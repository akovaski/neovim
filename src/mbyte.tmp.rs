use ::libc;
#[c2rust::header_src = "internal:0"]
pub mod internal {
    #[c2rust::src_loc = "0:0"]
    pub type __builtin_va_list = [__va_list_tag; 1];
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "0:0"]
    pub struct __va_list_tag {
        pub gp_offset: libc::c_uint,
        pub fp_offset: libc::c_uint,
        pub overflow_arg_area: *mut libc::c_void,
        pub reg_save_area: *mut libc::c_void,
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/types.h:28"]
pub mod types_h {
    #[c2rust::src_loc = "36:1"]
    pub type __int8_t = libc::c_schar;
    #[c2rust::src_loc = "37:1"]
    pub type __uint8_t = libc::c_uchar;
    #[c2rust::src_loc = "38:1"]
    pub type __int16_t = libc::c_short;
    #[c2rust::src_loc = "39:1"]
    pub type __uint16_t = libc::c_ushort;
    #[c2rust::src_loc = "40:1"]
    pub type __int32_t = libc::c_int;
    #[c2rust::src_loc = "41:1"]
    pub type __uint32_t = libc::c_uint;
    #[c2rust::src_loc = "43:1"]
    pub type __int64_t = libc::c_long;
    #[c2rust::src_loc = "44:1"]
    pub type __uint64_t = libc::c_ulong;
    #[c2rust::src_loc = "144:1"]
    pub type __uid_t = libc::c_uint;
    #[c2rust::src_loc = "145:1"]
    pub type __gid_t = libc::c_uint;
    #[c2rust::src_loc = "158:1"]
    pub type __time_t = libc::c_long;
    #[c2rust::src_loc = "191:1"]
    pub type __ssize_t = libc::c_long;
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h:28"]
pub mod stdint_intn_h {
    #[c2rust::src_loc = "24:1"]
    pub type int8_t = __int8_t;
    #[c2rust::src_loc = "25:1"]
    pub type int16_t = __int16_t;
    #[c2rust::src_loc = "26:1"]
    pub type int32_t = __int32_t;
    #[c2rust::src_loc = "27:1"]
    pub type int64_t = __int64_t;
    use super::types_h::{__int8_t, __int16_t, __int32_t, __int64_t};
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:28"]
pub mod stdint_uintn_h {
    #[c2rust::src_loc = "24:1"]
    pub type uint8_t = __uint8_t;
    #[c2rust::src_loc = "25:1"]
    pub type uint16_t = __uint16_t;
    #[c2rust::src_loc = "26:1"]
    pub type uint32_t = __uint32_t;
    #[c2rust::src_loc = "27:1"]
    pub type uint64_t = __uint64_t;
    use super::types_h::{__uint8_t, __uint16_t, __uint32_t, __uint64_t};
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stddef.h:30"]
pub mod stddef_h {
    #[c2rust::src_loc = "62:1"]
    pub type size_t = libc::c_ulong;
    #[c2rust::src_loc = "105:11"]
    pub const NULL_0: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "105:11"]
    pub const NULL: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "105:11"]
    pub const NULL_1: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "105:11"]
    pub const NULL_2: libc::c_int = 0 as libc::c_int;
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stdarg.h:31"]
pub mod stdarg_h {
    #[c2rust::src_loc = "30:1"]
    pub type va_list = __builtin_va_list;
    use super::internal::__builtin_va_list;
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/types/wint_t.h:31"]
pub mod wint_t_h {
    #[c2rust::src_loc = "20:1"]
    pub type wint_t = libc::c_uint;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/types.h:34"]
pub mod nvim_types_h {
    // dummy to pass an ACL to a function
    // Shorthand for unsigned variables. Many systems, but not all, have u_char
// already defined, so we use char_u to avoid trouble.
    #[c2rust::src_loc = "11:1"]
    pub type char_u = libc::c_uchar;
    // Opaque handle used by API clients to refer to various objects in vim
    #[c2rust::src_loc = "17:1"]
    pub type handle_T = libc::c_int;
    // Opaque handle to a lua value. Must be free with `executor_free_luaref` when
// not needed anymore! LUA_NOREF represents missing reference, i e to indicate
// absent callback etc.
    #[c2rust::src_loc = "22:1"]
    pub type LuaRef = libc::c_int;
    // NVIM_TYPES_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/eval/typval.h:34"]
pub mod typval_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "255:9"]
    pub struct sctx_T {
        pub sc_sid: scid_T,
        pub sc_seq: libc::c_int,
        pub sc_lnum: linenr_T,
    }
    #[c2rust::src_loc = "245:1"]
    pub type scid_T = libc::c_int;
    // for linenr_T
    // / Type used for VimL VAR_NUMBER values
    // / Type used for VimL VAR_FLOAT values
    // / Refcount for dict or list that should not be freed
    // / Additional values for tv_list_alloc() len argument
    // / List length is not known in advance
  // /
  // / To be used when there is neither a way to know how many elements will be
  // / needed nor are any educated guesses.
    // / List length *should* be known, but is actually not
  // /
  // / All occurrences of this value should be eventually removed. This is for
  // / the case when the only reason why list length is not known is that it
  // / would be hard to code without refactoring, but refactoring is needed.
    // / List length may be known in advance, but it requires too much effort
  // /
  // / To be used when it looks impractical to determine list length.
    // / Maximal possible value of varnumber_T variable
    // / Mimimal possible value of varnumber_T variable
    // / %d printf format specifier for varnumber_T
    #[c2rust::src_loc = "65:1"]
    pub type dict_T = dictvar_S;
    // / Structure holding dictionary watcher
    // prevent recursion if the dict is changed in the callback
    // / Special variable values
    // /< v:false
    // /< v:true
    // /< v:null
    // / Variable lock status for typval_T.v_lock
    // /< Not locked.
    // /< User lock, can be unlocked.
    // /< Locked forever.
    // / VimL variable types, for use in typval_T.v_type
    // /< Unknown (unspecified) value.
    // /< Number, .v_number is used.
    // /< String, .v_string is used.
    // /< Function reference, .v_string is used as function name.
    // /< List, .v_list is used.
    // /< Dictionary, .v_dict is used.
    // /< Floating-point value, .v_float is used.
    // /< Special value (true, false, null), .v_special
                    // /< is used.
    // /< Partial, .v_partial is used.
    // / Structure that holds an internal variable value
    // /< Variable type.
    // /< Variable lock status.
    // /< Number, for VAR_NUMBER.
    // /< Special value, for VAR_SPECIAL.
    // /< Floating-point number, for VAR_FLOAT.
    // /< String, for VAR_STRING and VAR_FUNC, can be NULL.
    // /< List for VAR_LIST, can be NULL.
    // /< Dictionary for VAR_DICT, can be NULL.
    // /< Closure: function with args.
    // /< Actual value.
    // / Values for (struct dictvar_S).dv_scope
    // /< Not a scope dictionary.
    // /< Scope dictionary which requires prefix (a:, v:, …).
    // /< Scope dictionary which may be accessed without prefix
                      // /< (l:, g:).
    // / Structure to hold an item of a list
    // /< Next item in list.
    // /< Previous item in list.
    // /< Item value.
    // / Structure used by those that are using an item in a list
    // /< Item being watched.
    // /< Next watcher.
    // / Structure to hold info about a list
// / Order of members is optimized to reduce padding.
    // /< First item, NULL if none.
    // /< Last item, NULL if none.
    // /< First watcher, NULL if none.
    // /< When not NULL item at index "lv_idx".
    // /< Copied list used by deepcopy().
    // /< next list in used lists list.
    // /< Previous list in used lists list.
    // /< Reference count.
    // /< Number of items.
    // /< Index of a cached item, used for optimising repeated l[idx].
    // /< ID used by deepcopy().
    // /< Zero, VAR_LOCKED, VAR_FIXED.
    // Static list with 10 items. Use tv_list_init_static10() to initialize.
    // must be first
    /* Structure that holds scope dictionary itself. */
    /* Flags. */
    /* Key value. */
    // / Structure to hold a scope dictionary
// /
// / @warning Must be compatible with dictitem_T.
// /
// / For use in find_var_in_ht to pretend that it found dictionary item when it
// / finds scope dictionary.
    // / Structure to hold an item of a Dictionary
// /
// / @warning Must be compatible with ScopeDictDictItem.
// /
// / Also used for a variable.
    // / Flags for dictitem_T.di_flags
    // /< Read-only value
    // /< Value, read-only in the sandbox
    // /< Fixed value: cannot be :unlet or remove()d.
    // /< Locked value.
    // /< Separately allocated.
    // / Structure representing a Dictionary
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "231:8"]
    pub struct dictvar_S {
        pub dv_lock: VarLockStatus,
        pub dv_scope: ScopeType,
        pub dv_refcount: libc::c_int,
        pub dv_copyID: libc::c_int,
        pub dv_hashtab: hashtab_T,
        pub dv_copydict: *mut dict_T,
        pub dv_used_next: *mut dict_T,
        pub dv_used_prev: *mut dict_T,
        pub watchers: QUEUE,
    }
    #[c2rust::src_loc = "138:9"]
    pub type ScopeType = libc::c_uint;
    #[c2rust::src_loc = "141:3"]
    pub const VAR_DEF_SCOPE: ScopeType = 2;
    #[c2rust::src_loc = "140:3"]
    pub const VAR_SCOPE: ScopeType = 1;
    #[c2rust::src_loc = "139:3"]
    pub const VAR_NO_SCOPE: ScopeType = 0;
    #[c2rust::src_loc = "102:9"]
    pub type VarLockStatus = libc::c_uint;
    #[c2rust::src_loc = "105:3"]
    pub const VAR_FIXED: VarLockStatus = 2;
    #[c2rust::src_loc = "104:3"]
    pub const VAR_LOCKED: VarLockStatus = 1;
    #[c2rust::src_loc = "103:3"]
    pub const VAR_UNLOCKED: VarLockStatus = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "212:9"]
    pub struct ScopeDictDictItem {
        pub di_tv: typval_T,
        pub di_flags: uint8_t,
        pub di_key: [char_u; 1],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "123:9"]
    pub struct typval_T {
        pub v_type: VarType,
        pub v_lock: VarLockStatus,
        pub vval: typval_vval_union,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "126:9"]
    pub union typval_vval_union {
        pub v_number: varnumber_T,
        pub v_special: SpecialVarValue,
        pub v_float: float_T,
        pub v_string: *mut char_u,
        pub v_list: *mut list_T,
        pub v_dict: *mut dict_T,
        pub v_partial: *mut partial_T,
    }
    #[c2rust::src_loc = "66:1"]
    pub type partial_T = partial_S;
    // /< Dictionary key watchers set by user code.
    // / Type used for script ID
    // / Format argument for scid_T
    // SCript ConteXt (SCTX): identifies a script line.
// When sourcing a script "sc_lnum" is zero, "sourcing_lnum" is the current
// line number. When executing a user function "sc_lnum" is the line where the
// function was defined, "sourcing_lnum" is the line number inside the
// function.  When stored with a function, mapping, option, etc. "sc_lnum" is
// the line number in the script "sc_sid".
    // script ID
    // sourcing sequence number
    // line number
    // Structure to hold info for a function that is currently being executed.
    // / Structure to hold info for a user function.
    // /< variable nr of arguments
    // /< nr of active calls
    // /< func_clear() was already called
    // /< arguments
    // /< function lines
    // /< true when func is being profiled
    // Profiling the function as a whole.
    // /< nr of calls
    // /< time spent in function + children
    // /< time spent in function itself
    // /< time spent in children this call
    // Profiling the function per line.
    // /< nr of times line was executed
    // /< time spent in a line + children
    // /< time spent in a line itself
    // /< start time for current line
    // /< time spent in children for this line
    // /< start wait time for current line
    // /< index of line being timed; -1 if none
    // /< line being timed was executed
    // /< SCTX where function was defined,
                                 // /< used for s: variables
    // /< reference count, see func_name_refcount()
    // /< l: local variables for closure
    // /< Name of function; can start with <SNR>123_
                                 // /< (<SNR> is K_SPECIAL KS_EXTRA KE_SNR)
    // / Maximum number of function arguments
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "299:8"]
    pub struct partial_S {
        pub pt_refcount: libc::c_int,
        pub pt_name: *mut char_u,
        pub pt_func: *mut ufunc_T,
        pub pt_auto: bool,
        pub pt_argc: libc::c_int,
        pub pt_argv: *mut typval_T,
        pub pt_dict: *mut dict_T,
    }
    #[c2rust::src_loc = "68:1"]
    pub type ufunc_T = ufunc;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "265:8"]
    pub struct ufunc {
        pub uf_varargs: libc::c_int,
        pub uf_flags: libc::c_int,
        pub uf_calls: libc::c_int,
        pub uf_cleared: bool,
        pub uf_args: garray_T,
        pub uf_lines: garray_T,
        pub uf_profiling: libc::c_int,
        pub uf_prof_initialized: libc::c_int,
        pub uf_tm_count: libc::c_int,
        pub uf_tm_total: proftime_T,
        pub uf_tm_self: proftime_T,
        pub uf_tm_children: proftime_T,
        pub uf_tml_count: *mut libc::c_int,
        pub uf_tml_total: *mut proftime_T,
        pub uf_tml_self: *mut proftime_T,
        pub uf_tml_start: proftime_T,
        pub uf_tml_children: proftime_T,
        pub uf_tml_wait: proftime_T,
        pub uf_tml_idx: libc::c_int,
        pub uf_tml_execed: libc::c_int,
        pub uf_script_ctx: sctx_T,
        pub uf_refcount: libc::c_int,
        pub uf_scoped: *mut funccall_T,
        pub uf_name: [char_u; 0],
    }
    #[c2rust::src_loc = "262:1"]
    pub type funccall_T = funccall_S;
    #[c2rust::src_loc = "64:1"]
    pub type list_T = listvar_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "164:8"]
    pub struct listvar_S {
        pub lv_first: *mut listitem_T,
        pub lv_last: *mut listitem_T,
        pub lv_watch: *mut listwatch_T,
        pub lv_idx_item: *mut listitem_T,
        pub lv_copylist: *mut list_T,
        pub lv_used_next: *mut list_T,
        pub lv_used_prev: *mut list_T,
        pub lv_refcount: libc::c_int,
        pub lv_len: libc::c_int,
        pub lv_idx: libc::c_int,
        pub lv_copyID: libc::c_int,
        pub lv_lock: VarLockStatus,
    }
    #[c2rust::src_loc = "146:1"]
    pub type listitem_T = listitem_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "148:8"]
    pub struct listitem_S {
        pub li_next: *mut listitem_T,
        pub li_prev: *mut listitem_T,
        pub li_tv: typval_T,
    }
    #[c2rust::src_loc = "155:1"]
    pub type listwatch_T = listwatch_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "157:8"]
    pub struct listwatch_S {
        pub lw_item: *mut listitem_T,
        pub lw_next: *mut listwatch_T,
    }
    #[c2rust::src_loc = "30:1"]
    pub type float_T = libc::c_double;
    #[c2rust::src_loc = "95:9"]
    pub type SpecialVarValue = libc::c_uint;
    #[c2rust::src_loc = "98:3"]
    pub const kSpecialVarNull: SpecialVarValue = 2;
    #[c2rust::src_loc = "97:3"]
    pub const kSpecialVarTrue: SpecialVarValue = 1;
    #[c2rust::src_loc = "96:3"]
    pub const kSpecialVarFalse: SpecialVarValue = 0;
    #[c2rust::src_loc = "26:1"]
    pub type varnumber_T = int64_t;
    #[c2rust::src_loc = "109:9"]
    pub type VarType = libc::c_uint;
    #[c2rust::src_loc = "119:3"]
    pub const VAR_PARTIAL: VarType = 8;
    #[c2rust::src_loc = "117:3"]
    pub const VAR_SPECIAL: VarType = 7;
    #[c2rust::src_loc = "116:3"]
    pub const VAR_FLOAT: VarType = 6;
    #[c2rust::src_loc = "115:3"]
    pub const VAR_DICT: VarType = 5;
    #[c2rust::src_loc = "114:3"]
    pub const VAR_LIST: VarType = 4;
    #[c2rust::src_loc = "113:3"]
    pub const VAR_FUNC: VarType = 3;
    #[c2rust::src_loc = "112:3"]
    pub const VAR_STRING: VarType = 2;
    #[c2rust::src_loc = "111:3"]
    pub const VAR_NUMBER: VarType = 1;
    #[c2rust::src_loc = "110:3"]
    pub const VAR_UNKNOWN: VarType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:9"]
    pub struct Callback {
        pub data: C2RustUnnamed_8,
        pub type_0: CallbackType,
    }
    #[c2rust::src_loc = "70:9"]
    pub type CallbackType = libc::c_uint;
    #[c2rust::src_loc = "73:3"]
    pub const kCallbackPartial: CallbackType = 2;
    #[c2rust::src_loc = "72:3"]
    pub const kCallbackFuncref: CallbackType = 1;
    #[c2rust::src_loc = "71:3"]
    pub const kCallbackNone: CallbackType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "77:3"]
    pub union C2RustUnnamed_8 {
        pub funcref: *mut char_u,
        pub partial: *mut partial_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "86:16"]
    pub struct dict_watcher {
        pub callback: Callback,
        pub key_pattern: *mut libc::c_char,
        pub key_pattern_len: size_t,
        pub node: QUEUE,
        pub busy: bool,
    }
    #[c2rust::src_loc = "86:1"]
    pub type DictWatcher = dict_watcher;
    // In a hashtab item "hi_key" points to "di_key" in a dictitem.
// This avoids adding a pointer to the hashtab item.
    // / Convert a hashitem pointer to a dictitem pointer
    // / Increase reference count for a given list
// /
// / Does nothing for NULL lists.
// /
// / @param[in,out]  l  List to modify.
    #[inline(always)]
    #[c2rust::src_loc = "436:1"]
    pub unsafe extern "C" fn tv_list_ref(l: *mut list_T) {
        if l.is_null() { return }
        (*l).lv_refcount += 1;
    }
    // / Set a list as the return value
// /
// / @param[out]  tv  Object to receive the list
// / @param[in,out]  l  List to pass to the object
    #[inline(always)]
    #[c2rust::src_loc = "451:1"]
    pub unsafe extern "C" fn tv_list_set_ret(tv: *mut typval_T,
                                             l: *mut list_T) {
        (*tv).v_type = VAR_LIST;
        (*tv).vval.v_list = l;
        tv_list_ref(l);
    }
    // / Get list lock status
// /
// / Returns VAR_FIXED for NULL lists.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "466:1"]
    pub unsafe extern "C" fn tv_list_locked(l: *const list_T)
     -> VarLockStatus {
        if l.is_null() { return VAR_FIXED }
        return (*l).lv_lock;
    }
    // / Set list lock status
// /
// / May only “set” VAR_FIXED for NULL lists.
// /
// / @param[out]  l  List to modify.
// / @param[in]  lock  New lock status.
    #[inline]
    #[c2rust::src_loc = "480:1"]
    pub unsafe extern "C" fn tv_list_set_lock(l: *mut list_T,
                                              lock: VarLockStatus) {
        if l.is_null() {
            if lock as libc::c_uint ==
                   VAR_FIXED as libc::c_int as libc::c_uint {
            } else {
                __assert_fail(b"lock == VAR_FIXED\x00" as *const u8 as
                                  *const libc::c_char,
                              b"/home/vole/neovim/src/nvim/eval/typval.h\x00"
                                  as *const u8 as *const libc::c_char,
                              484 as libc::c_int as libc::c_uint,
                              __ASSERT_FUNCTION_0.as_ptr());
            }
            return
        }
        (*l).lv_lock = lock;
    }
    // / Set list copyID
// /
// / Does not expect NULL list, be careful.
// /
// / @param[out]  l  List to modify.
// / @param[in]  copyid  New copyID.
    #[inline]
    #[c2rust::src_loc = "496:1"]
    pub unsafe extern "C" fn tv_list_set_copyid(l: *mut list_T,
                                                copyid: libc::c_int) {
        (*l).lv_copyID = copyid;
    }
    // / Get the number of items in a list
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "509:1"]
    pub unsafe extern "C" fn tv_list_len(l: *const list_T) -> libc::c_int {
        if l.is_null() { return 0 as libc::c_int }
        return (*l).lv_len;
    }
    // / Get list copyID
// /
// / Does not expect NULL list, be careful.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "526:1"]
    pub unsafe extern "C" fn tv_list_copyid(l: *const list_T) -> libc::c_int {
        return (*l).lv_copyID;
    }
    // / Get latest list copy
// /
// / Gets lv_copylist field assigned by tv_list_copy() earlier.
// /
// / Does not expect NULL list, be careful.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "541:1"]
    pub unsafe extern "C" fn tv_list_latest_copy(l: *const list_T)
     -> *mut list_T {
        return (*l).lv_copylist;
    }
    // / Normalize index: that is, return either -1 or non-negative index
// /
// / @param[in]  l  List to index. Used to get length.
// / @param[in]  n  List index, possibly negative.
// /
// / @return -1 or list index in range [0, tv_list_len(l)).
    #[inline]
    #[c2rust::src_loc = "555:1"]
    pub unsafe extern "C" fn tv_list_uidx(l: *const list_T,
                                          mut n: libc::c_int) -> libc::c_int {
        // Negative index is relative to the end.
        if n < 0 as libc::c_int { n += tv_list_len(l) }
        // Check for index out of range.
        if n < 0 as libc::c_int || n >= tv_list_len(l) {
            return -(1 as libc::c_int)
        }
        return n;
    }
    // / Check whether list has watchers
// /
// / E.g. is referenced by a :for loop.
// /
// / @param[in]  l  List to check.
// /
// / @return true if there are watchers, false otherwise.
    #[inline]
    #[c2rust::src_loc = "579:1"]
    pub unsafe extern "C" fn tv_list_has_watchers(l: *const list_T) -> bool {
        return !l.is_null() && !(*l).lv_watch.is_null();
    }
    // / Get first list item
// /
// / @param[in]  l  List to get item from.
// /
// / @return List item or NULL in case of an empty list.
    #[inline]
    #[c2rust::src_loc = "592:1"]
    pub unsafe extern "C" fn tv_list_first(l: *const list_T)
     -> *mut listitem_T {
        if l.is_null() { return NULL_1 as *mut listitem_T }
        return (*l).lv_first;
    }
    // / Get last list item
// /
// / @param[in]  l  List to get item from.
// /
// / @return List item or NULL in case of an empty list.
    #[inline]
    #[c2rust::src_loc = "610:1"]
    pub unsafe extern "C" fn tv_list_last(l: *const list_T)
     -> *mut listitem_T {
        if l.is_null() { return NULL_1 as *mut listitem_T }
        return (*l).lv_last;
    }
    // / Set a dictionary as the return value
// /
// / @param[out]  tv  Object to receive the dictionary
// / @param[in,out]  d  Dictionary to pass to the object
    #[inline(always)]
    #[c2rust::src_loc = "627:1"]
    pub unsafe extern "C" fn tv_dict_set_ret(tv: *mut typval_T,
                                             d: *mut dict_T) {
        (*tv).v_type = VAR_DICT;
        (*tv).vval.v_dict = d;
        if !d.is_null() { (*d).dv_refcount += 1 };
    }
    // / Get the number of items in a Dictionary
// /
// / @param[in]  d  Dictionary to check.
    #[inline]
    #[c2rust::src_loc = "642:1"]
    pub unsafe extern "C" fn tv_dict_len(d: *const dict_T) -> libc::c_long {
        if d.is_null() { return 0 as libc::c_long }
        return (*d).dv_hashtab.ht_used as libc::c_long;
    }
    // / Check if dictionary is watched
// /
// / @param[in]  d  Dictionary to check.
// /
// / @return true if there is at least one watcher.
    #[inline]
    #[c2rust::src_loc = "658:1"]
    pub unsafe extern "C" fn tv_dict_is_watched(d: *const dict_T) -> bool {
        return !d.is_null() && QUEUE_EMPTY(&(*d).watchers) == 0;
    }
    // / Initialize VimL object
// /
// / Initializes to unlocked VAR_UNKNOWN object.
// /
// / @param[out]  tv  Object to initialize.
    #[inline]
    #[c2rust::src_loc = "668:1"]
    pub unsafe extern "C" fn tv_init(tv: *mut typval_T) {
        if !tv.is_null() {
            memset(tv as *mut libc::c_void, 0 as libc::c_int,
                   ::std::mem::size_of::<typval_T>() as libc::c_ulong);
        };
    }
    // / Iterate over a list
// /
// / @param  modifier  Modifier: expected to be const or nothing, volatile should
// /                   also work if you have any uses for the volatile list.
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // / Iterate over a list
// /
// / To be used when you need to modify list or values you iterate over, use
// / #TV_LIST_ITER_CONST if you don’t.
// /
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // / Iterate over a list
// /
// / To be used when you don’t need to modify list or values you iterate over,
// / use #TV_LIST_ITER if you do.
// /
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // Below macros are macros to avoid duplicating code for functionally identical
// const and non-const function variants.
    // / Get typval_T out of list item
// /
// / @param[in]  li  List item to get typval_T from, must not be NULL.
// /
// / @return Pointer to typval_T.
    // / Get next list item given the current one
// /
// / @param[in]  l  List to get item from.
// / @param[in]  li  List item to get typval_T from.
// /
// / @return Pointer to the next item or NULL.
    // / Get previous list item given the current one
// /
// / @param[in]  l  List to get item from.
// / @param[in]  li  List item to get typval_T from.
// /
// / @return Pointer to the previous item or NULL.
    // List argument is not used currently, but it is a must for lists implemented
// as a pair (size(in list), array) without terminator - basically for lists on
// top of kvec.
    // / Iterate over a dictionary
// /
// / @param[in]  d  Dictionary to iterate over.
// / @param  di  Name of the variable with current dictitem_T entry.
// / @param  code  Cycle body.
    // FIXME circular dependency, cannot import message.h.
    // / Get the float value
// /
// / Raises an error if object is not number or floating-point.
// /
// / @param[in]  tv  VimL object to get value from.
// / @param[out]  ret_f  Location where resulting float is stored.
// /
// / @return true in case of success, false if tv is not a number or float.
    #[inline]
    #[c2rust::src_loc = "790:1"]
    pub unsafe extern "C" fn tv_get_float_chk(tv: *const typval_T,
                                              ret_f: *mut float_T) -> bool {
        if (*tv).v_type as libc::c_uint ==
               VAR_FLOAT as libc::c_int as libc::c_uint {
            *ret_f = (*tv).vval.v_float;
            return true_0 != 0
        }
        if (*tv).v_type as libc::c_uint ==
               VAR_NUMBER as libc::c_int as libc::c_uint {
            *ret_f = (*tv).vval.v_number as float_T;
            return true_0 != 0
        }
        emsgf(b"%s\x00" as *const u8 as *const libc::c_char,
              gettext(b"E808: Number or Float required\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char));
        return false_0 != 0;
    }
    // / Compute the `DictWatcher` address from a QUEUE node.
// /
// / This only exists for .asan-blacklist (ASAN doesn't handle QUEUE_DATA pointer
// / arithmetic).
    #[inline(always)]
    #[c2rust::src_loc = "813:1"]
    pub unsafe extern "C" fn tv_dict_watcher_node_data(mut q: *mut QUEUE)
     -> *mut DictWatcher {
        return (q as
                    *mut libc::c_char).offset(-(32 as libc::c_ulong as isize))
                   as *mut DictWatcher;
    }
    // / Check whether given typval_T contains a function
// /
// / That is, whether it contains VAR_FUNC or VAR_PARTIAL.
// /
// / @param[in]  tv  Typval to check.
// /
// / @return True if it is a function or a partial, false otherwise.
    #[inline]
    #[c2rust::src_loc = "828:1"]
    pub unsafe extern "C" fn tv_is_func(tv: typval_T) -> bool {
        return tv.v_type as libc::c_uint ==
                   VAR_FUNC as libc::c_int as libc::c_uint ||
                   tv.v_type as libc::c_uint ==
                       VAR_PARTIAL as libc::c_int as libc::c_uint;
    }
    use super::pos_h::linenr_T;
    use super::hashtab_h::hashtab_T;
    use super::queue_h::{QUEUE, QUEUE_EMPTY};
    use super::stdint_uintn_h::uint8_t;
    use super::nvim_types_h::char_u;
    use super::garray_h::garray_T;
    use super::profile_h::proftime_T;
    use super::stdint_intn_h::int64_t;
    use super::stddef_h::{size_t, NULL_1};
    use super::assert_h::{__assert_fail, __ASSERT_FUNCTION_0};
    use super::string_h::memset;
    use super::stdbool_h::{true_0, false_0};
    use super::message_h_generated_h::emsgf;
    use super::libintl_h::gettext;
    extern "C" {
        #[c2rust::src_loc = "262:16"]
        pub type funccall_S;
    }
    // NVIM_EVAL_TYPVAL_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/pos.h:34"]
pub mod pos_h {
    #[c2rust::src_loc = "4:1"]
    pub type linenr_T = libc::c_long;
    // line number type
    // / Format used to print values which have linenr_T type
    // / Column number type
    #[c2rust::src_loc = "9:1"]
    pub type colnr_T = libc::c_int;
    // / Maximal column number, 31 bits
    #[c2rust::src_loc = "16:1"]
    pub type C2RustUnnamed = libc::c_uint;
    #[c2rust::src_loc = "16:8"]
    pub const MAXCOL: C2RustUnnamed = 2147483647;
    /*
 * position in file or buffer
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:9"]
    pub struct pos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
        pub coladd: colnr_T,
    }
    /*
 * Same, but without coladd.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:9"]
    pub struct lpos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
    }
    // NVIM_POS_H
}
#[c2rust::header_src = "/usr/include/ctype.h:34"]
pub mod ctype_h {
    #[c2rust::src_loc = "46:1"]
    pub type C2RustUnnamed_0 = libc::c_uint;
    #[c2rust::src_loc = "59:3"]
    pub const _ISalnum: C2RustUnnamed_0 = 8;
    #[c2rust::src_loc = "58:3"]
    pub const _ISpunct: C2RustUnnamed_0 = 4;
    #[c2rust::src_loc = "57:3"]
    pub const _IScntrl: C2RustUnnamed_0 = 2;
    #[c2rust::src_loc = "56:3"]
    pub const _ISblank: C2RustUnnamed_0 = 1;
    #[c2rust::src_loc = "55:3"]
    pub const _ISgraph: C2RustUnnamed_0 = 32768;
    #[c2rust::src_loc = "54:3"]
    pub const _ISprint: C2RustUnnamed_0 = 16384;
    #[c2rust::src_loc = "53:3"]
    pub const _ISspace: C2RustUnnamed_0 = 8192;
    #[c2rust::src_loc = "52:3"]
    pub const _ISxdigit: C2RustUnnamed_0 = 4096;
    #[c2rust::src_loc = "51:3"]
    pub const _ISdigit: C2RustUnnamed_0 = 2048;
    #[c2rust::src_loc = "50:3"]
    pub const _ISalpha: C2RustUnnamed_0 = 1024;
    #[c2rust::src_loc = "49:3"]
    pub const _ISlower: C2RustUnnamed_0 = 512;
    #[c2rust::src_loc = "48:3"]
    pub const _ISupper: C2RustUnnamed_0 = 256;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "79:1"]
        pub fn __ctype_b_loc() -> *mut *const libc::c_ushort;
        #[no_mangle]
        #[c2rust::src_loc = "125:12"]
        pub fn toupper(_: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "122:12"]
        pub fn tolower(_: libc::c_int) -> libc::c_int;
    }
}
#[c2rust::header_src = "/usr/include/stdio.h:34"]
pub mod stdio_h {
    #[c2rust::src_loc = "77:1"]
    pub type ssize_t = __ssize_t;
    use super::types_h::__ssize_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "334:12"]
        pub fn sprintf(_: *mut libc::c_char, _: *const libc::c_char, _: ...)
         -> libc::c_int;
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/sys/types.h:34"]
pub mod sys_types_h {
    #[c2rust::src_loc = "64:1"]
    pub type gid_t = __gid_t;
    #[c2rust::src_loc = "79:1"]
    pub type uid_t = __uid_t;
    use super::types_h::{__gid_t, __uid_t};
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/types/time_t.h:34"]
pub mod time_t_h {
    #[c2rust::src_loc = "7:1"]
    pub type time_t = __time_t;
    use super::types_h::__time_t;
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h:34"]
pub mod pthreadtypes_arch_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "65:8"]
    pub struct __pthread_rwlock_arch_t {
        pub __readers: libc::c_uint,
        pub __writers: libc::c_uint,
        pub __wrphase_futex: libc::c_uint,
        pub __writers_futex: libc::c_uint,
        pub __pad3: libc::c_uint,
        pub __pad4: libc::c_uint,
        pub __cur_writer: libc::c_int,
        pub __shared: libc::c_int,
        pub __rwelision: libc::c_schar,
        pub __pad1: [libc::c_uchar; 7],
        pub __pad2: libc::c_ulong,
        pub __flags: libc::c_uint,
    }
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h:34"]
pub mod thread_shared_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "82:16"]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[c2rust::src_loc = "82:1"]
    pub type __pthread_list_t = __pthread_internal_list;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "118:8"]
    pub struct __pthread_mutex_s {
        pub __lock: libc::c_int,
        pub __count: libc::c_uint,
        pub __owner: libc::c_int,
        pub __nusers: libc::c_uint,
        pub __kind: libc::c_int,
        pub __spins: libc::c_short,
        pub __elision: libc::c_short,
        pub __list: __pthread_list_t,
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h:34"]
pub mod pthreadtypes_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "67:9"]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [libc::c_char; 40],
        pub __align: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "86:9"]
    pub union pthread_rwlock_t {
        pub __data: __pthread_rwlock_arch_t,
        pub __size: [libc::c_char; 56],
        pub __align: libc::c_long,
    }
    use super::thread_shared_types_h::__pthread_mutex_s;
    use super::pthreadtypes_arch_h::__pthread_rwlock_arch_t;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/hashtab.h:34"]
pub mod hashtab_h {
    // / Type for hash number (hash calculation result).
    #[c2rust::src_loc = "14:1"]
    pub type hash_T = size_t;
    // / The address of "hash_removed" is used as a magic number
// / for hi_key to indicate a removed item.
    // / Hashtable item.
// /
// / Each item has a NUL terminated string key.
// / A key can appear only once in the table.
// /
// / A hash number is computed from the key for quick lookup.  When the hashes
// / of two different keys point to the same entry an algorithm is used to
// / iterate over other entries in the table until the right one is found.
// / To make the iteration work removed keys are different from entries where a
// / key was never present.
// /
// / Note that this does not contain a pointer to the key and another pointer to
// / the value. Instead, it is assumed that the key is contained within the
// / value, so that you can get a pointer to the value subtracting an offset from
// / the pointer to the key.
// / This reduces the size of this item by 1/3.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:16"]
    pub struct hashitem_S {
        pub hi_hash: hash_T,
        pub hi_key: *mut char_u,
    }
    #[c2rust::src_loc = "38:1"]
    pub type hashitem_T = hashitem_S;
    // / Initial size for a hashtable.
// / Our items are relatively small and growing is expensive, thus start with 16.
// / Must be a power of 2.
    // / An array-based hashtable.
// /
// / Keys are NUL terminated strings. They cannot be repeated within a table.
// / Values are of any type.
// /
// / The hashtable grows to accommodate more entries when needed.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "62:16"]
    pub struct hashtable_S {
        pub ht_mask: hash_T,
        pub ht_used: size_t,
        pub ht_filled: size_t,
        pub ht_locked: libc::c_int,
        pub ht_array: *mut hashitem_T,
        pub ht_smallarray: [hashitem_T; 16],
    }
    #[c2rust::src_loc = "62:1"]
    pub type hashtab_T = hashtable_S;
    use super::stddef_h::size_t;
    use super::nvim_types_h::char_u;
    // / initial array
    // NVIM_HASHTAB_H
    // / Iterate over a hashtab
// /
// / @param[in]  ht  Hashtab to iterate over.
// / @param  hi  Name of the variable with current hashtab entry.
// / @param  code  Cycle body.
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/garray.h:34"]
pub mod garray_h {
    // for size_t
    // for char_u
    // / Structure used for growing arrays.
// / This is used to store information that only grows, is deleted all at
// / once, and needs to be accessed by index.  See ga_clear() and ga_grow().
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:16"]
    pub struct growarray {
        pub ga_len: libc::c_int,
        pub ga_maxlen: libc::c_int,
        pub ga_itemsize: libc::c_int,
        pub ga_growsize: libc::c_int,
        pub ga_data: *mut libc::c_void,
    }
    #[c2rust::src_loc = "12:1"]
    pub type garray_T = growarray;
    #[inline]
    #[c2rust::src_loc = "47:1"]
    pub unsafe extern "C" fn ga_append_via_ptr(mut gap: *mut garray_T,
                                               mut item_size: size_t)
     -> *mut libc::c_void {
        if item_size as libc::c_int != (*gap).ga_itemsize {
            logmsg(WARN_LOG_LEVEL, NULL as *const libc::c_char,
                   (*::std::mem::transmute::<&[u8; 18],
                                             &[libc::c_char; 18]>(b"ga_append_via_ptr\x00")).as_ptr(),
                   50 as libc::c_int, true_0 != 0,
                   b"wrong item size (%zu), should be %d\x00" as *const u8 as
                       *const libc::c_char, item_size, (*gap).ga_itemsize);
        }
        ga_grow(gap, 1 as libc::c_int);
        let fresh0 = (*gap).ga_len;
        (*gap).ga_len = (*gap).ga_len + 1;
        return ((*gap).ga_data as
                    *mut libc::c_char).offset(item_size.wrapping_mul(fresh0 as
                                                                         size_t)
                                                  as isize) as
                   *mut libc::c_void;
    }
    use super::stddef_h::{size_t, NULL};
    use super::log_h_generated_h::logmsg;
    use super::log_h::WARN_LOG_LEVEL;
    use super::stdbool_h::true_0;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "38:1"]
        pub fn ga_grow(gap: *mut garray_T, n: libc::c_int);
    }
    // pointer to the first item
    // NVIM_GARRAY_H
    // / Call `free` for every pointer stored in the garray and then frees the
// / garray.
// /
// / @param gap the garray to be freed
    // / Deep free a garray of specific type using a custom free function.
// / Items in the array as well as the array itself are freed.
// /
// / @param gap the garray to be freed
// / @param item_type type of the item in the garray
// / @param free_item_fn free function that takes (*item_type) as parameter
}
#[c2rust::header_src = "/usr/include/iconv.h:34"]
pub mod iconv_h {
    #[c2rust::src_loc = "29:1"]
    pub type iconv_t = *mut libc::c_void;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "37:1"]
        pub fn iconv_open(__tocode: *const libc::c_char,
                          __fromcode: *const libc::c_char) -> iconv_t;
        #[no_mangle]
        #[c2rust::src_loc = "42:1"]
        pub fn iconv(__cd: iconv_t, __inbuf: *mut *mut libc::c_char,
                     __inbytesleft: *mut size_t,
                     __outbuf: *mut *mut libc::c_char,
                     __outbytesleft: *mut size_t) -> size_t;
        #[no_mangle]
        #[c2rust::src_loc = "51:1"]
        pub fn iconv_close(__cd: iconv_t) -> libc::c_int;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mbyte.h:34"]
pub mod mbyte_h {
    // For indirect
    // for char_u
    /*
 * Return byte length of character that starts with byte "b".
 * Returns 1 for a single-byte character.
 * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.
 * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!
 */
    // max length of an unicode char
    /* properties used in enc_canon_table[] (first three mutually exclusive) */
    /* Unicode: Big endian */
    /* Unicode: Little endian */
    /* Unicode: UCS-2 */
    /* Unicode: UCS-4 */
    /* Unicode: UTF-16 */
    /* Latin1 */
    /* Latin9 */
    /* Mac Roman (not Macro Man! :-) */
    // TODO(bfredl): eventually we should keep only one of the namings
    // / Flags for vimconv_T
    #[c2rust::src_loc = "47:9"]
    pub type C2RustUnnamed_1 = libc::c_uint;
    #[c2rust::src_loc = "53:3"]
    pub const CONV_ICONV: C2RustUnnamed_1 = 5;
    #[c2rust::src_loc = "52:3"]
    pub const CONV_TO_LATIN9: C2RustUnnamed_1 = 4;
    #[c2rust::src_loc = "51:3"]
    pub const CONV_TO_LATIN1: C2RustUnnamed_1 = 3;
    #[c2rust::src_loc = "50:3"]
    pub const CONV_9_TO_UTF8: C2RustUnnamed_1 = 2;
    #[c2rust::src_loc = "49:3"]
    pub const CONV_TO_UTF8: C2RustUnnamed_1 = 1;
    #[c2rust::src_loc = "48:3"]
    pub const CONV_NONE: C2RustUnnamed_1 = 0;
    // / Structure used for string conversions
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "63:9"]
    pub struct vimconv_T {
        pub vc_type: libc::c_int,
        pub vc_factor: libc::c_int,
        pub vc_fd: iconv_t,
        pub vc_fail: bool,
    }
    #[c2rust::src_loc = "26:9"]
    pub const ENC_8BIT: libc::c_int = 0x1 as libc::c_int;
    #[c2rust::src_loc = "27:9"]
    pub const ENC_DBCS: libc::c_int = 0x2 as libc::c_int;
    #[c2rust::src_loc = "39:9"]
    pub const ENC_MACROMAN: libc::c_int = 0x800 as libc::c_int;
    #[c2rust::src_loc = "34:9"]
    pub const ENC_4BYTE: libc::c_int = 0x80 as libc::c_int;
    #[c2rust::src_loc = "31:9"]
    pub const ENC_ENDIAN_L: libc::c_int = 0x20 as libc::c_int;
    #[c2rust::src_loc = "28:9"]
    pub const ENC_UNICODE: libc::c_int = 0x4 as libc::c_int;
    #[c2rust::src_loc = "30:9"]
    pub const ENC_ENDIAN_B: libc::c_int = 0x10 as libc::c_int;
    #[c2rust::src_loc = "35:9"]
    pub const ENC_2WORD: libc::c_int = 0x100 as libc::c_int;
    #[c2rust::src_loc = "33:9"]
    pub const ENC_2BYTE: libc::c_int = 0x40 as libc::c_int;
    #[c2rust::src_loc = "38:9"]
    pub const ENC_LATIN9: libc::c_int = 0x400 as libc::c_int;
    #[c2rust::src_loc = "37:9"]
    pub const ENC_LATIN1: libc::c_int = 0x200 as libc::c_int;
    #[c2rust::src_loc = "42:9"]
    pub const mb_ptr2len:
              unsafe extern "C" fn(_: *const char_u) -> libc::c_int =
        utfc_ptr2len;
    // / Compare strings
// /
// / @param[in]  ic  True if case is to be ignored.
// /
// / @return 0 if s1 == s2, <0 if s1 < s2, >0 if s1 > s2.
    #[inline]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn mb_strcmp_ic(mut ic: bool,
                                          mut s1: *const libc::c_char,
                                          mut s2: *const libc::c_char)
     -> libc::c_int {
        return if ic as libc::c_int != 0 {
                   mb_stricmp(s1, s2)
               } else { strcmp(s1, s2) };
    }
    use super::iconv_h::iconv_t;
    use super::{utfc_ptr2len, mb_stricmp};
    use super::nvim_types_h::char_u;
    use super::string_h::strcmp;
    // NVIM_MBYTE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/buffer_defs.h:34"]
pub mod buffer_defs_h {
    // for FILE
    #[c2rust::src_loc = "9:1"]
    pub type buf_T = file_buffer;
    // Forward declaration
    // Reference to a buffer that stores the value of buf_free_count.
// bufref_valid() only needs to check "buf" when the count differs.
    // for garray_T
    // for ScreenGrid
    // for HLF_COUNT
    // for pos_T, lpos_T and linenr_T
    // for the number window-local and buffer-local options
    // for jump list and tag stack sizes in a buffer and mark types
    // for u_header_T; needs buf_T.
    // for hashtab_T
    // for dict_T
    // for proftime_T
    // for String
    // for Map(K, V)
    // for kvec
    // for marktree
    /*
 * Flags for w_valid.
 * These are set when something in a window structure becomes invalid, except
 * when the cursor is moved.  Call check_cursor_moved() before testing one of
 * the flags.
 * These are reset when that thing has been updated and is valid again.
 *
 * Every function that invalidates one of these must call one of the
 * invalidate_* functions.
 *
 * w_valid is supposed to be used only in screen.c.  From other files, use the
 * functions that set or reset the flags.
 *
 * VALID_BOTLINE    VALID_BOTLINE_AP
 *     on       on      w_botline valid
 *     off      on      w_botline approximated
 *     off      off     w_botline not valid
 *     on       off     not possible
 */
    /* w_wrow (window row) is valid */
    /* w_wcol (window col) is valid */
    /* w_virtcol (file col) is valid */
    /* w_cline_height and w_cline_folded valid */
    /* w_cline_row is valid */
    /* w_botine and w_empty_rows are valid */
    /* w_botine is approximated */
    /* w_topline is valid (for cursor position) */
    // flags for b_flags
    // buffer has been recovered
    // need to check readonly when loading file
                                // into buffer (set by ":e", may be reset by
                                // ":buf")
    // file has never been loaded into buffer,
                                // many variables still need to be set
    // Set when file name is changed after
                                // starting to edit, reset when file is
                                // written out.
    // file didn't exist when editing started
    // Warned for BF_NEW and file created
    // got errors while reading the file
    // dummy buffer, only used internally
    // ":preserve" was used
    /* Mask to check for flags that prevent normal writing */
    // display tick type
    // for struct memline (it needs memfile_T)
    // for struct memfile, bhdr_T, blocknr_T... (it needs buf_T)
    // for regprog_T. Needs win_T and buf_T.
    // for synstate_T (needs reg_extmatch_T, win_T, buf_T)
    // for signlist_T
    /*
 * The taggy struct is used to store the information about a :tag command.
 */
    // tag name
    // cursor position BEFORE ":tag"
    // match number
    // buffer number used for cur_match
    // used with tagfunc
    /*
 * structure used to store one block of the stuff/redo/recording buffers
 */
    // pointer to next buffblock
    // contents (actually longer)
    /*
 * header used for the stuff buffer and the redo buffer
 */
    // first (dummy) block of list
    // buffblock for appending
    // index for reading
    // space in bh_curr for appending
    /*
 * Structure that contains all options that are local to a window.
 * Used twice in a window: for the current buffer and for all buffers.
 * Also used in wininfo_T.
 */
    /* 'arabic' */
    // 'breakindent'
    /* 'breakindentopt' */
    // 'diff'
    // 'foldcolumn'
    // 'fdc' saved for diff mode
    /* 'foldenable' */
    /* 'foldenable' saved for diff mode */
    /* 'foldignore' */
    /* 'foldlevel' */
    /* 'foldlevel' state saved for diff mode */
    /* 'foldmethod' */
    /* 'fdm' saved for diff mode */
    /* 'foldminlines' */
    /* 'foldnestmax' */
    /* 'foldexpr' */
    /* 'foldtext' */
    /* 'foldmarker' */
    /* 'linebreak' */
    /* 'list' */
    /* 'number' */
    /* 'relativenumber' */
    /* 'numberwidth' */
    /* 'winfixheight' */
    /* 'winfixwidth' */
    /* 'previewwindow' */
    /* 'rightleft' */
    /* 'rightleftcmd' */
    /* 'scroll' */
    /* 'spell' */
    /* 'cursorcolumn' */
    /* 'cursorline' */
    /* 'colorcolumn' */
    /* 'statusline' */
    /* 'scrollbind' */
    /* options were saved for starting diff mode */
    /* 'scrollbind' saved for diff mode*/
    /* 'wrap' */
    /* 'wrap' state saved for diff mode*/
    /* 'concealcursor' */
    /* 'conceallevel' */
    /* 'cursorbind' */
    /* 'cursorbind' state saved for diff mode*/
    // 'signcolumn'
    // 'winhighlight'
    // 'fillchars'
    // 'listchars'
    // 'winblend'
    // SCTXs for window-local options
    /*
 * Window info stored with a buffer.
 *
 * Two types of info are kept for a buffer which are associated with a
 * specific window:
 * 1. Each window can have a different line number associated with a buffer.
 * 2. The window-local options for a buffer work in a similar way.
 * The window-info is kept in a list at b_wininfo.  It is kept in
 * most-recently-used order.
 */
    /* next entry or NULL for last entry */
    /* previous entry or NULL for first entry */
    /* pointer to window that did set wi_fpos */
    /* last cursor position in the file */
    /* true when wi_opt has useful values */
    /* local window options */
    /* copy of w_fold_manual */
    /* clone of w_folds */
    /*
 * Argument list: Array of file names.
 * Used for the global argument list and the argument lists local to a window.
 *
 * TODO: move struct arglist to another header
 */
    /* growarray with the array of file names */
    /* number of windows using this arglist */
    // /< id of this arglist
    /*
 * For each argument remember the file name as it was given, and the buffer
 * number that contains the expanded file name (required for when ":cd" is
 * used.
 *
 * TODO: move aentry_T to another header
 */
    /* file name as specified */
    /* buffer number with expanded file name */
    /*
 * Used for the typeahead buffer: typebuf.
 */
    /* buffer for typed characters */
    /* mapping flags for characters in tb_buf[] */
    /* size of tb_buf[] */
    /* current position in tb_buf[] */
    /* number of valid bytes in tb_buf[] */
    /* nr of mapped bytes in tb_buf[] */
    /* nr of silently mapped bytes in tb_buf[] */
    /* nr of bytes without abbrev. in tb_buf[] */
    /* nr of time tb_buf was changed; never zero */
    /* Struct to hold the saved typeahead for save_typeahead(). */
    /* TRUE when save_typebuf valid */
    /*
 * Structure used for mappings and abbreviations.
 */
    // next mapblock in list
    // mapped from, lhs
    // mapped to, rhs
    // rhs as entered by the user
    // strlen(m_keys)
    // valid mode
    // if non-zero no re-mapping for m_str
    // <silent> used, don't echo commands
    // <nowait> used
    // <expr> used, m_str is an expression
    // SCTX where map was defined
    /*
 * Used for highlighting in the status line.
 */
    /* 0: no HL, 1-9: User HL, < 0 for syn ID */
    /* values for b_syn_spell: what to do with toplevel text */
    /* spell check if @Spell not defined */
    /* spell check toplevel text */
    /* don't spell check toplevel text */
    /* avoid #ifdefs for when b_spell is not available */
    /*
 * Used for :syntime: timing of executing a syntax pattern.
 */
    /* total time used */
    /* time of slowest call */
    /* nr of times used */
    /* nr of times matched */
    /*
 * These are items normally related to a buffer.  But when using ":ownsyntax"
 * a window may have its own instance.
 */
    // syntax keywords hash table
    // idem, ignore case
    // TRUE when error occurred in HL
    // true when 'redrawtime' reached
    // ignore case for :syn cmds
    // SYNSPL_ values
    // table for syntax patterns
    // table for syntax clusters
    // @Spell cluster ID or 0
    // @NoSpell cluster ID or 0
    // TRUE when there is an item with a
                                        // "containedin" argument
    // flags about how to sync
    // group to sync on
    // minimal sync lines offset
    // maximal sync lines offset
    // offset for multi-line pattern
    // line continuation pattern
    // line continuation program
    /* ignore-case flag for above */
    /* for ":syntax include" */
    /* auto-conceal for :syn cmds */
    /* number of patterns with the HL_FOLD
                                           flag set */
    /*
   * b_sst_array[] contains the state stack for a number of lines, for the
   * start of that line (col == 0).  This avoids having to recompute the
   * syntax state too often.
   * b_sst_array[] is allocated to hold the state for all displayed lines,
   * and states for 1 out of about 20 other lines.
   * b_sst_array        pointer to an array of synstate_T
   * b_sst_len          number of entries in b_sst_array[]
   * b_sst_first        pointer to first used entry in b_sst_array[] or NULL
   * b_sst_firstfree    pointer to first free entry in b_sst_array[] or NULL
   * b_sst_freecount    number of free entries in b_sst_array[]
   * b_sst_check_lnum   entries after this lnum need to be checked for
   *                    validity (MAXLNUM means no check needed)
   */
    // last display tick
    // for spell checking
    // list of pointers to slang_T, see spell.c
    // flags: is midword char
    // multi-byte midword chars
    // 'spellcapcheck'
    // program for 'spellcapcheck'
    // 'spellfile'
    // 'spelllang'
    // all CJK letters as OK
    // syntax iskeyword option
    // iskeyword option
    // / Type used for changedtick_di member in buf_T
// /
// / Primary exists so that literals of relevant type can be made.
    // Maximum number of maphash blocks we will have
    /*
 * buffer: structure that holds information about one file
 *
 * Several windows can share a single Buffer
 * A buffer is unallocated if there is no memfile for it.
 * A buffer is new if the associated file has never been loaded yet.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "485:8"]
    pub struct file_buffer {
        pub handle: handle_T,
        pub b_ml: memline_T,
        pub b_next: *mut buf_T,
        pub b_prev: *mut buf_T,
        pub b_nwindows: libc::c_int,
        pub b_flags: libc::c_int,
        pub b_locked: libc::c_int,
        pub b_ffname: *mut char_u,
        pub b_sfname: *mut char_u,
        pub b_fname: *mut char_u,
        pub file_id_valid: bool,
        pub file_id: FileID,
        pub b_changed: libc::c_int,
        pub changedtick_di: ChangedtickDictItem,
        pub b_last_changedtick: varnumber_T,
        pub b_last_changedtick_pum: varnumber_T,
        pub b_saving: bool,
        pub b_mod_set: bool,
        pub b_mod_top: linenr_T,
        pub b_mod_bot: linenr_T,
        pub b_mod_xlines: libc::c_long,
        pub b_wininfo: *mut wininfo_T,
        pub b_mtime: libc::c_long,
        pub b_mtime_read: libc::c_long,
        pub b_orig_size: uint64_t,
        pub b_orig_mode: libc::c_int,
        pub b_namedm: [fmark_T; 26],
        pub b_visual: visualinfo_T,
        pub b_visual_mode_eval: libc::c_int,
        pub b_last_cursor: fmark_T,
        pub b_last_insert: fmark_T,
        pub b_last_change: fmark_T,
        pub b_changelist: [fmark_T; 100],
        pub b_changelistlen: libc::c_int,
        pub b_new_change: bool,
        pub b_chartab: [uint64_t; 4],
        pub b_maphash: [*mut mapblock_T; 256],
        pub b_first_abbr: *mut mapblock_T,
        pub b_ucmds: garray_T,
        pub b_op_start: pos_T,
        pub b_op_start_orig: pos_T,
        pub b_op_end: pos_T,
        pub b_marks_read: bool,
        pub b_u_oldhead: *mut u_header_T,
        pub b_u_newhead: *mut u_header_T,
        pub b_u_curhead: *mut u_header_T,
        pub b_u_numhead: libc::c_int,
        pub b_u_synced: bool,
        pub b_u_seq_last: libc::c_long,
        pub b_u_save_nr_last: libc::c_long,
        pub b_u_seq_cur: libc::c_long,
        pub b_u_time_cur: time_t,
        pub b_u_save_nr_cur: libc::c_long,
        pub b_u_line_ptr: *mut char_u,
        pub b_u_line_lnum: linenr_T,
        pub b_u_line_colnr: colnr_T,
        pub b_scanned: bool,
        pub b_p_iminsert: libc::c_long,
        pub b_p_imsearch: libc::c_long,
        pub b_kmap_state: libc::c_short,
        pub b_kmap_ga: garray_T,
        pub b_p_initialized: bool,
        pub b_p_script_ctx: [LastSet; 80],
        pub b_p_ai: libc::c_int,
        pub b_p_ai_nopaste: libc::c_int,
        pub b_p_bkc: *mut char_u,
        pub b_bkc_flags: libc::c_uint,
        pub b_p_ci: libc::c_int,
        pub b_p_bin: libc::c_int,
        pub b_p_bomb: libc::c_int,
        pub b_p_bh: *mut char_u,
        pub b_p_bt: *mut char_u,
        pub b_has_qf_entry: libc::c_int,
        pub b_p_bl: libc::c_int,
        pub b_p_channel: libc::c_long,
        pub b_p_cin: libc::c_int,
        pub b_p_cino: *mut char_u,
        pub b_p_cink: *mut char_u,
        pub b_p_cinw: *mut char_u,
        pub b_p_com: *mut char_u,
        pub b_p_cms: *mut char_u,
        pub b_p_cpt: *mut char_u,
        pub b_p_cfu: *mut char_u,
        pub b_p_ofu: *mut char_u,
        pub b_p_tfu: *mut char_u,
        pub b_p_eol: libc::c_int,
        pub b_p_fixeol: libc::c_int,
        pub b_p_et: libc::c_int,
        pub b_p_et_nobin: libc::c_int,
        pub b_p_et_nopaste: libc::c_int,
        pub b_p_fenc: *mut char_u,
        pub b_p_ff: *mut char_u,
        pub b_p_ft: *mut char_u,
        pub b_p_fo: *mut char_u,
        pub b_p_flp: *mut char_u,
        pub b_p_inf: libc::c_int,
        pub b_p_isk: *mut char_u,
        pub b_p_def: *mut char_u,
        pub b_p_inc: *mut char_u,
        pub b_p_inex: *mut char_u,
        pub b_p_inex_flags: uint32_t,
        pub b_p_inde: *mut char_u,
        pub b_p_inde_flags: uint32_t,
        pub b_p_indk: *mut char_u,
        pub b_p_fp: *mut char_u,
        pub b_p_fex: *mut char_u,
        pub b_p_fex_flags: uint32_t,
        pub b_p_kp: *mut char_u,
        pub b_p_lisp: libc::c_int,
        pub b_p_menc: *mut char_u,
        pub b_p_mps: *mut char_u,
        pub b_p_ml: libc::c_int,
        pub b_p_ml_nobin: libc::c_int,
        pub b_p_ma: libc::c_int,
        pub b_p_nf: *mut char_u,
        pub b_p_pi: libc::c_int,
        pub b_p_qe: *mut char_u,
        pub b_p_ro: libc::c_int,
        pub b_p_sw: libc::c_long,
        pub b_p_scbk: libc::c_long,
        pub b_p_si: libc::c_int,
        pub b_p_sts: libc::c_long,
        pub b_p_sts_nopaste: libc::c_long,
        pub b_p_sua: *mut char_u,
        pub b_p_swf: libc::c_int,
        pub b_p_smc: libc::c_long,
        pub b_p_syn: *mut char_u,
        pub b_p_ts: libc::c_long,
        pub b_p_tw: libc::c_long,
        pub b_p_tw_nobin: libc::c_long,
        pub b_p_tw_nopaste: libc::c_long,
        pub b_p_wm: libc::c_long,
        pub b_p_wm_nobin: libc::c_long,
        pub b_p_wm_nopaste: libc::c_long,
        pub b_p_keymap: *mut char_u,
        pub b_p_gp: *mut char_u,
        pub b_p_mp: *mut char_u,
        pub b_p_efm: *mut char_u,
        pub b_p_ep: *mut char_u,
        pub b_p_path: *mut char_u,
        pub b_p_ar: libc::c_int,
        pub b_p_tags: *mut char_u,
        pub b_p_tc: *mut char_u,
        pub b_tc_flags: libc::c_uint,
        pub b_p_dict: *mut char_u,
        pub b_p_tsr: *mut char_u,
        pub b_p_ul: libc::c_long,
        pub b_p_udf: libc::c_int,
        pub b_p_lw: *mut char_u,
        pub b_ind_level: libc::c_int,
        pub b_ind_open_imag: libc::c_int,
        pub b_ind_no_brace: libc::c_int,
        pub b_ind_first_open: libc::c_int,
        pub b_ind_open_extra: libc::c_int,
        pub b_ind_close_extra: libc::c_int,
        pub b_ind_open_left_imag: libc::c_int,
        pub b_ind_jump_label: libc::c_int,
        pub b_ind_case: libc::c_int,
        pub b_ind_case_code: libc::c_int,
        pub b_ind_case_break: libc::c_int,
        pub b_ind_param: libc::c_int,
        pub b_ind_func_type: libc::c_int,
        pub b_ind_comment: libc::c_int,
        pub b_ind_in_comment: libc::c_int,
        pub b_ind_in_comment2: libc::c_int,
        pub b_ind_cpp_baseclass: libc::c_int,
        pub b_ind_continuation: libc::c_int,
        pub b_ind_unclosed: libc::c_int,
        pub b_ind_unclosed2: libc::c_int,
        pub b_ind_unclosed_noignore: libc::c_int,
        pub b_ind_unclosed_wrapped: libc::c_int,
        pub b_ind_unclosed_whiteok: libc::c_int,
        pub b_ind_matching_paren: libc::c_int,
        pub b_ind_paren_prev: libc::c_int,
        pub b_ind_maxparen: libc::c_int,
        pub b_ind_maxcomment: libc::c_int,
        pub b_ind_scopedecl: libc::c_int,
        pub b_ind_scopedecl_code: libc::c_int,
        pub b_ind_java: libc::c_int,
        pub b_ind_js: libc::c_int,
        pub b_ind_keep_case_label: libc::c_int,
        pub b_ind_hash_comment: libc::c_int,
        pub b_ind_cpp_namespace: libc::c_int,
        pub b_ind_if_for_while: libc::c_int,
        pub b_ind_cpp_extern_c: libc::c_int,
        pub b_no_eol_lnum: linenr_T,
        pub b_start_eol: libc::c_int,
        pub b_start_ffc: libc::c_int,
        pub b_start_fenc: *mut char_u,
        pub b_bad_char: libc::c_int,
        pub b_start_bomb: libc::c_int,
        pub b_bufvar: ScopeDictDictItem,
        pub b_vars: *mut dict_T,
        pub b_may_swap: bool,
        pub b_did_warn: bool,
        pub b_help: bool,
        pub b_spell: bool,
        pub b_prompt_text: *mut char_u,
        pub b_prompt_callback: Callback,
        pub b_prompt_interrupt: Callback,
        pub b_prompt_insert: libc::c_int,
        pub b_s: synblock_T,
        pub b_signlist: *mut signlist_T,
        pub b_signcols_max: libc::c_int,
        pub b_signcols: libc::c_int,
        pub terminal: *mut Terminal,
        pub additional_data: *mut dict_T,
        pub b_mapped_ctrl_c: libc::c_int,
        pub b_marktree: [MarkTree; 1],
        pub b_extmark_index: *mut Map_uint64_t_ExtmarkItem,
        pub b_extmark_ns: *mut Map_uint64_t_ExtmarkNs,
        pub update_channels: C2RustUnnamed_4,
        pub update_callbacks: C2RustUnnamed_3,
        pub update_need_codepoints: bool,
        pub deleted_bytes: size_t,
        pub deleted_codepoints: size_t,
        pub deleted_codeunits: size_t,
        pub flush_count: libc::c_int,
        pub b_luahl: bool,
        pub b_luahl_start: LuaRef,
        pub b_luahl_window: LuaRef,
        pub b_luahl_line: LuaRef,
        pub b_luahl_end: LuaRef,
        pub b_diff_failed: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "822:3"]
    pub struct C2RustUnnamed_3 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut BufUpdateCallbacks,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "459:9"]
    pub struct BufUpdateCallbacks {
        pub on_lines: LuaRef,
        pub on_bytes: LuaRef,
        pub on_changedtick: LuaRef,
        pub on_detach: LuaRef,
        pub utf_sizes: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "820:3"]
    pub struct C2RustUnnamed_4 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "393:9"]
    pub struct synblock_T {
        pub b_keywtab: hashtab_T,
        pub b_keywtab_ic: hashtab_T,
        pub b_syn_error: libc::c_int,
        pub b_syn_slow: bool,
        pub b_syn_ic: libc::c_int,
        pub b_syn_spell: libc::c_int,
        pub b_syn_patterns: garray_T,
        pub b_syn_clusters: garray_T,
        pub b_spell_cluster_id: libc::c_int,
        pub b_nospell_cluster_id: libc::c_int,
        pub b_syn_containedin: libc::c_int,
        pub b_syn_sync_flags: libc::c_int,
        pub b_syn_sync_id: int16_t,
        pub b_syn_sync_minlines: libc::c_long,
        pub b_syn_sync_maxlines: libc::c_long,
        pub b_syn_sync_linebreaks: libc::c_long,
        pub b_syn_linecont_pat: *mut char_u,
        pub b_syn_linecont_prog: *mut regprog_T,
        pub b_syn_linecont_time: syn_time_T,
        pub b_syn_linecont_ic: libc::c_int,
        pub b_syn_topgrp: libc::c_int,
        pub b_syn_conceal: libc::c_int,
        pub b_syn_folditems: libc::c_int,
        pub b_sst_array: *mut synstate_T,
        pub b_sst_len: libc::c_int,
        pub b_sst_first: *mut synstate_T,
        pub b_sst_firstfree: *mut synstate_T,
        pub b_sst_freecount: libc::c_int,
        pub b_sst_check_lnum: linenr_T,
        pub b_sst_lasttick: disptick_T,
        pub b_langp: garray_T,
        pub b_spell_ismw: [bool; 256],
        pub b_spell_ismw_mb: *mut char_u,
        pub b_p_spc: *mut char_u,
        pub b_cap_prog: *mut regprog_T,
        pub b_p_spf: *mut char_u,
        pub b_p_spl: *mut char_u,
        pub b_cjk: libc::c_int,
        pub b_syn_chartab: [char_u; 32],
        pub b_syn_isk: *mut char_u,
    }
    #[c2rust::src_loc = "98:1"]
    pub type win_T = window_S;
    // internal diff failed for this buffer
    /*
 * Stuff for diff mode.
 */
    // up to four buffers can be diff'ed
    /*
 * Each diffblock defines where a block of lines starts in each of the buffers
 * and how many lines it occupies in that buffer.  When the lines are missing
 * in the buffer the df_count[] is zero.  This is all counted in
 * buffer lines.
 * There is always at least one unchanged line in between the diffs.
 * Otherwise it would have been included in the diff above or below it.
 * df_lnum[] + df_count[] is the lnum below the change.  When in one buffer
 * lines have been inserted, in the other buffer df_lnum[] is the line below
 * the insertion and df_count[] is zero.  When appending lines at the end of
 * the buffer, df_lnum[] is one beyond the end!
 * This is using a linked list, because the number of differences is expected
 * to be reasonable small.  The list is sorted on lnum.
 */
    /* line number in buffer */
    /* nr of inserted/changed lines */
    // / Tab pages point to the top frame of each tab page.
// / Note: Most values are NOT valid for the current tab page!  Use "curwin",
// / "firstwin", etc. for that.  "tp_topframe" is always valid and can be
// / compared against "topframe" to find the current tab page.
    // /< next tabpage or NULL
    // /< topframe for the windows
    // /< current window in this Tab page
    // /< previous window in this Tab page
    // /< first window in this Tab page
    // /< last window in this Tab page
    // /< Rows when Tab page was left
    // /< Columns when Tab page was left
    // /< value of 'cmdheight' when frame size
                                    // /< was set
    // /< list of diffs is outdated
    // /< update diffs before redrawing
    // /< window layout snapshots
    // /< Variable for "t:" Dictionary.
    // /< Internal variables, local to tab page.
    // /< Absolute path of local cwd or NULL.
    /*
 * Structure to cache info for displayed lines in w_lines[].
 * Each logical line has one entry.
 * The entry tells how the logical line is currently displayed in the window.
 * This is updated when displaying the window.
 * When the display is changed (e.g., when clearing the screen) w_lines_valid
 * is changed to exclude invalid entries.
 * When making changes to the buffer, wl_valid is reset to indicate wl_size
 * may not reflect what is actually in the buffer.  When wl_valid is FALSE,
 * the entries can only be used to count the number of displayed lines used.
 * wl_lnum and wl_lastlnum are invalid too.
 */
    /* buffer line number for logical line */
    /* height in screen lines */
    /* TRUE values are valid for text in buffer */
    /* TRUE when this is a range of folded lines */
    /* last buffer line number for logical line */
    /*
 * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
 * or row (FR_ROW) layout or is a leaf, which has a window.
 */
    // FR_LEAF, FR_COL or FR_ROW
    // new width used in win_equal_rec()
    // new height used in win_equal_rec()
    // containing frame or NULL
    // frame right or below in same parent, NULL
                                // for last
    // frame left or above in same parent, NULL
                                // for first
    // fr_child and fr_win are mutually exclusive
    // first contained frame
    // window that fills this frame
    /* frame is a leaf */
    /* frame with a row of windows */
    /* frame with a column of windows */
    /*
 * Struct used for highlighting 'hlsearch' matches, matches defined by
 * ":match" and matches defined by match functions.
 * For 'hlsearch' there is one pattern for all windows.  For ":match" and the
 * match functions there is a different pattern for each window.
 */
    // points to the regexp program; contains last found
                        // match (may continue in next line)
    // the buffer to search for a match
    // the line to search for a match
    // attributes to be used for a match
    // attributes currently active in win_line()
    // first lnum to search for multi-line pat
    // in win_line() points to char where HL starts
    // in win_line() points to char where HL ends
    // position specified directly by matchaddpos()
    // for a time limit
    // / number of positions supported by matchaddpos()
    // / Same as lpos_T, but with additional field len.
    // /< line number
    // /< column number
    // /< length: 0 - to the end of line
    // / posmatch_T provides an array for storing match items for matchaddpos()
// / function.
    // /< array of positions
    // /< internal position counter
    // /< top buffer line
    // /< bottom buffer line
    /*
 * matchitem_T provides a linked list for storing match items for ":match" and
 * the match functions.
 */
    // /< match ID
    // /< match priority
    // /< pattern to highlight
    // /< highlight group ID
    // /< regexp program for pattern
    // /< position matches
    // /< struct for doing the actual highlighting
    // /< cchar for Conceal highlighting
    // NW -> 0
// NE -> kFloatAnchorEast
// SW -> kFloatAnchorSouth
// SE -> kFloatAnchorSouth | kFloatAnchorEast
    // / Minimal UI: no number column, eob markers, etc
    // Structure to store last cursor position and topline.  Used by check_lnums()
// and reset_lnums().
    // original topline value
    // corrected topline value
    // original cursor position
    // corrected cursor position
    // / Structure which contains all information that belongs to a window.
// /
// / All row numbers are relative to the start of the window, except w_winrow.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1067:8"]
    pub struct window_S {
        pub handle: handle_T,
        pub w_buffer: *mut buf_T,
        pub w_s: *mut synblock_T,
        pub w_hl_id_normal: libc::c_int,
        pub w_hl_attr_normal: libc::c_int,
        pub w_hl_ids: [libc::c_int; 50],
        pub w_hl_attrs: [libc::c_int; 50],
        pub w_hl_needs_update: libc::c_int,
        pub w_prev: *mut win_T,
        pub w_next: *mut win_T,
        pub w_closing: bool,
        pub w_frame: *mut frame_T,
        pub w_cursor: pos_T,
        pub w_curswant: colnr_T,
        pub w_set_curswant: libc::c_int,
        pub w_last_cursorline: linenr_T,
        pub w_last_cursormoved: pos_T,
        pub w_old_visual_mode: libc::c_char,
        pub w_old_cursor_lnum: linenr_T,
        pub w_old_cursor_fcol: colnr_T,
        pub w_old_cursor_lcol: colnr_T,
        pub w_old_visual_lnum: linenr_T,
        pub w_old_visual_col: colnr_T,
        pub w_old_curswant: colnr_T,
        pub w_p_lcs_chars: C2RustUnnamed_6,
        pub w_p_fcs_chars: C2RustUnnamed_5,
        pub w_topline: linenr_T,
        pub w_topline_was_set: libc::c_char,
        pub w_topfill: libc::c_int,
        pub w_old_topfill: libc::c_int,
        pub w_botfill: bool,
        pub w_old_botfill: bool,
        pub w_leftcol: colnr_T,
        pub w_skipcol: colnr_T,
        pub w_winrow: libc::c_int,
        pub w_height: libc::c_int,
        pub w_status_height: libc::c_int,
        pub w_wincol: libc::c_int,
        pub w_width: libc::c_int,
        pub w_vsep_width: libc::c_int,
        pub w_save_cursor: pos_save_T,
        pub w_height_inner: libc::c_int,
        pub w_width_inner: libc::c_int,
        pub w_height_request: libc::c_int,
        pub w_width_request: libc::c_int,
        pub w_valid: libc::c_int,
        pub w_valid_cursor: pos_T,
        pub w_valid_leftcol: colnr_T,
        pub w_cline_height: libc::c_int,
        pub w_cline_folded: bool,
        pub w_cline_row: libc::c_int,
        pub w_virtcol: colnr_T,
        pub w_wrow: libc::c_int,
        pub w_wcol: libc::c_int,
        pub w_botline: linenr_T,
        pub w_empty_rows: libc::c_int,
        pub w_filler_rows: libc::c_int,
        pub w_lines_valid: libc::c_int,
        pub w_lines: *mut wline_T,
        pub w_folds: garray_T,
        pub w_fold_manual: bool,
        pub w_foldinvalid: bool,
        pub w_nrwidth: libc::c_int,
        pub w_redr_type: libc::c_int,
        pub w_upd_rows: libc::c_int,
        pub w_redraw_top: linenr_T,
        pub w_redraw_bot: linenr_T,
        pub w_redr_status: libc::c_int,
        pub w_ru_cursor: pos_T,
        pub w_ru_virtcol: colnr_T,
        pub w_ru_topline: linenr_T,
        pub w_ru_line_count: linenr_T,
        pub w_ru_topfill: libc::c_int,
        pub w_ru_empty: libc::c_char,
        pub w_alt_fnum: libc::c_int,
        pub w_alist: *mut alist_T,
        pub w_arg_idx: libc::c_int,
        pub w_arg_idx_invalid: libc::c_int,
        pub w_localdir: *mut char_u,
        pub w_onebuf_opt: winopt_T,
        pub w_allbuf_opt: winopt_T,
        pub w_p_stl_flags: uint32_t,
        pub w_p_fde_flags: uint32_t,
        pub w_p_fdt_flags: uint32_t,
        pub w_p_cc_cols: *mut libc::c_int,
        pub w_p_brimin: libc::c_int,
        pub w_p_brishift: libc::c_int,
        pub w_p_brisbr: bool,
        pub w_p_siso: libc::c_long,
        pub w_p_so: libc::c_long,
        pub w_scbind_pos: libc::c_long,
        pub w_winvar: ScopeDictDictItem,
        pub w_vars: *mut dict_T,
        pub w_pcmark: pos_T,
        pub w_prev_pcmark: pos_T,
        pub w_jumplist: [xfmark_T; 100],
        pub w_jumplistlen: libc::c_int,
        pub w_jumplistidx: libc::c_int,
        pub w_changelistidx: libc::c_int,
        pub w_match_head: *mut matchitem_T,
        pub w_next_match_id: libc::c_int,
        pub w_tagstack: [taggy_T; 20],
        pub w_tagstackidx: libc::c_int,
        pub w_tagstacklen: libc::c_int,
        pub w_grid: ScreenGrid,
        pub w_pos_changed: bool,
        pub w_floating: bool,
        pub w_float_config: FloatConfig,
        pub w_fraction: libc::c_int,
        pub w_prev_fraction_row: libc::c_int,
        pub w_nrwidth_line_count: linenr_T,
        pub w_nrwidth_width: libc::c_int,
        pub w_llist: *mut qf_info_T,
        pub w_llist_ref: *mut qf_info_T,
    }
    #[c2rust::src_loc = "377:1"]
    pub type qf_info_T = qf_info_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1035:9"]
    pub struct FloatConfig {
        pub window: Window,
        pub bufpos: lpos_T,
        pub height: libc::c_int,
        pub width: libc::c_int,
        pub row: libc::c_double,
        pub col: libc::c_double,
        pub anchor: FloatAnchor,
        pub relative: FloatRelative,
        pub external: bool,
        pub focusable: bool,
        pub style: WinStyle,
    }
    #[c2rust::src_loc = "1030:9"]
    pub type WinStyle = libc::c_uint;
    #[c2rust::src_loc = "1032:3"]
    pub const kWinStyleMinimal: WinStyle = 1;
    #[c2rust::src_loc = "1031:3"]
    pub const kWinStyleUnused: WinStyle = 0;
    #[c2rust::src_loc = "1021:9"]
    pub type FloatRelative = libc::c_uint;
    #[c2rust::src_loc = "1024:3"]
    pub const kFloatRelativeCursor: FloatRelative = 2;
    #[c2rust::src_loc = "1023:3"]
    pub const kFloatRelativeWindow: FloatRelative = 1;
    #[c2rust::src_loc = "1022:3"]
    pub const kFloatRelativeEditor: FloatRelative = 0;
    #[c2rust::src_loc = "1008:1"]
    pub type FloatAnchor = libc::c_int;
    #[c2rust::src_loc = "121:1"]
    pub type taggy_T = taggy;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "121:16"]
    pub struct taggy {
        pub tagname: *mut char_u,
        pub fmark: fmark_T,
        pub cur_match: libc::c_int,
        pub cur_fnum: libc::c_int,
        pub user_data: *mut char_u,
    }
    #[c2rust::src_loc = "995:1"]
    pub type matchitem_T = matchitem;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "996:8"]
    pub struct matchitem {
        pub next: *mut matchitem_T,
        pub id: libc::c_int,
        pub priority: libc::c_int,
        pub pattern: *mut char_u,
        pub hlg_id: libc::c_int,
        pub match_0: regmmatch_T,
        pub pos: posmatch_T,
        pub hl: match_T,
        pub conceal_char: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "955:9"]
    pub struct match_T {
        pub rm: regmmatch_T,
        pub buf: *mut buf_T,
        pub lnum: linenr_T,
        pub attr: libc::c_int,
        pub attr_cur: libc::c_int,
        pub first_lnum: linenr_T,
        pub startcol: colnr_T,
        pub endcol: colnr_T,
        pub is_addpos: bool,
        pub tm: proftime_T,
    }
    #[c2rust::src_loc = "982:1"]
    pub type posmatch_T = posmatch;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "983:8"]
    pub struct posmatch {
        pub pos: [llpos_T; 8],
        pub cur: libc::c_int,
        pub toplnum: linenr_T,
        pub botlnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "973:9"]
    pub struct llpos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
        pub len: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "161:9"]
    pub struct winopt_T {
        pub wo_arab: libc::c_int,
        pub wo_bri: libc::c_int,
        pub wo_briopt: *mut char_u,
        pub wo_diff: libc::c_int,
        pub wo_fdc: *mut char_u,
        pub wo_fdc_save: *mut char_u,
        pub wo_fen: libc::c_int,
        pub wo_fen_save: libc::c_int,
        pub wo_fdi: *mut char_u,
        pub wo_fdl: libc::c_long,
        pub wo_fdl_save: libc::c_int,
        pub wo_fdm: *mut char_u,
        pub wo_fdm_save: *mut char_u,
        pub wo_fml: libc::c_long,
        pub wo_fdn: libc::c_long,
        pub wo_fde: *mut char_u,
        pub wo_fdt: *mut char_u,
        pub wo_fmr: *mut char_u,
        pub wo_lbr: libc::c_int,
        pub wo_list: libc::c_int,
        pub wo_nu: libc::c_int,
        pub wo_rnu: libc::c_int,
        pub wo_nuw: libc::c_long,
        pub wo_wfh: libc::c_int,
        pub wo_wfw: libc::c_int,
        pub wo_pvw: libc::c_int,
        pub wo_rl: libc::c_int,
        pub wo_rlc: *mut char_u,
        pub wo_scr: libc::c_long,
        pub wo_spell: libc::c_int,
        pub wo_cuc: libc::c_int,
        pub wo_cul: libc::c_int,
        pub wo_cc: *mut char_u,
        pub wo_stl: *mut char_u,
        pub wo_scb: libc::c_int,
        pub wo_diff_saved: libc::c_int,
        pub wo_scb_save: libc::c_int,
        pub wo_wrap: libc::c_int,
        pub wo_wrap_save: libc::c_int,
        pub wo_cocu: *mut char_u,
        pub wo_cole: libc::c_long,
        pub wo_crb: libc::c_int,
        pub wo_crb_save: libc::c_int,
        pub wo_scl: *mut char_u,
        pub wo_winhl: *mut char_u,
        pub wo_fcs: *mut char_u,
        pub wo_lcs: *mut char_u,
        pub wo_winbl: libc::c_long,
        pub wo_script_ctx: [LastSet; 42],
    }
    #[c2rust::src_loc = "290:1"]
    pub type alist_T = arglist;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "290:16"]
    pub struct arglist {
        pub al_ga: garray_T,
        pub al_refcount: libc::c_int,
        pub id: libc::c_int,
    }
    #[c2rust::src_loc = "917:1"]
    pub type wline_T = w_line;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "917:16"]
    pub struct w_line {
        pub wl_lnum: linenr_T,
        pub wl_size: uint16_t,
        pub wl_valid: libc::c_char,
        pub wl_folded: libc::c_char,
        pub wl_lastlnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1056:9"]
    pub struct pos_save_T {
        pub w_topline_save: libc::c_int,
        pub w_topline_corr: libc::c_int,
        pub w_cursor_save: pos_T,
        pub w_cursor_corr: pos_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1127:3"]
    pub struct C2RustUnnamed_5 {
        pub stl: libc::c_int,
        pub stlnc: libc::c_int,
        pub vert: libc::c_int,
        pub fold: libc::c_int,
        pub foldopen: libc::c_int,
        pub foldclosed: libc::c_int,
        pub foldsep: libc::c_int,
        pub diff: libc::c_int,
        pub msgsep: libc::c_int,
        pub eob: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1113:3"]
    pub struct C2RustUnnamed_6 {
        pub eol: libc::c_int,
        pub ext: libc::c_int,
        pub prec: libc::c_int,
        pub nbsp: libc::c_int,
        pub space: libc::c_int,
        pub tab1: libc::c_int,
        pub tab2: libc::c_int,
        pub tab3: libc::c_int,
        pub trail: libc::c_int,
        pub conceal: libc::c_int,
    }
    #[c2rust::src_loc = "100:1"]
    pub type frame_T = frame_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "929:8"]
    pub struct frame_S {
        pub fr_layout: libc::c_char,
        pub fr_width: libc::c_int,
        pub fr_newwidth: libc::c_int,
        pub fr_height: libc::c_int,
        pub fr_newheight: libc::c_int,
        pub fr_parent: *mut frame_T,
        pub fr_next: *mut frame_T,
        pub fr_prev: *mut frame_T,
        pub fr_child: *mut frame_T,
        pub fr_win: *mut win_T,
    }
    #[c2rust::src_loc = "101:1"]
    pub type disptick_T = uint16_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "382:9"]
    pub struct syn_time_T {
        pub total: proftime_T,
        pub slowest: proftime_T,
        pub count: libc::c_long,
        pub match_0: libc::c_long,
    }
    #[c2rust::src_loc = "346:1"]
    pub type mapblock_T = mapblock;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "347:8"]
    pub struct mapblock {
        pub m_next: *mut mapblock_T,
        pub m_keys: *mut char_u,
        pub m_str: *mut char_u,
        pub m_orig_str: *mut char_u,
        pub m_keylen: libc::c_int,
        pub m_mode: libc::c_int,
        pub m_noremap: libc::c_int,
        pub m_silent: libc::c_char,
        pub m_nowait: libc::c_char,
        pub m_expr: libc::c_char,
        pub m_script_ctx: sctx_T,
    }
    #[c2rust::src_loc = "99:1"]
    pub type wininfo_T = wininfo_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "273:8"]
    pub struct wininfo_S {
        pub wi_next: *mut wininfo_T,
        pub wi_prev: *mut wininfo_T,
        pub wi_win: *mut win_T,
        pub wi_fpos: pos_T,
        pub wi_optset: bool,
        pub wi_opt: winopt_T,
        pub wi_fold_manual: bool,
        pub wi_folds: garray_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "457:9"]
    pub struct ChangedtickDictItem {
        pub di_tv: typval_T,
        pub di_flags: uint8_t,
        pub di_key: [char_u; 12],
    }
    #[inline]
    #[c2rust::src_loc = "1356:1"]
    pub unsafe extern "C" fn win_hl_attr(mut wp: *mut win_T,
                                         mut hlf: libc::c_int)
     -> libc::c_int {
        return (*wp).w_hl_attrs[hlf as usize];
    }
    use super::nvim_types_h::{handle_T, char_u, LuaRef};
    use super::memline_defs_h::memline_T;
    use super::fs_defs_h::FileID;
    use super::typval_h::{varnumber_T, ScopeDictDictItem, dict_T, Callback,
                          sctx_T, typval_T};
    use super::pos_h::{linenr_T, pos_T, colnr_T, lpos_T};
    use super::stdint_uintn_h::{uint64_t, uint32_t, uint16_t, uint8_t};
    use super::mark_defs_h::{fmark_T, xfmark_T};
    use super::undo_defs_h::{visualinfo_T, u_header_T};
    use super::garray_h::garray_T;
    use super::time_t_h::time_t;
    use super::option_defs_h::LastSet;
    use super::sign_defs_h::signlist_T;
    use super::terminal_h::Terminal;
    use super::marktree_h::MarkTree;
    use super::map_h::{Map_uint64_t_ExtmarkItem, Map_uint64_t_ExtmarkNs};
    use super::stddef_h::size_t;
    use super::hashtab_h::hashtab_T;
    use super::stdint_intn_h::int16_t;
    use super::regexp_defs_h::{regprog_T, regmmatch_T};
    use super::syntax_defs_h::synstate_T;
    use super::grid_defs_h::ScreenGrid;
    use super::defs_h::Window;
    use super::profile_h::proftime_T;
    extern "C" {
        #[c2rust::src_loc = "377:16"]
        pub type qf_info_S;
    }
    // NVIM_BUFFER_DEFS_H
    // / Macros defined in Vim, but not in Neovim
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/map.h:34"]
pub mod map_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:1"]
    pub struct Map_uint64_t_ExtmarkNs {
        pub table: *mut kh_uint64_t_ExtmarkNs_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:1"]
    pub struct kh_uint64_t_ExtmarkNs_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ExtmarkNs,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:16"]
    pub struct ExtmarkNs {
        pub map: *mut Map_uint64_t_uint64_t,
        pub free_id: uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:1"]
    pub struct Map_uint64_t_uint64_t {
        pub table: *mut kh_uint64_t_uint64_t_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:1"]
    pub struct kh_uint64_t_uint64_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "52:1"]
    pub struct Map_uint64_t_ExtmarkItem {
        pub table: *mut kh_uint64_t_ExtmarkItem_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "52:1"]
    pub struct kh_uint64_t_ExtmarkItem_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ExtmarkItem,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:1"]
    pub struct Map_uint64_t_ptr_t {
        pub table: *mut kh_uint64_t_ptr_t_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:1"]
    pub struct kh_uint64_t_ptr_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ptr_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:1"]
    pub struct kh_cstr_t_ptr_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut cstr_t,
        pub vals: *mut ptr_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:1"]
    pub struct Map_cstr_t_ptr_t {
        pub table: *mut kh_cstr_t_ptr_t_map_t,
    }
    use super::khash_h::{khint_t, khint32_t};
    use super::stdint_uintn_h::uint64_t;
    use super::extmark_defs_h::ExtmarkItem;
    use super::map_defs_h::{ptr_t, cstr_t};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "40:21"]
        pub fn map_uint64_t_ptr_t_get(map: *mut Map_uint64_t_ptr_t,
                                      key: uint64_t) -> ptr_t;
    }
    // NVIM_MAP_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/khash.h:34"]
pub mod khash_h {
    /* The MIT License

   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
    /*
  Example:

#include "nvim/khash.h"
KHASH_MAP_INIT_INT(32, char)
int main() {
    int ret, is_missing;
    khiter_t k;
    khash_t(32) *h = kh_init(32);
    k = kh_put(32, h, 5, &ret);
    kh_value(h, k) = 10;
    k = kh_get(32, h, 10);
    is_missing = (k == kh_end(h));
    k = kh_get(32, h, 5);
    kh_del(32, h, k);
    for (k = kh_begin(h); k != kh_end(h); ++k)
        if (kh_exist(h, k)) kh_value(h, k) = 1;
    kh_destroy(32, h);
    return 0;
}
*/
    /*
  2013-05-02 (0.2.8):

	* Use quadratic probing. When the capacity is power of 2, stepping function
	  i*(i+1)/2 guarantees to traverse each bucket. It is better than double
	  hashing on cache performance and is more robust than linear probing.

	  In theory, double hashing should be more robust than quadratic probing.
	  However, my implementation is probably not for large hash tables, because
	  the second hash function is closely tied to the first hash function,
	  which reduce the effectiveness of double hashing.

	Reference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php

  2011-12-29 (0.2.7):

    * Minor code clean up; no actual effect.

  2011-09-16 (0.2.6):

	* The capacity is a power of 2. This seems to dramatically improve the
	  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:

	   - http://code.google.com/p/ulib/
	   - http://nothings.org/computer/judy/

	* Allow to optionally use linear probing which usually has better
	  performance for random input. Double hashing is still the default as it
	  is more robust to certain non-random input.

	* Added Wang's integer hash function (not used by default). This hash
	  function is more robust to certain non-random input.

  2011-02-14 (0.2.5):

    * Allow to declare global functions.

  2009-09-26 (0.2.4):

    * Improve portability

  2008-09-19 (0.2.3):

	* Corrected the example
	* Improved interfaces

  2008-09-11 (0.2.2):

	* Improved speed a little in kh_put()

  2008-09-10 (0.2.1):

	* Added kh_clear()
	* Fixed a compiling error

  2008-09-02 (0.2.0):

	* Changed to token concatenation which increases flexibility.

  2008-08-31 (0.1.2):

	* Fixed a bug in kh_get(), which has not been tested previously.

  2008-08-31 (0.1.1):

	* Added destructor
*/
    /* !
  @header

  Generic hash table library.
 */
    /* compiler specific configuration */
    #[c2rust::src_loc = "140:1"]
    pub type khint32_t = libc::c_uint;
    #[c2rust::src_loc = "157:1"]
    pub type khint_t = khint32_t;
    /* This function uses 0.25*n_buckets bytes of working space instead of */
    /* [sizeof(key_t+val_t)+.25]*n_buckets. */
    /* requested size is too small */
    /* hash table size to be changed (shrink or expand); rehash */
    /* expand */
    /* otherwise shrink */
    /* rehashing is needed */
    /* kick-out process; sort of like in Cuckoo hashing */
    /* kick out the existing element */
    /* mark it as deleted in the old hash table */
    /* write the element and jump out of the loop */
    /* shrink the hash table */
    /* free the working space */
    /* update the hash table */
    /* clear "deleted" elements */
    /* expand the hash table */
    /* TODO: implement automatically shrinking; */
    /* resize() already support shrinking */
    /* for speed up */
    /* not present at all */
    /* deleted */
    /* Don't touch h->keys[x] if present and not deleted */
    /* --- BEGIN OF HASH FUNCTIONS --- */
    /* ! @function
  @abstract     Integer hash function
  @param  key   The integer [khint32_t]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     Integer comparison function
 */
    /* ! @function
  @abstract     64-bit integer hash function
  @param  key   The integer [khint64_t]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     64-bit integer comparison function
 */
    /* ! @function
  @abstract     const char* hash function
  @param  s     Pointer to a null terminated string
  @return       The hash value
 */
    #[inline]
    #[c2rust::src_loc = "459:1"]
    pub unsafe extern "C" fn __ac_X31_hash_string(mut s: *const libc::c_char)
     -> khint_t {
        let mut h = *s as khint_t;
        if h != 0 {
            s = s.offset(1);
            while *s != 0 {
                h =
                    (h <<
                         5 as
                             libc::c_int).wrapping_sub(h).wrapping_add(*s as
                                                                           uint8_t
                                                                           as
                                                                           libc::c_uint);
                s = s.offset(1)
            }
        }
        return h;
    }
    /* ! @function
  @abstract     Another interface to const char* hash function
  @param  key   Pointer to a null terminated string [const char*]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     Const char* comparison function
 */
    #[inline]
    #[c2rust::src_loc = "476:1"]
    pub unsafe extern "C" fn __ac_Wang_hash(mut key: khint_t) -> khint_t {
        key =
            (key as libc::c_uint).wrapping_add(!(key << 15 as libc::c_int)) as
                khint_t as khint_t;
        key ^= key >> 10 as libc::c_int;
        key =
            (key as libc::c_uint).wrapping_add(key << 3 as libc::c_int) as
                khint_t as khint_t;
        key ^= key >> 6 as libc::c_int;
        key =
            (key as libc::c_uint).wrapping_add(!(key << 11 as libc::c_int)) as
                khint_t as khint_t;
        key ^= key >> 16 as libc::c_int;
        return key;
    }
    use super::stdint_uintn_h::uint8_t;
    // NVIM_LIB_KHASH_H
    /* ! @function
  @abstract     Return a literal for an empty hash table.
  @param  name  Name of the hash table [symbol]
 */
    /* ! @function
  @abstract     Instantiate a hash map containing const char* keys
  @param  name  Name of the hash table [symbol]
  @param  khval_t  Type of values [type]
 */
    /* ! @function
  @abstract     Instantiate a hash map containing const char* keys
  @param  name  Name of the hash table [symbol]
 */
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/extmark_defs.h:34"]
pub mod extmark_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:9"]
    pub struct ExtmarkItem {
        pub ns_id: uint64_t,
        pub mark_id: uint64_t,
        pub hl_id: libc::c_int,
        pub virt_text: VirtText,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:9"]
    pub struct VirtText {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut VirtTextChunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "7:9"]
    pub struct VirtTextChunk {
        pub text: *mut libc::c_char,
        pub hl_id: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:9"]
    pub struct extmark_undo_vec_t {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut ExtmarkUndoObject,
    }
    #[c2rust::src_loc = "25:1"]
    pub type ExtmarkUndoObject = undo_object;
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "25:16"]
        pub type undo_object;
    }
    // NVIM_EXTMARK_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/marktree.h:34"]
pub mod marktree_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "59:9"]
    pub struct MarkTree {
        pub root: *mut mtnode_t,
        pub n_keys: size_t,
        pub n_nodes: size_t,
        pub next_id: uint64_t,
        pub id2node: *mut Map_uint64_t_ptr_t,
    }
    #[c2rust::src_loc = "23:1"]
    pub type mtnode_t = mtnode_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "47:8"]
    pub struct mtnode_s {
        pub n: int32_t,
        pub level: int32_t,
        pub parent: *mut mtnode_t,
        pub key: [mtkey_t; 19],
        pub ptr: [*mut mtnode_t; 0],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:9"]
    pub struct mtkey_t {
        pub pos: mtpos_t,
        pub id: uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:9"]
    pub struct mtpos_t {
        pub row: int32_t,
        pub col: int32_t,
    }
    use super::stddef_h::size_t;
    use super::stdint_uintn_h::uint64_t;
    use super::map_h::Map_uint64_t_ptr_t;
    use super::stdint_intn_h::int32_t;
    // NVIM_MARKTREE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/map_defs.h:34"]
pub mod map_defs_h {
    #[c2rust::src_loc = "7:1"]
    pub type ptr_t = *mut libc::c_void;
    #[c2rust::src_loc = "6:1"]
    pub type cstr_t = *const libc::c_char;
    // NVIM_MAP_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/queue.h:34"]
pub mod queue_h {
    // Queue implemented by circularly-linked list.
//
// Adapted from libuv. Simpler and more efficient than klist.h for implementing
// queues that support arbitrary insertion/removal.
//
// Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
    #[c2rust::src_loc = "27:1"]
    pub type QUEUE = _queue;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:16"]
    pub struct _queue {
        pub next: *mut _queue,
        pub prev: *mut _queue,
    }
    // Public macros.
    // Important note: mutating the list while QUEUE_FOREACH is
// iterating over its elements results in undefined behavior.
    /* NOLINT(readability/braces) */
    // ffi.cdef is unable to swallow `bool` in place of `int` here.
    #[inline]
    #[c2rust::src_loc = "43:1"]
    pub unsafe extern "C" fn QUEUE_EMPTY(q: *const QUEUE) -> libc::c_int {
        return (q == (*q).next) as libc::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "51:1"]
    pub unsafe extern "C" fn QUEUE_INIT(q: *mut QUEUE) {
        (*q).next = q;
        (*q).prev = q;
    }
    #[inline]
    #[c2rust::src_loc = "57:1"]
    pub unsafe extern "C" fn QUEUE_ADD(h: *mut QUEUE, n: *mut QUEUE) {
        (*(*h).prev).next = (*n).next;
        (*(*n).next).prev = (*h).prev;
        (*h).prev = (*n).prev;
        (*(*h).prev).next = h;
    }
    #[inline]
    #[c2rust::src_loc = "66:1"]
    pub unsafe extern "C" fn QUEUE_INSERT_HEAD(h: *mut QUEUE, q: *mut QUEUE) {
        (*q).next = (*h).next;
        (*q).prev = h;
        (*(*q).next).prev = q;
        (*h).next = q;
    }
    #[inline]
    #[c2rust::src_loc = "75:1"]
    pub unsafe extern "C" fn QUEUE_INSERT_TAIL(h: *mut QUEUE, q: *mut QUEUE) {
        (*q).next = h;
        (*q).prev = (*h).prev;
        (*(*q).prev).next = q;
        (*h).prev = q;
    }
    #[inline]
    #[c2rust::src_loc = "84:1"]
    pub unsafe extern "C" fn QUEUE_REMOVE(q: *mut QUEUE) {
        (*(*q).prev).next = (*q).next;
        (*(*q).next).prev = (*q).prev;
    }
    // NVIM_LIB_QUEUE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/terminal.h:34"]
pub mod terminal_h {
    #[c2rust::src_loc = "8:1"]
    pub type Terminal = terminal;
    extern "C" {
        #[c2rust::src_loc = "8:16"]
        pub type terminal;
    }
    // NVIM_TERMINAL_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/sign_defs.h:34"]
pub mod sign_defs_h {
    // signs: line annotations
    // Sign group
    // number of signs in this group
    // next sign id for this group
    // sign group name
    // Macros to get the sign group structure from the group name
    #[c2rust::src_loc = "21:1"]
    pub type signlist_T = signlist;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "23:8"]
    pub struct signlist {
        pub id: libc::c_int,
        pub lnum: linenr_T,
        pub typenr: libc::c_int,
        pub group: *mut signgroup_T,
        pub priority: libc::c_int,
        pub next: *mut signlist_T,
        pub prev: *mut signlist_T,
    }
    #[c2rust::src_loc = "10:1"]
    pub type signgroup_T = signgroup_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "10:16"]
    pub struct signgroup_S {
        pub refcount: uint16_t,
        pub next_sign_id: libc::c_int,
        pub sg_name: [char_u; 1],
    }
    use super::pos_h::linenr_T;
    use super::stdint_uintn_h::uint16_t;
    use super::nvim_types_h::char_u;
    // NVIM_SIGN_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/regexp_defs.h:34"]
pub mod regexp_defs_h {
    /*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by Henry
 * Spencer.  This code has been modified specifically for use with Vim, and
 * should not be used apart from compiling Vim.  If you want a good regular
 * expression library, get the original code.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 */
    /*
 * The number of sub-matches is limited to 10.
 * The first one (index 0) is the whole match, referenced with "\0".
 * The second one (index 1) is the first sub-match, referenced with "\1".
 * This goes up to the tenth (index 9), referenced with "\9".
 */
    /*
 * In the NFA engine: how many braces are allowed.
 * TODO(RE): Use dynamic memory allocation instead of static, like here
 */
    // In the NFA engine: how many states are allowed.
    // Which regexp engine to use? Needed for vim_regcomp().
// Must match with 'regexpengine'.
    #[c2rust::src_loc = "46:1"]
    pub type regprog_T = regprog;
    // / Structure to be used for multi-line matching.
// / Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
// / and ends in line "endpos[no].lnum" just before column "endpos[no].col".
// / The line numbers are relative to the first line, thus startpos[0].lnum is
// / always 0.
// / When there is no match, the line number is -1.
    // / when not zero: maximum column
    /*
 * Structure returned by vim_regcomp() to pass on to vim_regexec().
 * This is the general structure. For the actual matcher, two specific
 * structures are used. See code below.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "70:8"]
    pub struct regprog {
        pub engine: *mut regengine_T,
        pub regflags: libc::c_uint,
        pub re_engine: libc::c_uint,
        pub re_flags: libc::c_uint,
    }
    #[c2rust::src_loc = "45:1"]
    pub type regengine_T = regengine;
    // /< Second argument for vim_regcomp().
    /*
 * Structure used by the back track matcher.
 * These fields are only to be used in regexp.c!
 * See regexp.c for an explanation.
 */
    // These four members implement regprog_T.
    // /< Second argument for vim_regcomp().
    /* actually longer.. */
    // Structure representing a NFA state.
// An NFA state may have no outgoing edge, when it is a NFA_MATCH state.
    /* 0: normal, 1: recursive */
    /*
 * Structure used by the NFA matcher.
 */
    // These four members implement regprog_T.
    // /< Second argument for vim_regcomp().
    /* points into state[] */
    /* pattern starts with ^ */
    /* char at start of pattern */
    /* plain text to match with */
    /* pattern contains \ze */
    /* pattern contains \1 .. \9 */
    /* number of () */
    /* actually longer.. */
    /*
 * Structure to be used for single-line matching.
 * Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
 * When there is no match, the pointer is NULL.
 */
    /*
 * Structure used to store external references: "\z\(\)" to "\z\1".
 * Use a reference count to avoid the need to copy this around.  When it goes
 * from 1 to zero the matches need to be freed.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "156:8"]
    pub struct regengine {
        pub regcomp: Option<unsafe extern "C" fn(_: *mut char_u,
                                                 _: libc::c_int)
                                -> *mut regprog_T>,
        pub regfree: Option<unsafe extern "C" fn(_: *mut regprog_T) -> ()>,
        pub regexec_nl: Option<unsafe extern "C" fn(_: *mut regmatch_T,
                                                    _: *mut char_u,
                                                    _: colnr_T, _: bool)
                                   -> libc::c_int>,
        pub regexec_multi: Option<unsafe extern "C" fn(_: *mut regmmatch_T,
                                                       _: *mut win_T,
                                                       _: *mut buf_T,
                                                       _: linenr_T,
                                                       _: colnr_T,
                                                       _: *mut proftime_T,
                                                       _: *mut libc::c_int)
                                      -> libc::c_long>,
        pub expr: *mut char_u,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "55:9"]
    pub struct regmmatch_T {
        pub regprog: *mut regprog_T,
        pub startpos: [lpos_T; 10],
        pub endpos: [lpos_T; 10],
        pub rmm_ic: libc::c_int,
        pub rmm_maxcol: colnr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "139:9"]
    pub struct regmatch_T {
        pub regprog: *mut regprog_T,
        pub startp: [*mut char_u; 10],
        pub endp: [*mut char_u; 10],
        pub rm_ic: bool,
    }
    #[c2rust::src_loc = "47:1"]
    pub type reg_extmatch_T = reg_extmatch;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "151:8"]
    pub struct reg_extmatch {
        pub refcnt: int16_t,
        pub matches: [*mut char_u; 10],
    }
    use super::nvim_types_h::char_u;
    use super::pos_h::{colnr_T, linenr_T, lpos_T};
    use super::buffer_defs_h::{win_T, buf_T};
    use super::profile_h::proftime_T;
    use super::stdint_intn_h::int16_t;
    // NVIM_REGEXP_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/profile.h:34"]
pub mod profile_h {
    #[c2rust::src_loc = "7:1"]
    pub type proftime_T = uint64_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_PROFILE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/api/private/defs.h:34"]
pub mod defs_h {
    // Basic types
    // Per msgpack-rpc spec.
    // / Mask for all internal calls
    // / Internal call from VimL code
    // / Internal call from lua code
    // / Check whether call is internal
// /
// / @param[in]  channel_id  Channel id.
// /
// / @return true if channel_id refers to internal channel.
    // / Maximum value of an Integer
    // / Minimum value of an Integer
    #[c2rust::src_loc = "82:1"]
    pub type Window = handle_T;
    #[c2rust::src_loc = "66:1"]
    pub type Boolean = bool;
    #[c2rust::src_loc = "67:1"]
    pub type Integer = int64_t;
    #[c2rust::src_loc = "68:1"]
    pub type Float = libc::c_double;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:9"]
    pub struct String_0 {
        pub data: *mut libc::c_char,
        pub size: size_t,
    }
    // EXT types, cannot be split or reordered, see #EXT_OBJECT_TYPE_SHIFT
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:8"]
    pub struct object {
        pub type_0: ObjectType,
        pub data: C2RustUnnamed_14,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "116:3"]
    pub union C2RustUnnamed_14 {
        pub boolean: Boolean,
        pub integer: Integer,
        pub floating: Float,
        pub string: String_0,
        pub array: Array,
        pub dictionary: Dictionary,
        pub luaref: LuaRef,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:9"]
    pub struct Dictionary {
        pub items: *mut KeyValuePair,
        pub size: size_t,
        pub capacity: size_t,
    }
    #[c2rust::src_loc = "92:1"]
    pub type KeyValuePair = key_value_pair;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "127:8"]
    pub struct key_value_pair {
        pub key: String_0,
        pub value: Object,
    }
    #[c2rust::src_loc = "85:1"]
    pub type Object = object;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "87:9"]
    pub struct Array {
        pub items: *mut Object,
        pub size: size_t,
        pub capacity: size_t,
    }
    #[c2rust::src_loc = "99:9"]
    pub type ObjectType = libc::c_uint;
    #[c2rust::src_loc = "111:3"]
    pub const kObjectTypeTabpage: ObjectType = 10;
    #[c2rust::src_loc = "110:3"]
    pub const kObjectTypeWindow: ObjectType = 9;
    #[c2rust::src_loc = "109:3"]
    pub const kObjectTypeBuffer: ObjectType = 8;
    #[c2rust::src_loc = "107:3"]
    pub const kObjectTypeLuaRef: ObjectType = 7;
    #[c2rust::src_loc = "106:3"]
    pub const kObjectTypeDictionary: ObjectType = 6;
    #[c2rust::src_loc = "105:3"]
    pub const kObjectTypeArray: ObjectType = 5;
    #[c2rust::src_loc = "104:3"]
    pub const kObjectTypeString: ObjectType = 4;
    #[c2rust::src_loc = "103:3"]
    pub const kObjectTypeFloat: ObjectType = 3;
    #[c2rust::src_loc = "102:3"]
    pub const kObjectTypeInteger: ObjectType = 2;
    #[c2rust::src_loc = "101:3"]
    pub const kObjectTypeBoolean: ObjectType = 1;
    #[c2rust::src_loc = "100:3"]
    pub const kObjectTypeNil: ObjectType = 0;
    #[inline(always)]
    #[c2rust::src_loc = "56:1"]
    pub unsafe extern "C" fn is_internal_call(channel_id: uint64_t) -> bool {
        return channel_id &
                   (1 as libc::c_int as uint64_t) <<
                       (::std::mem::size_of::<uint64_t>() as
                            libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                            libc::c_ulong).wrapping_sub(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_ulong)
                   != 0;
    }
    use super::nvim_types_h::{handle_T, LuaRef};
    use super::stdint_intn_h::int64_t;
    use super::stddef_h::size_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_API_PRIVATE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/grid_defs.h:34"]
pub mod grid_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:9"]
    pub struct ScreenGrid {
        pub handle: handle_T,
        pub chars: *mut schar_T,
        pub attrs: *mut sattr_T,
        pub line_offset: *mut libc::c_uint,
        pub line_wraps: *mut char_u,
        pub dirty_col: *mut libc::c_int,
        pub Rows: libc::c_int,
        pub Columns: libc::c_int,
        pub valid: bool,
        pub throttled: bool,
        pub row_offset: libc::c_int,
        pub col_offset: libc::c_int,
        pub blending: bool,
        pub focusable: bool,
        pub comp_row: libc::c_int,
        pub comp_col: libc::c_int,
        pub comp_index: size_t,
        pub comp_disabled: bool,
    }
    #[c2rust::src_loc = "14:1"]
    pub type sattr_T = int16_t;
    #[c2rust::src_loc = "13:1"]
    pub type schar_T = [char_u; 29];
    #[c2rust::src_loc = "10:9"]
    pub const MAX_MCO: libc::c_int = 6 as libc::c_int;
    use super::nvim_types_h::{handle_T, char_u};
    use super::stddef_h::size_t;
    use super::stdint_intn_h::int16_t;
    // NVIM_GRID_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mark_defs.h:34"]
pub mod mark_defs_h {
    /*
 * marks: positions in a file
 * (a normal mark is a lnum/col pair, the same as a file position)
 */
    // / Number of possible numbered global marks
    // / Maximum possible number of letter marks
    // / Total possible number of global marks
    // / Total possible number of local marks
// /
// / That are uppercase marks plus '"', '^' and '.'. There are other local marks,
// / but they are not saved in ShaDa files.
    // / Maximum number of marks in jump list
    // / Maximum number of tags in tag stack
    // / Structure defining single local mark
    #[c2rust::src_loc = "35:1"]
    pub type fmark_T = filemark;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:16"]
    pub struct filemark {
        pub mark: pos_T,
        pub fnum: libc::c_int,
        pub timestamp: Timestamp,
        pub additional_data: *mut dict_T,
    }
    // /< Cursor position.
    // /< File number.
    // /< Time when this mark was last set.
    // /< Additional data from ShaDa file.
    // / Structure defining extended mark (mark with file name attached)
    #[c2rust::src_loc = "43:1"]
    pub type xfmark_T = xfilemark;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "43:16"]
    pub struct xfilemark {
        pub fmark: fmark_T,
        pub fname: *mut char_u,
    }
    #[c2rust::src_loc = "17:9"]
    pub const NMARKS: libc::c_int =
        'z' as i32 - 'a' as i32 + 1 as libc::c_int;
    use super::pos_h::pos_T;
    use super::time_h::Timestamp;
    use super::typval_h::dict_T;
    use super::nvim_types_h::char_u;
    // /< Actual mark.
    // /< File name, used when fnum == 0.
    // NVIM_MARK_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/time.h:34"]
pub mod time_h {
    #[c2rust::src_loc = "8:1"]
    pub type Timestamp = uint64_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_OS_TIME_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/option_defs.h:34"]
pub mod option_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "862:9"]
    pub struct LastSet {
        pub script_ctx: sctx_T,
        pub channel_id: uint64_t,
    }
    #[c2rust::src_loc = "354:10"]
    pub const CMP_INTERNAL: libc::c_int = 0x1 as libc::c_int;
    #[c2rust::src_loc = "355:10"]
    pub const CMP_KEEPASCII: libc::c_int = 0x2 as libc::c_int;
    use super::typval_h::sctx_T;
    use super::stdint_uintn_h::uint64_t;
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "295:18"]
        pub static mut p_ambw: *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "407:12"]
        pub static mut p_emoji: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "350:17"]
        pub static mut cmp_flags: libc::c_uint;
        #[no_mangle]
        #[c2rust::src_loc = "356:18"]
        pub static mut p_enc: *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "316:13"]
        pub static mut breakat_flags: [libc::c_char; 256];
    }
    // NVIM_OPTION_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/syntax_defs.h:34"]
pub mod syntax_defs_h {
    /* minimal size for state stack array */
    /* maximal size for state stack array */
    /* size of sst_stack[]. */
    /* normal distance between entries */
    /* invalid syn_state pointer */
    #[c2rust::src_loc = "12:1"]
    pub type synstate_T = syn_state;
    /* struct passed to in_id_list() */
    // ":syn include" unique tag
    // highlight group ID of item
    // cont.in group IDs, if non-zero
    /*
 * Each keyword has one keyentry, which is linked in a hash list.
 */
    // next entry with identical "keyword[]"
    // struct passed to in_id_list()
    // ID list for next match (if non-zero)
    // conceal substitute character
    // actually longer
    /*
 * Struct used to store one state of the state stack.
 */
    /* index of pattern */
    /* flags for pattern */
    /* stores si_seqnr */
    /* stores si_cchar */
    /* external matches from start pattern */
    /*
 * syn_state contains the syntax state stack for the start of one line.
 * Used by b_sst_array[].
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "53:8"]
    pub struct syn_state {
        pub sst_next: *mut synstate_T,
        pub sst_lnum: linenr_T,
        pub sst_union: C2RustUnnamed_7,
        pub sst_next_flags: libc::c_int,
        pub sst_stacksize: libc::c_int,
        pub sst_next_list: *mut int16_t,
        pub sst_tick: disptick_T,
        pub sst_change_lnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:3"]
    pub union C2RustUnnamed_7 {
        pub sst_stack: [bufstate_T; 7],
        pub sst_ga: garray_T,
    }
    #[c2rust::src_loc = "41:1"]
    pub type bufstate_T = buf_state;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:16"]
    pub struct buf_state {
        pub bs_idx: libc::c_int,
        pub bs_flags: libc::c_int,
        pub bs_seqnr: libc::c_int,
        pub bs_cchar: libc::c_int,
        pub bs_extmatch: *mut reg_extmatch_T,
    }
    use super::pos_h::linenr_T;
    use super::stdint_intn_h::int16_t;
    use super::buffer_defs_h::disptick_T;
    use super::garray_h::garray_T;
    use super::regexp_defs_h::reg_extmatch_T;
    // NVIM_SYNTAX_DEFS_H
    // when non-zero, change in this line
                                // may have made the state invalid
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/undo_defs.h:34"]
pub mod undo_defs_h {
    // for time_t
    #[c2rust::src_loc = "10:1"]
    pub type u_header_T = u_header;
    /* Structure to store info about the Visual area. */
    /* start pos of last VIsual */
    /* end position of last VIsual */
    /* VIsual_mode of last VIsual */
    /* MAXCOL from w_curswant */
    /* pointer to next entry in list */
    /* number of line above undo block */
    /* number of line below undo block */
    /* linecount when u_save called */
    /* array of lines in undo block */
    /* number of lines in ue_array */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:8"]
    pub struct u_header {
        pub uh_next: C2RustUnnamed_12,
        pub uh_prev: C2RustUnnamed_11,
        pub uh_alt_next: C2RustUnnamed_10,
        pub uh_alt_prev: C2RustUnnamed_9,
        pub uh_seq: libc::c_long,
        pub uh_walk: libc::c_int,
        pub uh_entry: *mut u_entry_T,
        pub uh_getbot_entry: *mut u_entry_T,
        pub uh_cursor: pos_T,
        pub uh_cursor_vcol: libc::c_long,
        pub uh_flags: libc::c_int,
        pub uh_namedm: [fmark_T; 26],
        pub uh_extmark: extmark_undo_vec_t,
        pub uh_visual: visualinfo_T,
        pub uh_time: time_t,
        pub uh_save_nr: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "13:9"]
    pub struct visualinfo_T {
        pub vi_start: pos_T,
        pub vi_end: pos_T,
        pub vi_mode: libc::c_int,
        pub vi_curswant: colnr_T,
    }
    #[c2rust::src_loc = "22:1"]
    pub type u_entry_T = u_entry;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "23:8"]
    pub struct u_entry {
        pub ue_next: *mut u_entry_T,
        pub ue_top: linenr_T,
        pub ue_bot: linenr_T,
        pub ue_lcount: linenr_T,
        pub ue_array: *mut *mut char_u,
        pub ue_size: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:3"]
    pub union C2RustUnnamed_9 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:3"]
    pub union C2RustUnnamed_10 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:3"]
    pub union C2RustUnnamed_11 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:3"]
    pub union C2RustUnnamed_12 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    use super::pos_h::{pos_T, colnr_T, linenr_T};
    use super::mark_defs_h::fmark_T;
    use super::extmark_defs_h::extmark_undo_vec_t;
    use super::time_t_h::time_t;
    use super::nvim_types_h::char_u;
    // NVIM_UNDO_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/fs_defs.h:34"]
pub mod fs_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:9"]
    pub struct FileID {
        pub inode: uint64_t,
        pub device_id: uint64_t,
    }
    use super::stdint_uintn_h::uint64_t;
    // NVIM_OS_FS_DEFS_H
    // non-writable thing (e.g., block device)
    // something we can write to (character
                           // device, fifo, socket, ..)
    // file or directory, check with os_isdir()
    // Values returned by os_nodetype()
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/memline_defs.h:34"]
pub mod memline_defs_h {
    // /
// / When searching for a specific line, we remember what blocks in the tree
// / are the branches leading to that block. This is stored in ml_stack.  Each
// / entry is a pointer to info in a block (may be data block or pointer block)
// /
    // block number
    // lowest lnum in this block
    // highest lnum in this block
    // index for block with current lnum
    // block/index pair
    // Flags when calling ml_updatechunk()
    // / memline structure: the contents of a buffer.
// / Essentially a tree with a branch factor of 128.
// / Lines are stored at leaf nodes.
// / Nodes are stored on ml_mfp (memfile_T):
// /   pointer_block: internal nodes
// /   data_block: leaf nodes
// /
// / Memline also has "chunks" of 800 lines that are separate from the 128-tree
// / structure, primarily used to speed up line2byte() and byte2line().
// /
// / Motivation: If you have a file that is 10000 lines long, and you insert
// /             a line at linenr 1000, you don't want to move 9000 lines in
// /             memory.  With this structure it is roughly (N * 128) pointer
// /             moves, where N is the height (typically 1-3).
// /
    #[c2rust::src_loc = "43:1"]
    pub type memline_T = memline;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "43:16"]
    pub struct memline {
        pub ml_line_count: linenr_T,
        pub ml_mfp: *mut memfile_T,
        pub ml_flags: libc::c_int,
        pub ml_stack: *mut infoptr_T,
        pub ml_stack_top: libc::c_int,
        pub ml_stack_size: libc::c_int,
        pub ml_line_lnum: linenr_T,
        pub ml_line_ptr: *mut char_u,
        pub ml_locked: *mut bhdr_T,
        pub ml_locked_low: linenr_T,
        pub ml_locked_high: linenr_T,
        pub ml_locked_lineadd: libc::c_int,
        pub ml_chunksize: *mut chunksize_T,
        pub ml_numchunks: libc::c_int,
        pub ml_usedchunks: libc::c_int,
    }
    #[c2rust::src_loc = "18:1"]
    pub type chunksize_T = ml_chunksize;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "18:16"]
    pub struct ml_chunksize {
        pub mlcs_numlines: libc::c_int,
        pub mlcs_totalsize: libc::c_long,
    }
    #[c2rust::src_loc = "11:1"]
    pub type infoptr_T = info_pointer;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:16"]
    pub struct info_pointer {
        pub ip_bnum: blocknr_T,
        pub ip_low: linenr_T,
        pub ip_high: linenr_T,
        pub ip_index: libc::c_int,
    }
    use super::pos_h::linenr_T;
    use super::memfile_defs_h::{memfile_T, bhdr_T, blocknr_T};
    use super::nvim_types_h::char_u;
    // number of lines in the buffer
    // pointer to associated memfile
    // empty buffer
    // cached line was changed and allocated
    // ml_locked was changed
    // ml_locked needs positive block number
    // stack of pointer blocks (array of IPTRs)
    // current top of ml_stack
    // total number of entries in ml_stack
    // line number of cached line, 0 if not valid
    // pointer to cached line
    // block used by last ml_get
    // first line in ml_locked
    // last line in ml_locked
    // number of lines inserted in ml_locked
    // NVIM_MEMLINE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/memfile_defs.h:34"]
pub mod memfile_defs_h {
    // / A block number.
// /
// / Blocks numbered from 0 upwards have been assigned a place in the actual
// / file. The block number is equal to the page number in the file. The blocks
// / with negative numbers are currently in memory only.
    // / A hash item.
// /
// / Items' keys are block numbers.
// / Items in the same bucket are organized into a doubly-linked list.
// /
// / Therefore, items can be arbitrary data structures beginning with pointers
// / for the list and and a block number key.
    // / Initial size for a hashtable.
    // / A chained hashtable with block numbers as keys and arbitrary data structures
// / as items.
// /
// / This is an intrusive data structure: we require that items begin with
// / mf_hashitem_T which contains the key and linked list pointers. List of items
// / in each bucket is doubly-linked.
    // / mask used to mod hash value to array index
                                // / (nr of items in array is 'mht_mask + 1')
    // / number of items inserted
    // / points to the array of buckets (can be
                                // / mht_small_buckets or a newly allocated array
                                // / when mht_small_buckets becomes too small)
    // / initial buckets
    // / A block header.
// /
// / There is a block header for each previously used block in the memfile.
// /
// / The block may be linked in the used list OR in the free list.
// / The used blocks are also kept in hash lists.
// /
// / The used list is a doubly linked list, most recently used block first.
// / The blocks in the used list have a block of memory allocated.
// / The hash lists are used to quickly find a block in the used list.
// / The free list is a single linked list, not sorted.
// / The blocks in the free list have no block of memory allocated and
// / the contents of the block in the file (if any) is irrelevant.
    #[c2rust::src_loc = "63:1"]
    pub type bhdr_T = bhdr;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "63:16"]
    pub struct bhdr {
        pub bh_hashitem: mf_hashitem_T,
        pub bh_next: *mut bhdr,
        pub bh_prev: *mut bhdr,
        pub bh_data: *mut libc::c_void,
        pub bh_page_count: libc::c_uint,
        pub bh_flags: libc::c_uint,
    }
    #[c2rust::src_loc = "25:1"]
    pub type mf_hashitem_T = mf_hashitem;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:16"]
    pub struct mf_hashitem {
        pub mhi_next: *mut mf_hashitem,
        pub mhi_prev: *mut mf_hashitem,
        pub mhi_key: blocknr_T,
    }
    #[c2rust::src_loc = "16:1"]
    pub type blocknr_T = int64_t;
    // / header for hash table and key
    // / block number, part of bh_hashitem
    // / next block header in free or used list
    // / previous block header in used list
    // / pointer to memory (for used block)
    // / number of pages in this block
    // BH_DIRTY or BH_LOCKED
    // / A block number translation list item.
// /
// / When a block with a negative number is flushed to the file, it gets
// / a positive number. Because the reference to the block is still the negative
// / number, we remember the translation to the new positive number in the
// / double linked trans lists. The structure is the same as the hash lists.
    // / header for hash table and key
    // / old, negative, number
    // / new, positive, number
    // / A memory file.
    #[c2rust::src_loc = "90:1"]
    pub type memfile_T = memfile;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "90:16"]
    pub struct memfile {
        pub mf_fname: *mut char_u,
        pub mf_ffname: *mut char_u,
        pub mf_fd: libc::c_int,
        pub mf_free_first: *mut bhdr_T,
        pub mf_used_first: *mut bhdr_T,
        pub mf_used_last: *mut bhdr_T,
        pub mf_hash: mf_hashtab_T,
        pub mf_trans: mf_hashtab_T,
        pub mf_blocknr_max: blocknr_T,
        pub mf_blocknr_min: blocknr_T,
        pub mf_neg_count: blocknr_T,
        pub mf_infile_count: blocknr_T,
        pub mf_page_size: libc::c_uint,
        pub mf_dirty: bool,
    }
    #[c2rust::src_loc = "40:1"]
    pub type mf_hashtab_T = mf_hashtab;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:16"]
    pub struct mf_hashtab {
        pub mht_mask: size_t,
        pub mht_count: size_t,
        pub mht_buckets: *mut *mut mf_hashitem_T,
        pub mht_small_buckets: [*mut mf_hashitem_T; 64],
    }
    use super::stdint_intn_h::int64_t;
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    // / name of the file
    // / idem, full path
    // / file descriptor
    // / first block header in free list
    // / mru block header in used list
    // / lru block header in used list
    // / hash lists
    // / trans lists
    // / highest positive block number + 1
    // / lowest negative block number - 1
    // / number of negative blocks numbers
    // / number of pages in the file
    // / number of bytes in a page
    // / TRUE if there are dirty blocks
    // NVIM_MEMFILE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/globals.h:34"]
pub mod globals_h {
    #[c2rust::src_loc = "1034:9"]
    pub type WorkingStatus = libc::c_uint;
    #[c2rust::src_loc = "1037:3"]
    pub const kBroken: WorkingStatus = 2;
    #[c2rust::src_loc = "1036:3"]
    pub const kWorking: WorkingStatus = 1;
    #[c2rust::src_loc = "1035:3"]
    pub const kUnknown: WorkingStatus = 0;
    #[c2rust::src_loc = "17:9"]
    pub const IOSIZE: libc::c_int = 1024 as libc::c_int + 1 as libc::c_int;
    // These flags are set based upon 'fileencoding'.
// Note that "enc_utf8" is also set for "unicode", because the characters are
// internally stored as UTF-8 (to avoid trouble with NUL bytes).
    #[c2rust::src_loc = "587:10"]
    pub const DBCS_JPN: libc::c_int = 932 as libc::c_int;
    // japan
    #[c2rust::src_loc = "588:10"]
    pub const DBCS_JPNU: libc::c_int = 9932 as libc::c_int;
    // euc-jp
    #[c2rust::src_loc = "589:10"]
    pub const DBCS_KOR: libc::c_int = 949 as libc::c_int;
    // korea
    #[c2rust::src_loc = "590:10"]
    pub const DBCS_KORU: libc::c_int = 9949 as libc::c_int;
    // euc-kr
    #[c2rust::src_loc = "591:10"]
    pub const DBCS_CHS: libc::c_int = 936 as libc::c_int;
    // chinese
    #[c2rust::src_loc = "592:10"]
    pub const DBCS_CHSU: libc::c_int = 9936 as libc::c_int;
    // euc-cn
    #[c2rust::src_loc = "593:10"]
    pub const DBCS_CHT: libc::c_int = 950 as libc::c_int;
    // taiwan
    #[c2rust::src_loc = "594:10"]
    pub const DBCS_CHTU: libc::c_int = 9950 as libc::c_int;
    // euc-tw
    // 2byte-
    #[c2rust::src_loc = "596:10"]
    pub const DBCS_DEBUG: libc::c_int = -(1 as libc::c_int);
    use super::buffer_defs_h::{win_T, buf_T};
    use super::nvim_types_h::char_u;
    extern "C" {
        // previous window
        // NOLINT
        // When using this macro "break" only breaks out of the inner loop. Use "goto"
// to break out of the tabpage loop.
        // -V:FOR_ALL_WINDOWS_IN_TAB:501
        #[no_mangle]
        #[c2rust::src_loc = "427:18"]
        pub static mut curwin: *mut win_T;
        // last buffer
        #[no_mangle]
        #[c2rust::src_loc = "450:18"]
        pub static mut curbuf: *mut buf_T;
        // mbyte flags that used to depend on 'encoding'. These are now deprecated, as
// 'encoding' is always "utf-8". Code that use them can be refactored to
// remove dead code.
        // / Encoding used when 'fencs' is set to "default"
        #[no_mangle]
        #[c2rust::src_loc = "605:16"]
        pub static mut fenc_default: *mut char_u;
        // Selected "quit" at the dialog.
        #[no_mangle]
        #[c2rust::src_loc = "671:15"]
        pub static mut IObuff: [char_u; 1025];
    }
    // NVIM_GLOBALS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/keymap.h:34"]
pub mod keymap_h {
    // keypad Delete key
    #[c2rust::src_loc = "223:5"]
    pub const KE_CSI: key_extra = 81;
    /*
 * translation of three byte code "K_SPECIAL a b" into int "K_xxx" and back
 */
    /*
 * get second or third byte when translating special key code into three bytes
 */
    /*
 * get single int code from second byte after K_SPECIAL
 */
    // Codes for keys that do not have a termcap name.
// The numbers are fixed to make sure that recorded key sequences remain valid.
// Add new entries at the end, not halfway.
//
// K_SPECIAL KS_EXTRA KE_xxx
//
// Entries must be in the range 0x02-0x7f (see comment at K_SPECIAL).
    #[c2rust::src_loc = "124:1"]
    pub type key_extra = libc::c_uint;
    // <Cmd> special key
    // event
    #[c2rust::src_loc = "248:5"]
    pub const KE_COMMAND: key_extra = 104;
    // no-op: does nothing
    // , KE_FOCUSGAINED = 98    // focus gained
  // , KE_FOCUSLOST = 99      // focus lost
  // , KE_MOUSEMOVE = 100     // mouse moved with no button down
  // , KE_CANCEL = 101        // return from vgetc
    #[c2rust::src_loc = "247:5"]
    pub const KE_EVENT: key_extra = 102;
    // DnD data is available
    // , KE_CURSORHOLD = 96     // CursorHold event
    #[c2rust::src_loc = "242:5"]
    pub const KE_NOP: key_extra = 97;
    #[c2rust::src_loc = "240:5"]
    pub const KE_DROP: key_extra = 95;
    #[c2rust::src_loc = "238:5"]
    pub const KE_X2RELEASE: key_extra = 94;
    #[c2rust::src_loc = "237:5"]
    pub const KE_X2DRAG: key_extra = 93;
    #[c2rust::src_loc = "236:5"]
    pub const KE_X2MOUSE: key_extra = 92;
    #[c2rust::src_loc = "235:5"]
    pub const KE_X1RELEASE: key_extra = 91;
    // X1/X2 mouse-buttons
    #[c2rust::src_loc = "234:5"]
    pub const KE_X1DRAG: key_extra = 90;
    // control-end
    #[c2rust::src_loc = "233:5"]
    pub const KE_X1MOUSE: key_extra = 89;
    // control-home
    #[c2rust::src_loc = "231:5"]
    pub const KE_C_END: key_extra = 88;
    // control-right
    #[c2rust::src_loc = "230:5"]
    pub const KE_C_HOME: key_extra = 87;
    // control-left
    #[c2rust::src_loc = "229:5"]
    pub const KE_C_RIGHT: key_extra = 86;
    // open command-line window from Command-line Mode
    #[c2rust::src_loc = "228:5"]
    pub const KE_C_LEFT: key_extra = 85;
    // <Plug>
    #[c2rust::src_loc = "226:5"]
    pub const KE_CMDWIN: key_extra = 84;
    // <SNR>
    #[c2rust::src_loc = "225:5"]
    pub const KE_PLUG: key_extra = 83;
    // CSI typed directly
    #[c2rust::src_loc = "224:5"]
    pub const KE_SNR: key_extra = 82;
    // keypad Insert key
    #[c2rust::src_loc = "221:5"]
    pub const KE_KDEL: key_extra = 80;
    // scroll wheel pseudo-button Right
    #[c2rust::src_loc = "220:5"]
    pub const KE_KINS: key_extra = 79;
    // scroll wheel pseudo-button Left
    #[c2rust::src_loc = "218:5"]
    pub const KE_MOUSERIGHT: key_extra = 78;
    // scroll wheel pseudo-button Up
    #[c2rust::src_loc = "217:5"]
    pub const KE_MOUSELEFT: key_extra = 77;
    // scroll wheel pseudo-button Down
    #[c2rust::src_loc = "216:5"]
    pub const KE_MOUSEUP: key_extra = 76;
    // NOTE: The scroll wheel events are inverted: i.e. UP is the same as
  // moving the actual scroll wheel down, LEFT is the same as moving the
  // scroll wheel right.
    #[c2rust::src_loc = "215:5"]
    pub const KE_MOUSEDOWN: key_extra = 75;
    #[c2rust::src_loc = "210:5"]
    pub const KE_S_XF4: key_extra = 74;
    #[c2rust::src_loc = "209:5"]
    pub const KE_S_XF3: key_extra = 73;
    // vt100 shifted function keys for xterm
    #[c2rust::src_loc = "208:5"]
    pub const KE_S_XF2: key_extra = 72;
    // non-mappable left mouse button release
    #[c2rust::src_loc = "207:5"]
    pub const KE_S_XF1: key_extra = 71;
    // non-mappable Left mouse button click
    #[c2rust::src_loc = "205:5"]
    pub const KE_LEFTRELEASE_NM: key_extra = 70;
    #[c2rust::src_loc = "204:5"]
    pub const KE_LEFTMOUSE_NM: key_extra = 69;
    #[c2rust::src_loc = "202:5"]
    pub const KE_XRIGHT: key_extra = 68;
    #[c2rust::src_loc = "201:5"]
    pub const KE_XLEFT: key_extra = 67;
    // extra vt100 cursor keys for xterm
    #[c2rust::src_loc = "200:5"]
    pub const KE_XDOWN: key_extra = 66;
    // extra (vt100) home key for xterm
    #[c2rust::src_loc = "199:5"]
    pub const KE_XUP: key_extra = 65;
    // extra (vt100) home key for xterm
    #[c2rust::src_loc = "198:5"]
    pub const KE_ZHOME: key_extra = 64;
    // extra (vt100) end key for xterm
    #[c2rust::src_loc = "197:5"]
    pub const KE_XHOME: key_extra = 63;
    // extra (vt100) end key for xterm
    #[c2rust::src_loc = "196:5"]
    pub const KE_ZEND: key_extra = 62;
    #[c2rust::src_loc = "195:5"]
    pub const KE_XEND: key_extra = 61;
    #[c2rust::src_loc = "194:5"]
    pub const KE_XF4: key_extra = 60;
    #[c2rust::src_loc = "193:5"]
    pub const KE_XF3: key_extra = 59;
    // extra vt100 function keys for xterm
    #[c2rust::src_loc = "192:5"]
    pub const KE_XF2: key_extra = 58;
    // shifted TAB key (no longer used)
    // , KE_SNIFF_UNUSED = 56   // obsolete
    #[c2rust::src_loc = "191:5"]
    pub const KE_XF1: key_extra = 57;
    // unshifted TAB key
    #[c2rust::src_loc = "188:5"]
    pub const KE_S_TAB_OLD: key_extra = 55;
    // Ignored mouse drag/release
    #[c2rust::src_loc = "187:5"]
    pub const KE_TAB: key_extra = 54;
    // Right mouse button release
    #[c2rust::src_loc = "185:5"]
    pub const KE_IGNORE: key_extra = 53;
    // Drag with right mouse button down
    #[c2rust::src_loc = "183:5"]
    pub const KE_RIGHTRELEASE: key_extra = 52;
    // Right mouse button click
    #[c2rust::src_loc = "182:5"]
    pub const KE_RIGHTDRAG: key_extra = 51;
    // Middle mouse button release
    #[c2rust::src_loc = "181:5"]
    pub const KE_RIGHTMOUSE: key_extra = 50;
    // Drag with middle mouse button down
    #[c2rust::src_loc = "180:5"]
    pub const KE_MIDDLERELEASE: key_extra = 49;
    // Middle mouse button click
    #[c2rust::src_loc = "179:5"]
    pub const KE_MIDDLEDRAG: key_extra = 48;
    // Left mouse button release
    #[c2rust::src_loc = "178:5"]
    pub const KE_MIDDLEMOUSE: key_extra = 47;
    // Drag with left mouse button down
    #[c2rust::src_loc = "177:5"]
    pub const KE_LEFTRELEASE: key_extra = 46;
    // Left mouse button click
    #[c2rust::src_loc = "176:5"]
    pub const KE_LEFTDRAG: key_extra = 45;
    // mouse event start
    // Symbols for pseudo keys which are translated from the real key symbols
  // above.
    #[c2rust::src_loc = "175:5"]
    pub const KE_LEFTMOUSE: key_extra = 44;
    #[c2rust::src_loc = "171:5"]
    pub const KE_MOUSE: key_extra = 43;
    #[c2rust::src_loc = "169:5"]
    pub const KE_S_F37: key_extra = 42;
    #[c2rust::src_loc = "168:5"]
    pub const KE_S_F36: key_extra = 41;
    #[c2rust::src_loc = "167:5"]
    pub const KE_S_F35: key_extra = 40;
    #[c2rust::src_loc = "166:5"]
    pub const KE_S_F34: key_extra = 39;
    #[c2rust::src_loc = "165:5"]
    pub const KE_S_F33: key_extra = 38;
    #[c2rust::src_loc = "164:5"]
    pub const KE_S_F32: key_extra = 37;
    #[c2rust::src_loc = "163:5"]
    pub const KE_S_F31: key_extra = 36;
    #[c2rust::src_loc = "161:5"]
    pub const KE_S_F30: key_extra = 35;
    #[c2rust::src_loc = "160:5"]
    pub const KE_S_F29: key_extra = 34;
    #[c2rust::src_loc = "159:5"]
    pub const KE_S_F28: key_extra = 33;
    #[c2rust::src_loc = "158:5"]
    pub const KE_S_F27: key_extra = 32;
    #[c2rust::src_loc = "157:5"]
    pub const KE_S_F26: key_extra = 31;
    #[c2rust::src_loc = "156:5"]
    pub const KE_S_F25: key_extra = 30;
    #[c2rust::src_loc = "155:5"]
    pub const KE_S_F24: key_extra = 29;
    #[c2rust::src_loc = "154:5"]
    pub const KE_S_F23: key_extra = 28;
    #[c2rust::src_loc = "153:5"]
    pub const KE_S_F22: key_extra = 27;
    #[c2rust::src_loc = "152:5"]
    pub const KE_S_F21: key_extra = 26;
    #[c2rust::src_loc = "150:5"]
    pub const KE_S_F20: key_extra = 25;
    #[c2rust::src_loc = "149:5"]
    pub const KE_S_F19: key_extra = 24;
    #[c2rust::src_loc = "148:5"]
    pub const KE_S_F18: key_extra = 23;
    #[c2rust::src_loc = "147:5"]
    pub const KE_S_F17: key_extra = 22;
    #[c2rust::src_loc = "146:5"]
    pub const KE_S_F16: key_extra = 21;
    #[c2rust::src_loc = "145:5"]
    pub const KE_S_F15: key_extra = 20;
    #[c2rust::src_loc = "144:5"]
    pub const KE_S_F14: key_extra = 19;
    #[c2rust::src_loc = "143:5"]
    pub const KE_S_F13: key_extra = 18;
    #[c2rust::src_loc = "142:5"]
    pub const KE_S_F12: key_extra = 17;
    #[c2rust::src_loc = "141:5"]
    pub const KE_S_F11: key_extra = 16;
    #[c2rust::src_loc = "139:5"]
    pub const KE_S_F10: key_extra = 15;
    #[c2rust::src_loc = "138:5"]
    pub const KE_S_F9: key_extra = 14;
    #[c2rust::src_loc = "137:5"]
    pub const KE_S_F8: key_extra = 13;
    #[c2rust::src_loc = "136:5"]
    pub const KE_S_F7: key_extra = 12;
    #[c2rust::src_loc = "135:5"]
    pub const KE_S_F6: key_extra = 11;
    #[c2rust::src_loc = "134:5"]
    pub const KE_S_F5: key_extra = 10;
    #[c2rust::src_loc = "133:5"]
    pub const KE_S_F4: key_extra = 9;
    #[c2rust::src_loc = "132:5"]
    pub const KE_S_F3: key_extra = 8;
    // shifted function keys
    #[c2rust::src_loc = "131:5"]
    pub const KE_S_F2: key_extra = 7;
    // shift-down
    #[c2rust::src_loc = "130:5"]
    pub const KE_S_F1: key_extra = 6;
    // shift-up
    #[c2rust::src_loc = "128:5"]
    pub const KE_S_DOWN: key_extra = 5;
    // name of this terminal entry
    #[c2rust::src_loc = "127:5"]
    pub const KE_S_UP: key_extra = 4;
    #[c2rust::src_loc = "125:3"]
    pub const KE_NAME: key_extra = 3;
    /*
 * Keycode definitions for special keys.
 *
 * Any special key code sequences are replaced by these codes.
 */
    /*
 * For MSDOS some keys produce codes larger than 0xff. They are split into two
 * chars, the first one is K_NUL.
 */
    /* for MSDOS: special key follows */
    /*
 * K_SPECIAL is the first byte of a special key code and is always followed by
 * two bytes.
 * The second byte can have any value. ASCII is used for normal termcap
 * entries, 0x80 and higher for special keys, see below.
 * The third byte is guaranteed to be between 0x02 and 0x7f.
 */
    #[c2rust::src_loc = "26:9"]
    pub const K_SPECIAL: libc::c_int = 0x80 as libc::c_int;
    /*
 * Positive characters are "normal" characters.
 * Negative characters are special key codes.  Only characters below -0x200
 * are used to so that the absolute value can't be mistaken for a single-byte
 * character.
 */
    /*
 * Characters 0x0100 - 0x01ff have a special meaning for abbreviations.
 * Multi-byte characters also have ABBR_OFF added, thus are above 0x0200.
 */
    /*
 * NUL cannot be in the input string, therefore it is replaced by
 *	K_SPECIAL   KS_ZERO	KE_FILLER
 */
    /*
 * K_SPECIAL cannot be in the input string, therefore it is replaced by
 *	K_SPECIAL   KS_SPECIAL	KE_FILLER
 */
    /*
 * KS_EXTRA is used for keys that have no termcap name
 *	K_SPECIAL   KS_EXTRA	KE_xxx
 */
    #[c2rust::src_loc = "58:9"]
    pub const KS_EXTRA: libc::c_int = 253 as libc::c_int;
    /*
 * KS_MODIFIER is used when a modifier is given for a (special) key
 *	K_SPECIAL   KS_MODIFIER	bitmask
 */
    /*
 * These are used for the GUI
 *	K_SPECIAL   KS_xxx	KE_FILLER
 */
    /*
 * Used for switching Select mode back on after a mapping or menu.
 */
    /* Used a termcap entry that produces a normal character. */
    /* Used for click in a tab pages label. */
    /* Used for menu in a tab pages line. */
    /*
 * Filler used after KS_SPECIAL and others
 */
    #[c2rust::src_loc = "93:9"]
    pub const KE_FILLER: libc::c_int = 'X' as i32;
    #[c2rust::src_loc = "52:9"]
    pub const KS_SPECIAL: libc::c_int = 254 as libc::c_int;
    // NVIM_KEYMAP_H
    // Maximum length of a special key event as tokens.  This includes modifiers.
// The longest event is something like <M-C-S-T-4-LeftDrag> which would be the
// following string of tokens:
//
// <K_SPECIAL> <KS_MODIFIER> bitmask <K_SPECIAL> <KS_EXTRA> <KE_LEFTDRAG>.
//
// This is a total of 6 tokens, and is currently the longest one possible.
    /*
 * The length of the longest special key name, including modifiers.
 * Current longest is <M-C-S-T-D-A-4-ScrollWheelRight> (length includes '<' and
 * '>').
 */
    // "super" key (macOS: command-key)
    // use MOD_MASK_MULTI_CLICK
    // use MOD_MASK_MULTI_CLICK
    // use MOD_MASK_MULTI_CLICK
    // META when it's different from ALT
    // aka META
    /* Bits for modifier mask */
/* 0x01 cannot be used, because the modifier must be 0x02 or higher */
    /*
 * Symbols for pseudo keys which are translated from the real key symbols
 * above.
 */
    // keypad equal
    // keypad comma
    // keypad 9
    // keypad 8
    // keypad 7
    // keypad 6
    // keypad 5
    // keypad 4
    // keypad 3
    // keypad 2
    // keypad 1
    // keypad 0
    // keypad . or ,
    // keypad Enter
    // keypad *
    // keypad /
    // keypad minus
    // keypad plus
    // keypad center
    // keypad pagedown (lower R.)
    // keypad pageup (upper R.)
    // keypad end (lower left)
    // keypad home (upper left)
    /* K_S_F13 to K_S_F37  are currently not used */
    // shifted func. keys
    /* extra set of shifted function keys F1-F4, for vt100 compatible xterm */
    // function keys
    /* extra set of cursor keys for vt100 compatible xterm */
    /* extra set of function keys F1-F4, for vt100 compatible xterm */
    // keypad right
    // keypad left
    // keypad down
    // keypad up
    /*
 * the three byte codes are replaced with the following int when using vgetc()
 */
}
#[c2rust::header_src = "/usr/include/langinfo.h:2000"]
pub mod langinfo_h {
    #[c2rust::src_loc = "356:3"]
    pub const CODESET: C2RustUnnamed_33 = 14;
    #[c2rust::src_loc = "41:1"]
    pub type C2RustUnnamed_33 = libc::c_uint;
    #[c2rust::src_loc = "643:3"]
    pub const _NL_NUM: C2RustUnnamed_33 = 786449;
    #[c2rust::src_loc = "640:3"]
    pub const _NL_NUM_LC_IDENTIFICATION: C2RustUnnamed_33 = 786448;
    #[c2rust::src_loc = "639:3"]
    pub const _NL_IDENTIFICATION_CODESET: C2RustUnnamed_33 = 786447;
    #[c2rust::src_loc = "638:3"]
    pub const _NL_IDENTIFICATION_CATEGORY: C2RustUnnamed_33 = 786446;
    #[c2rust::src_loc = "637:3"]
    pub const _NL_IDENTIFICATION_DATE: C2RustUnnamed_33 = 786445;
    #[c2rust::src_loc = "636:3"]
    pub const _NL_IDENTIFICATION_REVISION: C2RustUnnamed_33 = 786444;
    #[c2rust::src_loc = "635:3"]
    pub const _NL_IDENTIFICATION_ABBREVIATION: C2RustUnnamed_33 = 786443;
    #[c2rust::src_loc = "634:3"]
    pub const _NL_IDENTIFICATION_APPLICATION: C2RustUnnamed_33 = 786442;
    #[c2rust::src_loc = "633:3"]
    pub const _NL_IDENTIFICATION_AUDIENCE: C2RustUnnamed_33 = 786441;
    #[c2rust::src_loc = "632:3"]
    pub const _NL_IDENTIFICATION_TERRITORY: C2RustUnnamed_33 = 786440;
    #[c2rust::src_loc = "631:3"]
    pub const _NL_IDENTIFICATION_LANGUAGE: C2RustUnnamed_33 = 786439;
    #[c2rust::src_loc = "630:3"]
    pub const _NL_IDENTIFICATION_FAX: C2RustUnnamed_33 = 786438;
    #[c2rust::src_loc = "629:3"]
    pub const _NL_IDENTIFICATION_TEL: C2RustUnnamed_33 = 786437;
    #[c2rust::src_loc = "628:3"]
    pub const _NL_IDENTIFICATION_EMAIL: C2RustUnnamed_33 = 786436;
    #[c2rust::src_loc = "627:3"]
    pub const _NL_IDENTIFICATION_CONTACT: C2RustUnnamed_33 = 786435;
    #[c2rust::src_loc = "626:3"]
    pub const _NL_IDENTIFICATION_ADDRESS: C2RustUnnamed_33 = 786434;
    #[c2rust::src_loc = "625:3"]
    pub const _NL_IDENTIFICATION_SOURCE: C2RustUnnamed_33 = 786433;
    #[c2rust::src_loc = "624:3"]
    pub const _NL_IDENTIFICATION_TITLE: C2RustUnnamed_33 = 786432;
    #[c2rust::src_loc = "622:3"]
    pub const _NL_NUM_LC_MEASUREMENT: C2RustUnnamed_33 = 720898;
    #[c2rust::src_loc = "621:3"]
    pub const _NL_MEASUREMENT_CODESET: C2RustUnnamed_33 = 720897;
    #[c2rust::src_loc = "620:3"]
    pub const _NL_MEASUREMENT_MEASUREMENT: C2RustUnnamed_33 = 720896;
    #[c2rust::src_loc = "618:3"]
    pub const _NL_NUM_LC_TELEPHONE: C2RustUnnamed_33 = 655365;
    #[c2rust::src_loc = "617:3"]
    pub const _NL_TELEPHONE_CODESET: C2RustUnnamed_33 = 655364;
    #[c2rust::src_loc = "616:3"]
    pub const _NL_TELEPHONE_INT_PREFIX: C2RustUnnamed_33 = 655363;
    #[c2rust::src_loc = "615:3"]
    pub const _NL_TELEPHONE_INT_SELECT: C2RustUnnamed_33 = 655362;
    #[c2rust::src_loc = "614:3"]
    pub const _NL_TELEPHONE_TEL_DOM_FMT: C2RustUnnamed_33 = 655361;
    #[c2rust::src_loc = "613:3"]
    pub const _NL_TELEPHONE_TEL_INT_FMT: C2RustUnnamed_33 = 655360;
    #[c2rust::src_loc = "611:3"]
    pub const _NL_NUM_LC_ADDRESS: C2RustUnnamed_33 = 589837;
    #[c2rust::src_loc = "610:3"]
    pub const _NL_ADDRESS_CODESET: C2RustUnnamed_33 = 589836;
    #[c2rust::src_loc = "609:3"]
    pub const _NL_ADDRESS_LANG_LIB: C2RustUnnamed_33 = 589835;
    #[c2rust::src_loc = "608:3"]
    pub const _NL_ADDRESS_LANG_TERM: C2RustUnnamed_33 = 589834;
    #[c2rust::src_loc = "607:3"]
    pub const _NL_ADDRESS_LANG_AB: C2RustUnnamed_33 = 589833;
    #[c2rust::src_loc = "606:3"]
    pub const _NL_ADDRESS_LANG_NAME: C2RustUnnamed_33 = 589832;
    #[c2rust::src_loc = "605:3"]
    pub const _NL_ADDRESS_COUNTRY_ISBN: C2RustUnnamed_33 = 589831;
    #[c2rust::src_loc = "604:3"]
    pub const _NL_ADDRESS_COUNTRY_NUM: C2RustUnnamed_33 = 589830;
    #[c2rust::src_loc = "603:3"]
    pub const _NL_ADDRESS_COUNTRY_CAR: C2RustUnnamed_33 = 589829;
    #[c2rust::src_loc = "602:3"]
    pub const _NL_ADDRESS_COUNTRY_AB3: C2RustUnnamed_33 = 589828;
    #[c2rust::src_loc = "601:3"]
    pub const _NL_ADDRESS_COUNTRY_AB2: C2RustUnnamed_33 = 589827;
    #[c2rust::src_loc = "600:3"]
    pub const _NL_ADDRESS_COUNTRY_POST: C2RustUnnamed_33 = 589826;
    #[c2rust::src_loc = "599:3"]
    pub const _NL_ADDRESS_COUNTRY_NAME: C2RustUnnamed_33 = 589825;
    #[c2rust::src_loc = "598:3"]
    pub const _NL_ADDRESS_POSTAL_FMT: C2RustUnnamed_33 = 589824;
    #[c2rust::src_loc = "596:3"]
    pub const _NL_NUM_LC_NAME: C2RustUnnamed_33 = 524295;
    #[c2rust::src_loc = "595:3"]
    pub const _NL_NAME_CODESET: C2RustUnnamed_33 = 524294;
    #[c2rust::src_loc = "594:3"]
    pub const _NL_NAME_NAME_MS: C2RustUnnamed_33 = 524293;
    #[c2rust::src_loc = "593:3"]
    pub const _NL_NAME_NAME_MISS: C2RustUnnamed_33 = 524292;
    #[c2rust::src_loc = "592:3"]
    pub const _NL_NAME_NAME_MRS: C2RustUnnamed_33 = 524291;
    #[c2rust::src_loc = "591:3"]
    pub const _NL_NAME_NAME_MR: C2RustUnnamed_33 = 524290;
    #[c2rust::src_loc = "590:3"]
    pub const _NL_NAME_NAME_GEN: C2RustUnnamed_33 = 524289;
    #[c2rust::src_loc = "589:3"]
    pub const _NL_NAME_NAME_FMT: C2RustUnnamed_33 = 524288;
    #[c2rust::src_loc = "587:3"]
    pub const _NL_NUM_LC_PAPER: C2RustUnnamed_33 = 458755;
    #[c2rust::src_loc = "586:3"]
    pub const _NL_PAPER_CODESET: C2RustUnnamed_33 = 458754;
    #[c2rust::src_loc = "585:3"]
    pub const _NL_PAPER_WIDTH: C2RustUnnamed_33 = 458753;
    #[c2rust::src_loc = "584:3"]
    pub const _NL_PAPER_HEIGHT: C2RustUnnamed_33 = 458752;
    #[c2rust::src_loc = "582:3"]
    pub const _NL_NUM_LC_MESSAGES: C2RustUnnamed_33 = 327685;
    #[c2rust::src_loc = "581:3"]
    pub const _NL_MESSAGES_CODESET: C2RustUnnamed_33 = 327684;
    #[c2rust::src_loc = "577:3"]
    pub const __NOSTR: C2RustUnnamed_33 = 327683;
    #[c2rust::src_loc = "573:3"]
    pub const __YESSTR: C2RustUnnamed_33 = 327682;
    #[c2rust::src_loc = "571:3"]
    pub const __NOEXPR: C2RustUnnamed_33 = 327681;
    #[c2rust::src_loc = "569:3"]
    pub const __YESEXPR: C2RustUnnamed_33 = 327680;
    #[c2rust::src_loc = "567:3"]
    pub const _NL_NUM_LC_NUMERIC: C2RustUnnamed_33 = 65542;
    #[c2rust::src_loc = "566:3"]
    pub const _NL_NUMERIC_CODESET: C2RustUnnamed_33 = 65541;
    #[c2rust::src_loc = "565:3"]
    pub const _NL_NUMERIC_THOUSANDS_SEP_WC: C2RustUnnamed_33 = 65540;
    #[c2rust::src_loc = "564:3"]
    pub const _NL_NUMERIC_DECIMAL_POINT_WC: C2RustUnnamed_33 = 65539;
    #[c2rust::src_loc = "560:3"]
    pub const __GROUPING: C2RustUnnamed_33 = 65538;
    #[c2rust::src_loc = "558:3"]
    pub const THOUSEP: C2RustUnnamed_33 = 65537;
    #[c2rust::src_loc = "554:3"]
    pub const __THOUSANDS_SEP: C2RustUnnamed_33 = 65537;
    #[c2rust::src_loc = "552:3"]
    pub const RADIXCHAR: C2RustUnnamed_33 = 65536;
    #[c2rust::src_loc = "548:3"]
    pub const __DECIMAL_POINT: C2RustUnnamed_33 = 65536;
    #[c2rust::src_loc = "544:3"]
    pub const _NL_NUM_LC_MONETARY: C2RustUnnamed_33 = 262190;
    #[c2rust::src_loc = "543:3"]
    pub const _NL_MONETARY_CODESET: C2RustUnnamed_33 = 262189;
    #[c2rust::src_loc = "542:3"]
    pub const _NL_MONETARY_THOUSANDS_SEP_WC: C2RustUnnamed_33 = 262188;
    #[c2rust::src_loc = "541:3"]
    pub const _NL_MONETARY_DECIMAL_POINT_WC: C2RustUnnamed_33 = 262187;
    #[c2rust::src_loc = "540:3"]
    pub const _NL_MONETARY_CONVERSION_RATE: C2RustUnnamed_33 = 262186;
    #[c2rust::src_loc = "539:3"]
    pub const _NL_MONETARY_DUO_VALID_TO: C2RustUnnamed_33 = 262185;
    #[c2rust::src_loc = "538:3"]
    pub const _NL_MONETARY_DUO_VALID_FROM: C2RustUnnamed_33 = 262184;
    #[c2rust::src_loc = "537:3"]
    pub const _NL_MONETARY_UNO_VALID_TO: C2RustUnnamed_33 = 262183;
    #[c2rust::src_loc = "536:3"]
    pub const _NL_MONETARY_UNO_VALID_FROM: C2RustUnnamed_33 = 262182;
    #[c2rust::src_loc = "535:3"]
    pub const _NL_MONETARY_DUO_INT_N_SIGN_POSN: C2RustUnnamed_33 = 262181;
    #[c2rust::src_loc = "534:3"]
    pub const _NL_MONETARY_DUO_INT_P_SIGN_POSN: C2RustUnnamed_33 = 262180;
    #[c2rust::src_loc = "533:3"]
    pub const _NL_MONETARY_DUO_N_SIGN_POSN: C2RustUnnamed_33 = 262179;
    #[c2rust::src_loc = "532:3"]
    pub const _NL_MONETARY_DUO_P_SIGN_POSN: C2RustUnnamed_33 = 262178;
    #[c2rust::src_loc = "531:3"]
    pub const _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE: C2RustUnnamed_33 = 262177;
    #[c2rust::src_loc = "530:3"]
    pub const _NL_MONETARY_DUO_INT_N_CS_PRECEDES: C2RustUnnamed_33 = 262176;
    #[c2rust::src_loc = "529:3"]
    pub const _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE: C2RustUnnamed_33 = 262175;
    #[c2rust::src_loc = "528:3"]
    pub const _NL_MONETARY_DUO_INT_P_CS_PRECEDES: C2RustUnnamed_33 = 262174;
    #[c2rust::src_loc = "527:3"]
    pub const _NL_MONETARY_DUO_N_SEP_BY_SPACE: C2RustUnnamed_33 = 262173;
    #[c2rust::src_loc = "526:3"]
    pub const _NL_MONETARY_DUO_N_CS_PRECEDES: C2RustUnnamed_33 = 262172;
    #[c2rust::src_loc = "525:3"]
    pub const _NL_MONETARY_DUO_P_SEP_BY_SPACE: C2RustUnnamed_33 = 262171;
    #[c2rust::src_loc = "524:3"]
    pub const _NL_MONETARY_DUO_P_CS_PRECEDES: C2RustUnnamed_33 = 262170;
    #[c2rust::src_loc = "523:3"]
    pub const _NL_MONETARY_DUO_FRAC_DIGITS: C2RustUnnamed_33 = 262169;
    #[c2rust::src_loc = "522:3"]
    pub const _NL_MONETARY_DUO_INT_FRAC_DIGITS: C2RustUnnamed_33 = 262168;
    #[c2rust::src_loc = "521:3"]
    pub const _NL_MONETARY_DUO_CURRENCY_SYMBOL: C2RustUnnamed_33 = 262167;
    #[c2rust::src_loc = "520:3"]
    pub const _NL_MONETARY_DUO_INT_CURR_SYMBOL: C2RustUnnamed_33 = 262166;
    #[c2rust::src_loc = "516:3"]
    pub const __INT_N_SIGN_POSN: C2RustUnnamed_33 = 262165;
    #[c2rust::src_loc = "512:3"]
    pub const __INT_P_SIGN_POSN: C2RustUnnamed_33 = 262164;
    #[c2rust::src_loc = "508:3"]
    pub const __INT_N_SEP_BY_SPACE: C2RustUnnamed_33 = 262163;
    #[c2rust::src_loc = "504:3"]
    pub const __INT_N_CS_PRECEDES: C2RustUnnamed_33 = 262162;
    #[c2rust::src_loc = "500:3"]
    pub const __INT_P_SEP_BY_SPACE: C2RustUnnamed_33 = 262161;
    #[c2rust::src_loc = "496:3"]
    pub const __INT_P_CS_PRECEDES: C2RustUnnamed_33 = 262160;
    #[c2rust::src_loc = "494:3"]
    pub const _NL_MONETARY_CRNCYSTR: C2RustUnnamed_33 = 262159;
    #[c2rust::src_loc = "490:3"]
    pub const __N_SIGN_POSN: C2RustUnnamed_33 = 262158;
    #[c2rust::src_loc = "486:3"]
    pub const __P_SIGN_POSN: C2RustUnnamed_33 = 262157;
    #[c2rust::src_loc = "482:3"]
    pub const __N_SEP_BY_SPACE: C2RustUnnamed_33 = 262156;
    #[c2rust::src_loc = "478:3"]
    pub const __N_CS_PRECEDES: C2RustUnnamed_33 = 262155;
    #[c2rust::src_loc = "474:3"]
    pub const __P_SEP_BY_SPACE: C2RustUnnamed_33 = 262154;
    #[c2rust::src_loc = "470:3"]
    pub const __P_CS_PRECEDES: C2RustUnnamed_33 = 262153;
    #[c2rust::src_loc = "466:3"]
    pub const __FRAC_DIGITS: C2RustUnnamed_33 = 262152;
    #[c2rust::src_loc = "462:3"]
    pub const __INT_FRAC_DIGITS: C2RustUnnamed_33 = 262151;
    #[c2rust::src_loc = "458:3"]
    pub const __NEGATIVE_SIGN: C2RustUnnamed_33 = 262150;
    #[c2rust::src_loc = "454:3"]
    pub const __POSITIVE_SIGN: C2RustUnnamed_33 = 262149;
    #[c2rust::src_loc = "450:3"]
    pub const __MON_GROUPING: C2RustUnnamed_33 = 262148;
    #[c2rust::src_loc = "446:3"]
    pub const __MON_THOUSANDS_SEP: C2RustUnnamed_33 = 262147;
    #[c2rust::src_loc = "442:3"]
    pub const __MON_DECIMAL_POINT: C2RustUnnamed_33 = 262146;
    #[c2rust::src_loc = "438:3"]
    pub const __CURRENCY_SYMBOL: C2RustUnnamed_33 = 262145;
    #[c2rust::src_loc = "434:3"]
    pub const __INT_CURR_SYMBOL: C2RustUnnamed_33 = 262144;
    #[c2rust::src_loc = "429:3"]
    pub const _NL_NUM_LC_CTYPE: C2RustUnnamed_33 = 86;
    #[c2rust::src_loc = "428:3"]
    pub const _NL_CTYPE_EXTRA_MAP_14: C2RustUnnamed_33 = 85;
    #[c2rust::src_loc = "427:3"]
    pub const _NL_CTYPE_EXTRA_MAP_13: C2RustUnnamed_33 = 84;
    #[c2rust::src_loc = "426:3"]
    pub const _NL_CTYPE_EXTRA_MAP_12: C2RustUnnamed_33 = 83;
    #[c2rust::src_loc = "425:3"]
    pub const _NL_CTYPE_EXTRA_MAP_11: C2RustUnnamed_33 = 82;
    #[c2rust::src_loc = "424:3"]
    pub const _NL_CTYPE_EXTRA_MAP_10: C2RustUnnamed_33 = 81;
    #[c2rust::src_loc = "423:3"]
    pub const _NL_CTYPE_EXTRA_MAP_9: C2RustUnnamed_33 = 80;
    #[c2rust::src_loc = "422:3"]
    pub const _NL_CTYPE_EXTRA_MAP_8: C2RustUnnamed_33 = 79;
    #[c2rust::src_loc = "421:3"]
    pub const _NL_CTYPE_EXTRA_MAP_7: C2RustUnnamed_33 = 78;
    #[c2rust::src_loc = "420:3"]
    pub const _NL_CTYPE_EXTRA_MAP_6: C2RustUnnamed_33 = 77;
    #[c2rust::src_loc = "419:3"]
    pub const _NL_CTYPE_EXTRA_MAP_5: C2RustUnnamed_33 = 76;
    #[c2rust::src_loc = "418:3"]
    pub const _NL_CTYPE_EXTRA_MAP_4: C2RustUnnamed_33 = 75;
    #[c2rust::src_loc = "417:3"]
    pub const _NL_CTYPE_EXTRA_MAP_3: C2RustUnnamed_33 = 74;
    #[c2rust::src_loc = "416:3"]
    pub const _NL_CTYPE_EXTRA_MAP_2: C2RustUnnamed_33 = 73;
    #[c2rust::src_loc = "415:3"]
    pub const _NL_CTYPE_EXTRA_MAP_1: C2RustUnnamed_33 = 72;
    #[c2rust::src_loc = "414:3"]
    pub const _NL_CTYPE_NONASCII_CASE: C2RustUnnamed_33 = 71;
    #[c2rust::src_loc = "413:3"]
    pub const _NL_CTYPE_MAP_TO_NONASCII: C2RustUnnamed_33 = 70;
    #[c2rust::src_loc = "412:3"]
    pub const _NL_CTYPE_TRANSLIT_IGNORE: C2RustUnnamed_33 = 69;
    #[c2rust::src_loc = "411:3"]
    pub const _NL_CTYPE_TRANSLIT_IGNORE_LEN: C2RustUnnamed_33 = 68;
    #[c2rust::src_loc = "410:3"]
    pub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING: C2RustUnnamed_33 = 67;
    #[c2rust::src_loc = "409:3"]
    pub const _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN: C2RustUnnamed_33 = 66;
    #[c2rust::src_loc = "408:3"]
    pub const _NL_CTYPE_TRANSLIT_TO_TBL: C2RustUnnamed_33 = 65;
    #[c2rust::src_loc = "407:3"]
    pub const _NL_CTYPE_TRANSLIT_TO_IDX: C2RustUnnamed_33 = 64;
    #[c2rust::src_loc = "406:3"]
    pub const _NL_CTYPE_TRANSLIT_FROM_TBL: C2RustUnnamed_33 = 63;
    #[c2rust::src_loc = "405:3"]
    pub const _NL_CTYPE_TRANSLIT_FROM_IDX: C2RustUnnamed_33 = 62;
    #[c2rust::src_loc = "404:3"]
    pub const _NL_CTYPE_TRANSLIT_TAB_SIZE: C2RustUnnamed_33 = 61;
    #[c2rust::src_loc = "403:3"]
    pub const _NL_CTYPE_OUTDIGIT9_WC: C2RustUnnamed_33 = 60;
    #[c2rust::src_loc = "402:3"]
    pub const _NL_CTYPE_OUTDIGIT8_WC: C2RustUnnamed_33 = 59;
    #[c2rust::src_loc = "401:3"]
    pub const _NL_CTYPE_OUTDIGIT7_WC: C2RustUnnamed_33 = 58;
    #[c2rust::src_loc = "400:3"]
    pub const _NL_CTYPE_OUTDIGIT6_WC: C2RustUnnamed_33 = 57;
    #[c2rust::src_loc = "399:3"]
    pub const _NL_CTYPE_OUTDIGIT5_WC: C2RustUnnamed_33 = 56;
    #[c2rust::src_loc = "398:3"]
    pub const _NL_CTYPE_OUTDIGIT4_WC: C2RustUnnamed_33 = 55;
    #[c2rust::src_loc = "397:3"]
    pub const _NL_CTYPE_OUTDIGIT3_WC: C2RustUnnamed_33 = 54;
    #[c2rust::src_loc = "396:3"]
    pub const _NL_CTYPE_OUTDIGIT2_WC: C2RustUnnamed_33 = 53;
    #[c2rust::src_loc = "395:3"]
    pub const _NL_CTYPE_OUTDIGIT1_WC: C2RustUnnamed_33 = 52;
    #[c2rust::src_loc = "394:3"]
    pub const _NL_CTYPE_OUTDIGIT0_WC: C2RustUnnamed_33 = 51;
    #[c2rust::src_loc = "393:3"]
    pub const _NL_CTYPE_OUTDIGIT9_MB: C2RustUnnamed_33 = 50;
    #[c2rust::src_loc = "392:3"]
    pub const _NL_CTYPE_OUTDIGIT8_MB: C2RustUnnamed_33 = 49;
    #[c2rust::src_loc = "391:3"]
    pub const _NL_CTYPE_OUTDIGIT7_MB: C2RustUnnamed_33 = 48;
    #[c2rust::src_loc = "390:3"]
    pub const _NL_CTYPE_OUTDIGIT6_MB: C2RustUnnamed_33 = 47;
    #[c2rust::src_loc = "389:3"]
    pub const _NL_CTYPE_OUTDIGIT5_MB: C2RustUnnamed_33 = 46;
    #[c2rust::src_loc = "388:3"]
    pub const _NL_CTYPE_OUTDIGIT4_MB: C2RustUnnamed_33 = 45;
    #[c2rust::src_loc = "387:3"]
    pub const _NL_CTYPE_OUTDIGIT3_MB: C2RustUnnamed_33 = 44;
    #[c2rust::src_loc = "386:3"]
    pub const _NL_CTYPE_OUTDIGIT2_MB: C2RustUnnamed_33 = 43;
    #[c2rust::src_loc = "385:3"]
    pub const _NL_CTYPE_OUTDIGIT1_MB: C2RustUnnamed_33 = 42;
    #[c2rust::src_loc = "384:3"]
    pub const _NL_CTYPE_OUTDIGIT0_MB: C2RustUnnamed_33 = 41;
    #[c2rust::src_loc = "383:3"]
    pub const _NL_CTYPE_INDIGITS9_WC: C2RustUnnamed_33 = 40;
    #[c2rust::src_loc = "382:3"]
    pub const _NL_CTYPE_INDIGITS8_WC: C2RustUnnamed_33 = 39;
    #[c2rust::src_loc = "381:3"]
    pub const _NL_CTYPE_INDIGITS7_WC: C2RustUnnamed_33 = 38;
    #[c2rust::src_loc = "380:3"]
    pub const _NL_CTYPE_INDIGITS6_WC: C2RustUnnamed_33 = 37;
    #[c2rust::src_loc = "379:3"]
    pub const _NL_CTYPE_INDIGITS5_WC: C2RustUnnamed_33 = 36;
    #[c2rust::src_loc = "378:3"]
    pub const _NL_CTYPE_INDIGITS4_WC: C2RustUnnamed_33 = 35;
    #[c2rust::src_loc = "377:3"]
    pub const _NL_CTYPE_INDIGITS3_WC: C2RustUnnamed_33 = 34;
    #[c2rust::src_loc = "376:3"]
    pub const _NL_CTYPE_INDIGITS2_WC: C2RustUnnamed_33 = 33;
    #[c2rust::src_loc = "375:3"]
    pub const _NL_CTYPE_INDIGITS1_WC: C2RustUnnamed_33 = 32;
    #[c2rust::src_loc = "374:3"]
    pub const _NL_CTYPE_INDIGITS0_WC: C2RustUnnamed_33 = 31;
    #[c2rust::src_loc = "373:3"]
    pub const _NL_CTYPE_INDIGITS_WC_LEN: C2RustUnnamed_33 = 30;
    #[c2rust::src_loc = "372:3"]
    pub const _NL_CTYPE_INDIGITS9_MB: C2RustUnnamed_33 = 29;
    #[c2rust::src_loc = "371:3"]
    pub const _NL_CTYPE_INDIGITS8_MB: C2RustUnnamed_33 = 28;
    #[c2rust::src_loc = "370:3"]
    pub const _NL_CTYPE_INDIGITS7_MB: C2RustUnnamed_33 = 27;
    #[c2rust::src_loc = "369:3"]
    pub const _NL_CTYPE_INDIGITS6_MB: C2RustUnnamed_33 = 26;
    #[c2rust::src_loc = "368:3"]
    pub const _NL_CTYPE_INDIGITS5_MB: C2RustUnnamed_33 = 25;
    #[c2rust::src_loc = "367:3"]
    pub const _NL_CTYPE_INDIGITS4_MB: C2RustUnnamed_33 = 24;
    #[c2rust::src_loc = "366:3"]
    pub const _NL_CTYPE_INDIGITS3_MB: C2RustUnnamed_33 = 23;
    #[c2rust::src_loc = "365:3"]
    pub const _NL_CTYPE_INDIGITS2_MB: C2RustUnnamed_33 = 22;
    #[c2rust::src_loc = "364:3"]
    pub const _NL_CTYPE_INDIGITS1_MB: C2RustUnnamed_33 = 21;
    #[c2rust::src_loc = "363:3"]
    pub const _NL_CTYPE_INDIGITS0_MB: C2RustUnnamed_33 = 20;
    #[c2rust::src_loc = "362:3"]
    pub const _NL_CTYPE_INDIGITS_MB_LEN: C2RustUnnamed_33 = 19;
    #[c2rust::src_loc = "361:3"]
    pub const _NL_CTYPE_MAP_OFFSET: C2RustUnnamed_33 = 18;
    #[c2rust::src_loc = "360:3"]
    pub const _NL_CTYPE_CLASS_OFFSET: C2RustUnnamed_33 = 17;
    #[c2rust::src_loc = "359:3"]
    pub const _NL_CTYPE_TOLOWER32: C2RustUnnamed_33 = 16;
    #[c2rust::src_loc = "358:3"]
    pub const _NL_CTYPE_TOUPPER32: C2RustUnnamed_33 = 15;
    #[c2rust::src_loc = "355:3"]
    pub const _NL_CTYPE_CODESET_NAME: C2RustUnnamed_33 = 14;
    #[c2rust::src_loc = "354:3"]
    pub const _NL_CTYPE_MB_CUR_MAX: C2RustUnnamed_33 = 13;
    #[c2rust::src_loc = "353:3"]
    pub const _NL_CTYPE_WIDTH: C2RustUnnamed_33 = 12;
    #[c2rust::src_loc = "352:3"]
    pub const _NL_CTYPE_MAP_NAMES: C2RustUnnamed_33 = 11;
    #[c2rust::src_loc = "351:3"]
    pub const _NL_CTYPE_CLASS_NAMES: C2RustUnnamed_33 = 10;
    #[c2rust::src_loc = "350:3"]
    pub const _NL_CTYPE_GAP6: C2RustUnnamed_33 = 9;
    #[c2rust::src_loc = "349:3"]
    pub const _NL_CTYPE_GAP5: C2RustUnnamed_33 = 8;
    #[c2rust::src_loc = "348:3"]
    pub const _NL_CTYPE_GAP4: C2RustUnnamed_33 = 7;
    #[c2rust::src_loc = "347:3"]
    pub const _NL_CTYPE_GAP3: C2RustUnnamed_33 = 6;
    #[c2rust::src_loc = "346:3"]
    pub const _NL_CTYPE_CLASS32: C2RustUnnamed_33 = 5;
    #[c2rust::src_loc = "345:3"]
    pub const _NL_CTYPE_GAP2: C2RustUnnamed_33 = 4;
    #[c2rust::src_loc = "344:3"]
    pub const _NL_CTYPE_TOLOWER: C2RustUnnamed_33 = 3;
    #[c2rust::src_loc = "343:3"]
    pub const _NL_CTYPE_GAP1: C2RustUnnamed_33 = 2;
    #[c2rust::src_loc = "342:3"]
    pub const _NL_CTYPE_TOUPPER: C2RustUnnamed_33 = 1;
    #[c2rust::src_loc = "341:3"]
    pub const _NL_CTYPE_CLASS: C2RustUnnamed_33 = 0;
    #[c2rust::src_loc = "336:3"]
    pub const _NL_NUM_LC_COLLATE: C2RustUnnamed_33 = 196627;
    #[c2rust::src_loc = "335:3"]
    pub const _NL_COLLATE_CODESET: C2RustUnnamed_33 = 196626;
    #[c2rust::src_loc = "334:3"]
    pub const _NL_COLLATE_COLLSEQWC: C2RustUnnamed_33 = 196625;
    #[c2rust::src_loc = "333:3"]
    pub const _NL_COLLATE_COLLSEQMB: C2RustUnnamed_33 = 196624;
    #[c2rust::src_loc = "332:3"]
    pub const _NL_COLLATE_SYMB_EXTRAMB: C2RustUnnamed_33 = 196623;
    #[c2rust::src_loc = "331:3"]
    pub const _NL_COLLATE_SYMB_TABLEMB: C2RustUnnamed_33 = 196622;
    #[c2rust::src_loc = "330:3"]
    pub const _NL_COLLATE_SYMB_HASH_SIZEMB: C2RustUnnamed_33 = 196621;
    #[c2rust::src_loc = "329:3"]
    pub const _NL_COLLATE_INDIRECTWC: C2RustUnnamed_33 = 196620;
    #[c2rust::src_loc = "328:3"]
    pub const _NL_COLLATE_EXTRAWC: C2RustUnnamed_33 = 196619;
    #[c2rust::src_loc = "327:3"]
    pub const _NL_COLLATE_WEIGHTWC: C2RustUnnamed_33 = 196618;
    #[c2rust::src_loc = "326:3"]
    pub const _NL_COLLATE_TABLEWC: C2RustUnnamed_33 = 196617;
    #[c2rust::src_loc = "325:3"]
    pub const _NL_COLLATE_GAP3: C2RustUnnamed_33 = 196616;
    #[c2rust::src_loc = "324:3"]
    pub const _NL_COLLATE_GAP2: C2RustUnnamed_33 = 196615;
    #[c2rust::src_loc = "323:3"]
    pub const _NL_COLLATE_GAP1: C2RustUnnamed_33 = 196614;
    #[c2rust::src_loc = "322:3"]
    pub const _NL_COLLATE_INDIRECTMB: C2RustUnnamed_33 = 196613;
    #[c2rust::src_loc = "321:3"]
    pub const _NL_COLLATE_EXTRAMB: C2RustUnnamed_33 = 196612;
    #[c2rust::src_loc = "320:3"]
    pub const _NL_COLLATE_WEIGHTMB: C2RustUnnamed_33 = 196611;
    #[c2rust::src_loc = "319:3"]
    pub const _NL_COLLATE_TABLEMB: C2RustUnnamed_33 = 196610;
    #[c2rust::src_loc = "318:3"]
    pub const _NL_COLLATE_RULESETS: C2RustUnnamed_33 = 196609;
    #[c2rust::src_loc = "317:3"]
    pub const _NL_COLLATE_NRULES: C2RustUnnamed_33 = 196608;
    #[c2rust::src_loc = "312:3"]
    pub const _NL_NUM_LC_TIME: C2RustUnnamed_33 = 131231;
    #[c2rust::src_loc = "310:3"]
    pub const _NL_WABALTMON_12: C2RustUnnamed_33 = 131230;
    #[c2rust::src_loc = "309:3"]
    pub const _NL_WABALTMON_11: C2RustUnnamed_33 = 131229;
    #[c2rust::src_loc = "308:3"]
    pub const _NL_WABALTMON_10: C2RustUnnamed_33 = 131228;
    #[c2rust::src_loc = "307:3"]
    pub const _NL_WABALTMON_9: C2RustUnnamed_33 = 131227;
    #[c2rust::src_loc = "306:3"]
    pub const _NL_WABALTMON_8: C2RustUnnamed_33 = 131226;
    #[c2rust::src_loc = "305:3"]
    pub const _NL_WABALTMON_7: C2RustUnnamed_33 = 131225;
    #[c2rust::src_loc = "304:3"]
    pub const _NL_WABALTMON_6: C2RustUnnamed_33 = 131224;
    #[c2rust::src_loc = "303:3"]
    pub const _NL_WABALTMON_5: C2RustUnnamed_33 = 131223;
    #[c2rust::src_loc = "302:3"]
    pub const _NL_WABALTMON_4: C2RustUnnamed_33 = 131222;
    #[c2rust::src_loc = "301:3"]
    pub const _NL_WABALTMON_3: C2RustUnnamed_33 = 131221;
    #[c2rust::src_loc = "300:3"]
    pub const _NL_WABALTMON_2: C2RustUnnamed_33 = 131220;
    #[c2rust::src_loc = "299:3"]
    pub const _NL_WABALTMON_1: C2RustUnnamed_33 = 131219;
    #[c2rust::src_loc = "295:3"]
    pub const _NL_ABALTMON_12: C2RustUnnamed_33 = 131218;
    #[c2rust::src_loc = "294:3"]
    pub const _NL_ABALTMON_11: C2RustUnnamed_33 = 131217;
    #[c2rust::src_loc = "293:3"]
    pub const _NL_ABALTMON_10: C2RustUnnamed_33 = 131216;
    #[c2rust::src_loc = "292:3"]
    pub const _NL_ABALTMON_9: C2RustUnnamed_33 = 131215;
    #[c2rust::src_loc = "291:3"]
    pub const _NL_ABALTMON_8: C2RustUnnamed_33 = 131214;
    #[c2rust::src_loc = "290:3"]
    pub const _NL_ABALTMON_7: C2RustUnnamed_33 = 131213;
    #[c2rust::src_loc = "289:3"]
    pub const _NL_ABALTMON_6: C2RustUnnamed_33 = 131212;
    #[c2rust::src_loc = "288:3"]
    pub const _NL_ABALTMON_5: C2RustUnnamed_33 = 131211;
    #[c2rust::src_loc = "287:3"]
    pub const _NL_ABALTMON_4: C2RustUnnamed_33 = 131210;
    #[c2rust::src_loc = "286:3"]
    pub const _NL_ABALTMON_3: C2RustUnnamed_33 = 131209;
    #[c2rust::src_loc = "285:3"]
    pub const _NL_ABALTMON_2: C2RustUnnamed_33 = 131208;
    #[c2rust::src_loc = "284:3"]
    pub const _NL_ABALTMON_1: C2RustUnnamed_33 = 131207;
    #[c2rust::src_loc = "280:3"]
    pub const _NL_WALTMON_12: C2RustUnnamed_33 = 131206;
    #[c2rust::src_loc = "279:3"]
    pub const _NL_WALTMON_11: C2RustUnnamed_33 = 131205;
    #[c2rust::src_loc = "278:3"]
    pub const _NL_WALTMON_10: C2RustUnnamed_33 = 131204;
    #[c2rust::src_loc = "277:3"]
    pub const _NL_WALTMON_9: C2RustUnnamed_33 = 131203;
    #[c2rust::src_loc = "276:3"]
    pub const _NL_WALTMON_8: C2RustUnnamed_33 = 131202;
    #[c2rust::src_loc = "275:3"]
    pub const _NL_WALTMON_7: C2RustUnnamed_33 = 131201;
    #[c2rust::src_loc = "274:3"]
    pub const _NL_WALTMON_6: C2RustUnnamed_33 = 131200;
    #[c2rust::src_loc = "273:3"]
    pub const _NL_WALTMON_5: C2RustUnnamed_33 = 131199;
    #[c2rust::src_loc = "272:3"]
    pub const _NL_WALTMON_4: C2RustUnnamed_33 = 131198;
    #[c2rust::src_loc = "271:3"]
    pub const _NL_WALTMON_3: C2RustUnnamed_33 = 131197;
    #[c2rust::src_loc = "270:3"]
    pub const _NL_WALTMON_2: C2RustUnnamed_33 = 131196;
    #[c2rust::src_loc = "269:3"]
    pub const _NL_WALTMON_1: C2RustUnnamed_33 = 131195;
    #[c2rust::src_loc = "251:3"]
    pub const __ALTMON_12: C2RustUnnamed_33 = 131194;
    #[c2rust::src_loc = "250:3"]
    pub const __ALTMON_11: C2RustUnnamed_33 = 131193;
    #[c2rust::src_loc = "249:3"]
    pub const __ALTMON_10: C2RustUnnamed_33 = 131192;
    #[c2rust::src_loc = "248:3"]
    pub const __ALTMON_9: C2RustUnnamed_33 = 131191;
    #[c2rust::src_loc = "247:3"]
    pub const __ALTMON_8: C2RustUnnamed_33 = 131190;
    #[c2rust::src_loc = "246:3"]
    pub const __ALTMON_7: C2RustUnnamed_33 = 131189;
    #[c2rust::src_loc = "245:3"]
    pub const __ALTMON_6: C2RustUnnamed_33 = 131188;
    #[c2rust::src_loc = "244:3"]
    pub const __ALTMON_5: C2RustUnnamed_33 = 131187;
    #[c2rust::src_loc = "243:3"]
    pub const __ALTMON_4: C2RustUnnamed_33 = 131186;
    #[c2rust::src_loc = "242:3"]
    pub const __ALTMON_3: C2RustUnnamed_33 = 131185;
    #[c2rust::src_loc = "241:3"]
    pub const __ALTMON_2: C2RustUnnamed_33 = 131184;
    #[c2rust::src_loc = "240:3"]
    pub const __ALTMON_1: C2RustUnnamed_33 = 131183;
    #[c2rust::src_loc = "236:3"]
    pub const _NL_TIME_CODESET: C2RustUnnamed_33 = 131182;
    #[c2rust::src_loc = "234:3"]
    pub const _NL_W_DATE_FMT: C2RustUnnamed_33 = 131181;
    #[c2rust::src_loc = "232:3"]
    pub const _DATE_FMT: C2RustUnnamed_33 = 131180;
    #[c2rust::src_loc = "230:3"]
    pub const _NL_TIME_TIMEZONE: C2RustUnnamed_33 = 131179;
    #[c2rust::src_loc = "229:3"]
    pub const _NL_TIME_CAL_DIRECTION: C2RustUnnamed_33 = 131178;
    #[c2rust::src_loc = "228:3"]
    pub const _NL_TIME_FIRST_WORKDAY: C2RustUnnamed_33 = 131177;
    #[c2rust::src_loc = "227:3"]
    pub const _NL_TIME_FIRST_WEEKDAY: C2RustUnnamed_33 = 131176;
    #[c2rust::src_loc = "226:3"]
    pub const _NL_TIME_WEEK_1STWEEK: C2RustUnnamed_33 = 131175;
    #[c2rust::src_loc = "225:3"]
    pub const _NL_TIME_WEEK_1STDAY: C2RustUnnamed_33 = 131174;
    #[c2rust::src_loc = "224:3"]
    pub const _NL_TIME_WEEK_NDAYS: C2RustUnnamed_33 = 131173;
    #[c2rust::src_loc = "222:3"]
    pub const _NL_WERA_T_FMT: C2RustUnnamed_33 = 131172;
    #[c2rust::src_loc = "221:3"]
    pub const _NL_WERA_D_T_FMT: C2RustUnnamed_33 = 131171;
    #[c2rust::src_loc = "220:3"]
    pub const _NL_WALT_DIGITS: C2RustUnnamed_33 = 131170;
    #[c2rust::src_loc = "219:3"]
    pub const _NL_WERA_D_FMT: C2RustUnnamed_33 = 131169;
    #[c2rust::src_loc = "218:3"]
    pub const _NL_WERA_YEAR: C2RustUnnamed_33 = 131168;
    #[c2rust::src_loc = "216:3"]
    pub const _NL_WT_FMT_AMPM: C2RustUnnamed_33 = 131167;
    #[c2rust::src_loc = "215:3"]
    pub const _NL_WT_FMT: C2RustUnnamed_33 = 131166;
    #[c2rust::src_loc = "214:3"]
    pub const _NL_WD_FMT: C2RustUnnamed_33 = 131165;
    #[c2rust::src_loc = "213:3"]
    pub const _NL_WD_T_FMT: C2RustUnnamed_33 = 131164;
    #[c2rust::src_loc = "211:3"]
    pub const _NL_WPM_STR: C2RustUnnamed_33 = 131163;
    #[c2rust::src_loc = "210:3"]
    pub const _NL_WAM_STR: C2RustUnnamed_33 = 131162;
    #[c2rust::src_loc = "208:3"]
    pub const _NL_WMON_12: C2RustUnnamed_33 = 131161;
    #[c2rust::src_loc = "207:3"]
    pub const _NL_WMON_11: C2RustUnnamed_33 = 131160;
    #[c2rust::src_loc = "206:3"]
    pub const _NL_WMON_10: C2RustUnnamed_33 = 131159;
    #[c2rust::src_loc = "205:3"]
    pub const _NL_WMON_9: C2RustUnnamed_33 = 131158;
    #[c2rust::src_loc = "204:3"]
    pub const _NL_WMON_8: C2RustUnnamed_33 = 131157;
    #[c2rust::src_loc = "203:3"]
    pub const _NL_WMON_7: C2RustUnnamed_33 = 131156;
    #[c2rust::src_loc = "202:3"]
    pub const _NL_WMON_6: C2RustUnnamed_33 = 131155;
    #[c2rust::src_loc = "201:3"]
    pub const _NL_WMON_5: C2RustUnnamed_33 = 131154;
    #[c2rust::src_loc = "200:3"]
    pub const _NL_WMON_4: C2RustUnnamed_33 = 131153;
    #[c2rust::src_loc = "199:3"]
    pub const _NL_WMON_3: C2RustUnnamed_33 = 131152;
    #[c2rust::src_loc = "198:3"]
    pub const _NL_WMON_2: C2RustUnnamed_33 = 131151;
    #[c2rust::src_loc = "197:3"]
    pub const _NL_WMON_1: C2RustUnnamed_33 = 131150;
    #[c2rust::src_loc = "193:3"]
    pub const _NL_WABMON_12: C2RustUnnamed_33 = 131149;
    #[c2rust::src_loc = "192:3"]
    pub const _NL_WABMON_11: C2RustUnnamed_33 = 131148;
    #[c2rust::src_loc = "191:3"]
    pub const _NL_WABMON_10: C2RustUnnamed_33 = 131147;
    #[c2rust::src_loc = "190:3"]
    pub const _NL_WABMON_9: C2RustUnnamed_33 = 131146;
    #[c2rust::src_loc = "189:3"]
    pub const _NL_WABMON_8: C2RustUnnamed_33 = 131145;
    #[c2rust::src_loc = "188:3"]
    pub const _NL_WABMON_7: C2RustUnnamed_33 = 131144;
    #[c2rust::src_loc = "187:3"]
    pub const _NL_WABMON_6: C2RustUnnamed_33 = 131143;
    #[c2rust::src_loc = "186:3"]
    pub const _NL_WABMON_5: C2RustUnnamed_33 = 131142;
    #[c2rust::src_loc = "185:3"]
    pub const _NL_WABMON_4: C2RustUnnamed_33 = 131141;
    #[c2rust::src_loc = "184:3"]
    pub const _NL_WABMON_3: C2RustUnnamed_33 = 131140;
    #[c2rust::src_loc = "183:3"]
    pub const _NL_WABMON_2: C2RustUnnamed_33 = 131139;
    #[c2rust::src_loc = "182:3"]
    pub const _NL_WABMON_1: C2RustUnnamed_33 = 131138;
    #[c2rust::src_loc = "178:3"]
    pub const _NL_WDAY_7: C2RustUnnamed_33 = 131137;
    #[c2rust::src_loc = "177:3"]
    pub const _NL_WDAY_6: C2RustUnnamed_33 = 131136;
    #[c2rust::src_loc = "176:3"]
    pub const _NL_WDAY_5: C2RustUnnamed_33 = 131135;
    #[c2rust::src_loc = "175:3"]
    pub const _NL_WDAY_4: C2RustUnnamed_33 = 131134;
    #[c2rust::src_loc = "174:3"]
    pub const _NL_WDAY_3: C2RustUnnamed_33 = 131133;
    #[c2rust::src_loc = "173:3"]
    pub const _NL_WDAY_2: C2RustUnnamed_33 = 131132;
    #[c2rust::src_loc = "172:3"]
    pub const _NL_WDAY_1: C2RustUnnamed_33 = 131131;
    #[c2rust::src_loc = "169:3"]
    pub const _NL_WABDAY_7: C2RustUnnamed_33 = 131130;
    #[c2rust::src_loc = "168:3"]
    pub const _NL_WABDAY_6: C2RustUnnamed_33 = 131129;
    #[c2rust::src_loc = "167:3"]
    pub const _NL_WABDAY_5: C2RustUnnamed_33 = 131128;
    #[c2rust::src_loc = "166:3"]
    pub const _NL_WABDAY_4: C2RustUnnamed_33 = 131127;
    #[c2rust::src_loc = "165:3"]
    pub const _NL_WABDAY_3: C2RustUnnamed_33 = 131126;
    #[c2rust::src_loc = "164:3"]
    pub const _NL_WABDAY_2: C2RustUnnamed_33 = 131125;
    #[c2rust::src_loc = "163:3"]
    pub const _NL_WABDAY_1: C2RustUnnamed_33 = 131124;
    #[c2rust::src_loc = "161:3"]
    pub const _NL_TIME_ERA_ENTRIES: C2RustUnnamed_33 = 131123;
    #[c2rust::src_loc = "160:3"]
    pub const _NL_TIME_ERA_NUM_ENTRIES: C2RustUnnamed_33 = 131122;
    #[c2rust::src_loc = "157:3"]
    pub const ERA_T_FMT: C2RustUnnamed_33 = 131121;
    #[c2rust::src_loc = "155:3"]
    pub const ERA_D_T_FMT: C2RustUnnamed_33 = 131120;
    #[c2rust::src_loc = "153:3"]
    pub const ALT_DIGITS: C2RustUnnamed_33 = 131119;
    #[c2rust::src_loc = "151:3"]
    pub const ERA_D_FMT: C2RustUnnamed_33 = 131118;
    #[c2rust::src_loc = "147:3"]
    pub const __ERA_YEAR: C2RustUnnamed_33 = 131117;
    #[c2rust::src_loc = "145:3"]
    pub const ERA: C2RustUnnamed_33 = 131116;
    #[c2rust::src_loc = "142:3"]
    pub const T_FMT_AMPM: C2RustUnnamed_33 = 131115;
    #[c2rust::src_loc = "140:3"]
    pub const T_FMT: C2RustUnnamed_33 = 131114;
    #[c2rust::src_loc = "138:3"]
    pub const D_FMT: C2RustUnnamed_33 = 131113;
    #[c2rust::src_loc = "136:3"]
    pub const D_T_FMT: C2RustUnnamed_33 = 131112;
    #[c2rust::src_loc = "133:3"]
    pub const PM_STR: C2RustUnnamed_33 = 131111;
    #[c2rust::src_loc = "131:3"]
    pub const AM_STR: C2RustUnnamed_33 = 131110;
    #[c2rust::src_loc = "128:3"]
    pub const MON_12: C2RustUnnamed_33 = 131109;
    #[c2rust::src_loc = "126:3"]
    pub const MON_11: C2RustUnnamed_33 = 131108;
    #[c2rust::src_loc = "124:3"]
    pub const MON_10: C2RustUnnamed_33 = 131107;
    #[c2rust::src_loc = "122:3"]
    pub const MON_9: C2RustUnnamed_33 = 131106;
    #[c2rust::src_loc = "120:3"]
    pub const MON_8: C2RustUnnamed_33 = 131105;
    #[c2rust::src_loc = "118:3"]
    pub const MON_7: C2RustUnnamed_33 = 131104;
    #[c2rust::src_loc = "116:3"]
    pub const MON_6: C2RustUnnamed_33 = 131103;
    #[c2rust::src_loc = "114:3"]
    pub const MON_5: C2RustUnnamed_33 = 131102;
    #[c2rust::src_loc = "112:3"]
    pub const MON_4: C2RustUnnamed_33 = 131101;
    #[c2rust::src_loc = "110:3"]
    pub const MON_3: C2RustUnnamed_33 = 131100;
    #[c2rust::src_loc = "108:3"]
    pub const MON_2: C2RustUnnamed_33 = 131099;
    #[c2rust::src_loc = "106:3"]
    pub const MON_1: C2RustUnnamed_33 = 131098;
    #[c2rust::src_loc = "101:3"]
    pub const ABMON_12: C2RustUnnamed_33 = 131097;
    #[c2rust::src_loc = "99:3"]
    pub const ABMON_11: C2RustUnnamed_33 = 131096;
    #[c2rust::src_loc = "97:3"]
    pub const ABMON_10: C2RustUnnamed_33 = 131095;
    #[c2rust::src_loc = "95:3"]
    pub const ABMON_9: C2RustUnnamed_33 = 131094;
    #[c2rust::src_loc = "93:3"]
    pub const ABMON_8: C2RustUnnamed_33 = 131093;
    #[c2rust::src_loc = "91:3"]
    pub const ABMON_7: C2RustUnnamed_33 = 131092;
    #[c2rust::src_loc = "89:3"]
    pub const ABMON_6: C2RustUnnamed_33 = 131091;
    #[c2rust::src_loc = "87:3"]
    pub const ABMON_5: C2RustUnnamed_33 = 131090;
    #[c2rust::src_loc = "85:3"]
    pub const ABMON_4: C2RustUnnamed_33 = 131089;
    #[c2rust::src_loc = "83:3"]
    pub const ABMON_3: C2RustUnnamed_33 = 131088;
    #[c2rust::src_loc = "81:3"]
    pub const ABMON_2: C2RustUnnamed_33 = 131087;
    #[c2rust::src_loc = "79:3"]
    pub const ABMON_1: C2RustUnnamed_33 = 131086;
    #[c2rust::src_loc = "74:3"]
    pub const DAY_7: C2RustUnnamed_33 = 131085;
    #[c2rust::src_loc = "72:3"]
    pub const DAY_6: C2RustUnnamed_33 = 131084;
    #[c2rust::src_loc = "70:3"]
    pub const DAY_5: C2RustUnnamed_33 = 131083;
    #[c2rust::src_loc = "68:3"]
    pub const DAY_4: C2RustUnnamed_33 = 131082;
    #[c2rust::src_loc = "66:3"]
    pub const DAY_3: C2RustUnnamed_33 = 131081;
    #[c2rust::src_loc = "64:3"]
    pub const DAY_2: C2RustUnnamed_33 = 131080;
    #[c2rust::src_loc = "62:3"]
    pub const DAY_1: C2RustUnnamed_33 = 131079;
    #[c2rust::src_loc = "58:3"]
    pub const ABDAY_7: C2RustUnnamed_33 = 131078;
    #[c2rust::src_loc = "56:3"]
    pub const ABDAY_6: C2RustUnnamed_33 = 131077;
    #[c2rust::src_loc = "54:3"]
    pub const ABDAY_5: C2RustUnnamed_33 = 131076;
    #[c2rust::src_loc = "52:3"]
    pub const ABDAY_4: C2RustUnnamed_33 = 131075;
    #[c2rust::src_loc = "50:3"]
    pub const ABDAY_3: C2RustUnnamed_33 = 131074;
    #[c2rust::src_loc = "48:3"]
    pub const ABDAY_2: C2RustUnnamed_33 = 131073;
    #[c2rust::src_loc = "46:3"]
    pub const ABDAY_1: C2RustUnnamed_33 = 131072;
    #[c2rust::src_loc = "357:9"]
    pub const CODESET_0: libc::c_int = CODESET as libc::c_int;
    use super::nl_types_h::nl_item;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "661:1"]
        pub fn nl_langinfo(__item: nl_item) -> *mut libc::c_char;
    }
}
#[c2rust::header_src = "/usr/include/nl_types.h:2000"]
pub mod nl_types_h {
    #[c2rust::src_loc = "36:1"]
    pub type nl_item = libc::c_int;
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h:34"]
pub mod struct_iovec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:8"]
    pub struct iovec {
        pub iov_base: *mut libc::c_void,
        pub iov_len: size_t,
    }
    use super::stddef_h::size_t;
}
#[c2rust::header_src = "/home/vole/neovim/.deps/usr/include/uv.h:34"]
pub mod uv_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1693:8"]
    pub struct uv_loop_s {
        pub data: *mut libc::c_void,
        pub active_handles: libc::c_uint,
        pub handle_queue: [*mut libc::c_void; 2],
        pub active_reqs: C2RustUnnamed_20,
        pub stop_flag: libc::c_uint,
        pub flags: libc::c_ulong,
        pub backend_fd: libc::c_int,
        pub pending_queue: [*mut libc::c_void; 2],
        pub watcher_queue: [*mut libc::c_void; 2],
        pub watchers: *mut *mut uv__io_t,
        pub nwatchers: libc::c_uint,
        pub nfds: libc::c_uint,
        pub wq: [*mut libc::c_void; 2],
        pub wq_mutex: uv_mutex_t,
        pub wq_async: uv_async_t,
        pub cloexec_lock: uv_rwlock_t,
        pub closing_handles: *mut uv_handle_t,
        pub process_handles: [*mut libc::c_void; 2],
        pub prepare_handles: [*mut libc::c_void; 2],
        pub check_handles: [*mut libc::c_void; 2],
        pub idle_handles: [*mut libc::c_void; 2],
        pub async_handles: [*mut libc::c_void; 2],
        pub async_unused: Option<unsafe extern "C" fn() -> ()>,
        pub async_io_watcher: uv__io_t,
        pub async_wfd: libc::c_int,
        pub timer_heap: C2RustUnnamed_18,
        pub timer_counter: uint64_t,
        pub time: uint64_t,
        pub signal_pipefd: [libc::c_int; 2],
        pub signal_io_watcher: uv__io_t,
        pub child_watcher: uv_signal_t,
        pub emfile_fd: libc::c_int,
        pub inotify_read_watcher: uv__io_t,
        pub inotify_watchers: *mut libc::c_void,
        pub inotify_fd: libc::c_int,
    }
    #[c2rust::src_loc = "225:1"]
    pub type uv_signal_t = uv_signal_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1508:8"]
    pub struct uv_signal_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_17,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub signal_cb: uv_signal_cb,
        pub signum: libc::c_int,
        pub tree_entry: C2RustUnnamed_15,
        pub caught_signals: libc::c_uint,
        pub dispatched_signals: libc::c_uint,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1512:3"]
    pub struct C2RustUnnamed_15 {
        pub rbe_left: *mut uv_signal_s,
        pub rbe_right: *mut uv_signal_s,
        pub rbe_parent: *mut uv_signal_s,
        pub rbe_color: libc::c_int,
    }
    #[c2rust::src_loc = "370:1"]
    pub type uv_signal_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_signal_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "209:1"]
    pub type uv_handle_t = uv_handle_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "435:8"]
    pub struct uv_handle_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_16,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "436:3"]
    pub union C2RustUnnamed_16 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "314:1"]
    pub type uv_close_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_handle_t) -> ()>;
    #[c2rust::src_loc = "188:9"]
    pub type uv_handle_type = libc::c_uint;
    #[c2rust::src_loc = "194:3"]
    pub const UV_HANDLE_TYPE_MAX: uv_handle_type = 18;
    #[c2rust::src_loc = "193:3"]
    pub const UV_FILE: uv_handle_type = 17;
    #[c2rust::src_loc = "191:22"]
    pub const UV_SIGNAL: uv_handle_type = 16;
    #[c2rust::src_loc = "191:22"]
    pub const UV_UDP: uv_handle_type = 15;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TTY: uv_handle_type = 14;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TIMER: uv_handle_type = 13;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TCP: uv_handle_type = 12;
    #[c2rust::src_loc = "191:22"]
    pub const UV_STREAM: uv_handle_type = 11;
    #[c2rust::src_loc = "191:22"]
    pub const UV_PROCESS: uv_handle_type = 10;
    #[c2rust::src_loc = "191:22"]
    pub const UV_PREPARE: uv_handle_type = 9;
    #[c2rust::src_loc = "191:22"]
    pub const UV_POLL: uv_handle_type = 8;
    #[c2rust::src_loc = "191:22"]
    pub const UV_NAMED_PIPE: uv_handle_type = 7;
    #[c2rust::src_loc = "191:22"]
    pub const UV_IDLE: uv_handle_type = 6;
    #[c2rust::src_loc = "191:22"]
    pub const UV_HANDLE: uv_handle_type = 5;
    #[c2rust::src_loc = "191:22"]
    pub const UV_FS_POLL: uv_handle_type = 4;
    #[c2rust::src_loc = "191:22"]
    pub const UV_FS_EVENT: uv_handle_type = 3;
    #[c2rust::src_loc = "191:22"]
    pub const UV_CHECK: uv_handle_type = 2;
    #[c2rust::src_loc = "191:22"]
    pub const UV_ASYNC: uv_handle_type = 1;
    #[c2rust::src_loc = "189:3"]
    pub const UV_UNKNOWN_HANDLE: uv_handle_type = 0;
    #[c2rust::src_loc = "208:1"]
    pub type uv_loop_t = uv_loop_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1509:3"]
    pub union C2RustUnnamed_17 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1705:3"]
    pub struct C2RustUnnamed_18 {
        pub min: *mut libc::c_void,
        pub nelts: libc::c_uint,
    }
    #[c2rust::src_loc = "221:1"]
    pub type uv_async_t = uv_async_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "803:8"]
    pub struct uv_async_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_19,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub async_cb: uv_async_cb,
        pub queue: [*mut libc::c_void; 2],
        pub pending: libc::c_int,
    }
    #[c2rust::src_loc = "317:1"]
    pub type uv_async_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_async_t) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "804:3"]
    pub union C2RustUnnamed_19 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1699:3"]
    pub union C2RustUnnamed_20 {
        pub unused: [*mut libc::c_void; 2],
        pub count: libc::c_uint,
    }
    #[c2rust::src_loc = "197:9"]
    pub type uv_req_type = libc::c_uint;
    #[c2rust::src_loc = "203:3"]
    pub const UV_REQ_TYPE_MAX: uv_req_type = 10;
    #[c2rust::src_loc = "200:19"]
    pub const UV_GETNAMEINFO: uv_req_type = 9;
    #[c2rust::src_loc = "200:19"]
    pub const UV_GETADDRINFO: uv_req_type = 8;
    #[c2rust::src_loc = "200:19"]
    pub const UV_WORK: uv_req_type = 7;
    #[c2rust::src_loc = "200:19"]
    pub const UV_FS: uv_req_type = 6;
    #[c2rust::src_loc = "200:19"]
    pub const UV_UDP_SEND: uv_req_type = 5;
    #[c2rust::src_loc = "200:19"]
    pub const UV_SHUTDOWN: uv_req_type = 4;
    #[c2rust::src_loc = "200:19"]
    pub const UV_WRITE: uv_req_type = 3;
    #[c2rust::src_loc = "200:19"]
    pub const UV_CONNECT: uv_req_type = 2;
    #[c2rust::src_loc = "200:19"]
    pub const UV_REQ: uv_req_type = 1;
    #[c2rust::src_loc = "198:3"]
    pub const UV_UNKNOWN_REQ: uv_req_type = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "485:8"]
    pub struct uv_stream_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_21,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
    }
    #[c2rust::src_loc = "313:1"]
    pub type uv_connection_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_stream_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "211:1"]
    pub type uv_stream_t = uv_stream_s;
    #[c2rust::src_loc = "231:1"]
    pub type uv_shutdown_t = uv_shutdown_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "411:8"]
    pub struct uv_shutdown_s {
        pub data: *mut libc::c_void,
        pub type_0: uv_req_type,
        pub reserved: [*mut libc::c_void; 6],
        pub handle: *mut uv_stream_t,
        pub cb: uv_shutdown_cb,
    }
    #[c2rust::src_loc = "312:1"]
    pub type uv_shutdown_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_shutdown_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "233:1"]
    pub type uv_connect_t = uv_connect_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "574:8"]
    pub struct uv_connect_s {
        pub data: *mut libc::c_void,
        pub type_0: uv_req_type,
        pub reserved: [*mut libc::c_void; 6],
        pub cb: uv_connect_cb,
        pub handle: *mut uv_stream_t,
        pub queue: [*mut libc::c_void; 2],
    }
    #[c2rust::src_loc = "311:1"]
    pub type uv_connect_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_connect_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "307:1"]
    pub type uv_read_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_stream_t, _: ssize_t,
                                    _: *const uv_buf_t) -> ()>;
    #[c2rust::src_loc = "304:1"]
    pub type uv_alloc_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_handle_t, _: size_t,
                                    _: *mut uv_buf_t) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "486:3"]
    pub union C2RustUnnamed_21 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "538:8"]
    pub struct uv_tcp_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_22,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "539:3"]
    pub union C2RustUnnamed_22 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "212:1"]
    pub type uv_tcp_t = uv_tcp_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "726:8"]
    pub struct uv_pipe_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_23,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
        pub ipc: libc::c_int,
        pub pipe_fname: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "727:3"]
    pub union C2RustUnnamed_23 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "214:1"]
    pub type uv_pipe_t = uv_pipe_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "819:8"]
    pub struct uv_timer_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_24,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub timer_cb: uv_timer_cb,
        pub heap_node: [*mut libc::c_void; 3],
        pub timeout: uint64_t,
        pub repeat: uint64_t,
        pub start_id: uint64_t,
    }
    #[c2rust::src_loc = "316:1"]
    pub type uv_timer_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_timer_t) -> ()>;
    #[c2rust::src_loc = "217:1"]
    pub type uv_timer_t = uv_timer_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "820:3"]
    pub union C2RustUnnamed_24 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "793:8"]
    pub struct uv_idle_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_25,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub idle_cb: uv_idle_cb,
        pub queue: [*mut libc::c_void; 2],
    }
    #[c2rust::src_loc = "320:1"]
    pub type uv_idle_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_idle_t) -> ()>;
    #[c2rust::src_loc = "220:1"]
    pub type uv_idle_t = uv_idle_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "794:3"]
    pub union C2RustUnnamed_25 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1006:8"]
    pub struct uv_process_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_26,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub exit_cb: uv_exit_cb,
        pub pid: libc::c_int,
        pub queue: [*mut libc::c_void; 2],
        pub status: libc::c_int,
    }
    #[c2rust::src_loc = "321:1"]
    pub type uv_exit_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_process_t, _: int64_t,
                                    _: libc::c_int) -> ()>;
    #[c2rust::src_loc = "222:1"]
    pub type uv_process_t = uv_process_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1007:3"]
    pub union C2RustUnnamed_26 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "879:9"]
    pub type uv_stdio_flags = libc::c_uint;
    #[c2rust::src_loc = "897:3"]
    pub const UV_OVERLAPPED_PIPE: uv_stdio_flags = 64;
    #[c2rust::src_loc = "891:3"]
    pub const UV_WRITABLE_PIPE: uv_stdio_flags = 32;
    #[c2rust::src_loc = "890:3"]
    pub const UV_READABLE_PIPE: uv_stdio_flags = 16;
    #[c2rust::src_loc = "883:3"]
    pub const UV_INHERIT_STREAM: uv_stdio_flags = 4;
    #[c2rust::src_loc = "882:3"]
    pub const UV_INHERIT_FD: uv_stdio_flags = 2;
    #[c2rust::src_loc = "881:3"]
    pub const UV_CREATE_PIPE: uv_stdio_flags = 1;
    #[c2rust::src_loc = "880:3"]
    pub const UV_IGNORE: uv_stdio_flags = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "900:16"]
    pub struct uv_stdio_container_s {
        pub flags: uv_stdio_flags,
        pub data: C2RustUnnamed_27,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "903:3"]
    pub union C2RustUnnamed_27 {
        pub stream: *mut uv_stream_t,
        pub fd: libc::c_int,
    }
    #[c2rust::src_loc = "900:1"]
    pub type uv_stdio_container_t = uv_stdio_container_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "909:16"]
    pub struct uv_process_options_s {
        pub exit_cb: uv_exit_cb,
        pub file: *const libc::c_char,
        pub args: *mut *mut libc::c_char,
        pub env: *mut *mut libc::c_char,
        pub cwd: *const libc::c_char,
        pub flags: libc::c_uint,
        pub stdio_count: libc::c_int,
        pub stdio: *mut uv_stdio_container_t,
        pub uid: uv_uid_t,
        pub gid: uv_gid_t,
    }
    #[c2rust::src_loc = "909:1"]
    pub type uv_process_options_t = uv_process_options_s;
    use super::unix_h::{uv__io_t, uv_mutex_t, uv_rwlock_t, uv_buf_t, uv_uid_t,
                        uv_gid_t};
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    use super::stdio_h::ssize_t;
    use super::stdint_intn_h::int64_t;
}
#[c2rust::header_src = "/home/vole/neovim/.deps/usr/include/uv/unix.h:34"]
pub mod unix_h {
    #[c2rust::src_loc = "92:1"]
    pub type uv__io_t = uv__io_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:8"]
    pub struct uv__io_s {
        pub cb: uv__io_cb,
        pub pending_queue: [*mut libc::c_void; 2],
        pub watcher_queue: [*mut libc::c_void; 2],
        pub pevents: libc::c_uint,
        pub events: libc::c_uint,
        pub fd: libc::c_int,
    }
    #[c2rust::src_loc = "89:1"]
    pub type uv__io_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_loop_s, _: *mut uv__io_s,
                                    _: libc::c_uint) -> ()>;
    #[c2rust::src_loc = "136:1"]
    pub type uv_rwlock_t = pthread_rwlock_t;
    #[c2rust::src_loc = "135:1"]
    pub type uv_mutex_t = pthread_mutex_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "121:16"]
    pub struct uv_buf_t {
        pub base: *mut libc::c_char,
        pub len: size_t,
    }
    #[c2rust::src_loc = "126:1"]
    pub type uv_file = libc::c_int;
    #[c2rust::src_loc = "166:1"]
    pub type uv_gid_t = gid_t;
    #[c2rust::src_loc = "167:1"]
    pub type uv_uid_t = uid_t;
    use super::uv_h::uv_loop_s;
    use super::pthreadtypes_h::{pthread_rwlock_t, pthread_mutex_t};
    use super::stddef_h::size_t;
    use super::sys_types_h::{gid_t, uid_t};
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/defs.h:34"]
pub mod event_defs_h {
    #[c2rust::src_loc = "9:1"]
    pub type argv_callback
        =
        Option<unsafe extern "C" fn(_: *mut *mut libc::c_void) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "10:16"]
    pub struct message {
        pub handler: argv_callback,
        pub argv: [*mut libc::c_void; 10],
    }
    #[c2rust::src_loc = "10:1"]
    pub type Event = message;
    #[inline]
    #[c2rust::src_loc = "30:1"]
    pub unsafe extern "C" fn event_create(mut cb: argv_callback,
                                          mut argc: libc::c_int,
                                          mut args: ...) -> Event {
        if argc <= 10 as libc::c_int {
        } else {
            __assert_fail(b"argc <= EVENT_HANDLER_MAX_ARGC\x00" as *const u8
                              as *const libc::c_char,
                          b"../src/nvim/event/defs.h\x00" as *const u8 as
                              *const libc::c_char,
                          32 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 44],
                                                    &[libc::c_char; 44]>(b"Event event_create(argv_callback, int, ...)\x00")).as_ptr());
        }
        let mut event =
            Event{handler: None, argv: [0 as *mut libc::c_void; 10],};
        if argc <= 10 as libc::c_int {
        } else {
            __assert_fail(b"argc <= EVENT_HANDLER_MAX_ARGC\x00" as *const u8
                              as *const libc::c_char,
                          b"../src/nvim/event/defs.h\x00" as *const u8 as
                              *const libc::c_char,
                          34 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 44],
                                                    &[libc::c_char; 44]>(b"Event event_create(argv_callback, int, ...)\x00")).as_ptr());
        }
        event.handler = cb;
        if argc != 0 {
            let mut args_0: ::std::ffi::VaListImpl;
            args_0 = args.clone();
            let mut i = 0 as libc::c_int;
            while i < argc {
                event.argv[i as usize] = args_0.arg::<*mut libc::c_void>();
                i += 1
            }
        }
        return event;
    }
    use super::assert_h::__assert_fail;
    // NVIM_EVENT_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/multiqueue.h:34"]
pub mod multiqueue_h {
    #[c2rust::src_loc = "10:1"]
    pub type MultiQueue = multiqueue;
    extern "C" {
        #[c2rust::src_loc = "10:16"]
        pub type multiqueue;
    }
    // NVIM_EVENT_MULTIQUEUE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/loop.h:34"]
pub mod loop_h {
    #[c2rust::src_loc = "12:1"]
    pub type WatcherPtr = *mut libc::c_void;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct __kl1_WatcherPtr {
        pub data: WatcherPtr,
        pub next: *mut __kl1_WatcherPtr,
    }
    #[c2rust::src_loc = "15:1"]
    pub type kl1_WatcherPtr = __kl1_WatcherPtr;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct kmp_WatcherPtr_t {
        pub cnt: size_t,
        pub n: size_t,
        pub max: size_t,
        pub buf: *mut *mut kl1_WatcherPtr,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct kl_WatcherPtr_t {
        pub head: *mut kl1_WatcherPtr,
        pub tail: *mut kl1_WatcherPtr,
        pub mp: *mut kmp_WatcherPtr_t,
        pub size: size_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "17:16"]
    pub struct loop_0 {
        pub uv: uv_loop_t,
        pub events: *mut MultiQueue,
        pub thread_events: *mut MultiQueue,
        pub fast_events: *mut MultiQueue,
        pub children: *mut kl_WatcherPtr_t,
        pub children_watcher: uv_signal_t,
        pub children_kill_timer: uv_timer_t,
        pub poll_timer: uv_timer_t,
        pub async_0: uv_async_t,
        pub mutex: uv_mutex_t,
        pub recursive: libc::c_int,
    }
    #[c2rust::src_loc = "17:1"]
    pub type Loop = loop_0;
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_init_WatcherPtr() -> *mut kmp_WatcherPtr_t {
        return xcalloc(1 as libc::c_int as size_t,
                       ::std::mem::size_of::<kmp_WatcherPtr_t>() as
                           libc::c_ulong) as *mut kmp_WatcherPtr_t;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_destroy_WatcherPtr(mut mp:
                                                        *mut kmp_WatcherPtr_t) {
        let mut k: size_t = 0;
        k = 0 as libc::c_int as size_t;
        while k < (*mp).n {
            let mut ptr_ =
                &mut *(*mp).buf.offset(k as isize) as *mut *mut kl1_WatcherPtr
                    as *mut *mut libc::c_void;
            xfree(*ptr_);
            *ptr_ = NULL_2 as *mut libc::c_void;
            k = k.wrapping_add(1)
        }
        let mut ptr__0 =
            &mut (*mp).buf as *mut *mut *mut kl1_WatcherPtr as
                *mut *mut libc::c_void;
        xfree(*ptr__0);
        *ptr__0 = NULL_2 as *mut libc::c_void;
        let mut ptr__1 =
            &mut mp as *mut *mut kmp_WatcherPtr_t as *mut *mut libc::c_void;
        xfree(*ptr__1);
        *ptr__1 = NULL_2 as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_alloc_WatcherPtr(mut mp:
                                                      *mut kmp_WatcherPtr_t)
     -> *mut kl1_WatcherPtr {
        (*mp).cnt = (*mp).cnt.wrapping_add(1);
        if (*mp).n == 0 as libc::c_int as libc::c_ulong {
            return xcalloc(1 as libc::c_int as size_t,
                           ::std::mem::size_of::<kl1_WatcherPtr>() as
                               libc::c_ulong) as *mut kl1_WatcherPtr
        }
        (*mp).n = (*mp).n.wrapping_sub(1);
        return *(*mp).buf.offset((*mp).n as isize);
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_free_WatcherPtr(mut mp:
                                                     *mut kmp_WatcherPtr_t,
                                                 mut p: *mut kl1_WatcherPtr) {
        (*mp).cnt = (*mp).cnt.wrapping_sub(1);
        if (*mp).n == (*mp).max {
            (*mp).max =
                if (*mp).max != 0 {
                    ((*mp).max) << 1 as libc::c_int
                } else { 16 as libc::c_int as libc::c_ulong };
            (*mp).buf =
                xrealloc((*mp).buf as *mut libc::c_void,
                         (::std::mem::size_of::<*mut kl1_WatcherPtr>() as
                              libc::c_ulong).wrapping_mul((*mp).max)) as
                    *mut *mut kl1_WatcherPtr
        }
        let fresh1 = (*mp).n;
        (*mp).n = (*mp).n.wrapping_add(1);
        let ref mut fresh2 = *(*mp).buf.offset(fresh1 as isize);
        *fresh2 = p;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_init_WatcherPtr() -> *mut kl_WatcherPtr_t {
        let mut kl =
            xcalloc(1 as libc::c_int as size_t,
                    ::std::mem::size_of::<kl_WatcherPtr_t>() as libc::c_ulong)
                as *mut kl_WatcherPtr_t;
        (*kl).mp = kmp_init_WatcherPtr();
        (*kl).tail = kmp_alloc_WatcherPtr((*kl).mp);
        (*kl).head = (*kl).tail;
        (*(*kl).head).next = 0 as *mut __kl1_WatcherPtr;
        return kl;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_destroy_WatcherPtr(mut kl:
                                                       *mut kl_WatcherPtr_t) {
        let mut p = 0 as *mut kl1_WatcherPtr;
        p = (*kl).head;
        while p != (*kl).tail {
            kmp_free_WatcherPtr((*kl).mp, p);
            p = (*p).next
        }
        kmp_free_WatcherPtr((*kl).mp, p);
        kmp_destroy_WatcherPtr((*kl).mp);
        let mut ptr_ =
            &mut kl as *mut *mut kl_WatcherPtr_t as *mut *mut libc::c_void;
        xfree(*ptr_);
        *ptr_ = NULL_2 as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_push_WatcherPtr(mut kl: *mut kl_WatcherPtr_t,
                                                mut d: WatcherPtr) {
        let mut q = 0 as *mut kl1_WatcherPtr;
        let mut p = kmp_alloc_WatcherPtr((*kl).mp);
        q = (*kl).tail;
        (*p).next = 0 as *mut __kl1_WatcherPtr;
        (*(*kl).tail).next = p;
        (*kl).tail = p;
        (*kl).size = (*kl).size.wrapping_add(1);
        (*q).data = d;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_shift_at_WatcherPtr(mut kl:
                                                        *mut kl_WatcherPtr_t,
                                                    mut n:
                                                        *mut *mut kl1_WatcherPtr)
     -> WatcherPtr {
        if !(**n).next.is_null() {
        } else {
            __assert_fail(b"(*n)->next\x00" as *const u8 as
                              *const libc::c_char,
                          b"../src/nvim/event/loop.h\x00" as *const u8 as
                              *const libc::c_char,
                          15 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 72],
                                                    &[libc::c_char; 72]>(b"WatcherPtr kl_shift_at_WatcherPtr(kl_WatcherPtr_t *, kl1_WatcherPtr **)\x00")).as_ptr());
        }
        let mut p = 0 as *mut kl1_WatcherPtr;
        (*kl).size = (*kl).size.wrapping_sub(1);
        p = *n;
        *n = (**n).next;
        if p == (*kl).head { (*kl).head = *n }
        let mut d = (*p).data;
        kmp_free_WatcherPtr((*kl).mp, p);
        return d;
    }
    use super::stddef_h::{size_t, NULL_2};
    use super::uv_h::{uv_loop_t, uv_signal_t, uv_timer_t, uv_async_t};
    use super::multiqueue_h::MultiQueue;
    use super::unix_h::uv_mutex_t;
    use super::memory_h_generated_h::{xcalloc, xfree, xrealloc};
    use super::assert_h::__assert_fail;
    // NVIM_EVENT_LOOP_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/rbuffer.h:39"]
pub mod rbuffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "77:8"]
    pub struct rbuffer {
        pub full_cb: rbuffer_callback,
        pub nonfull_cb: rbuffer_callback,
        pub data: *mut libc::c_void,
        pub size: size_t,
        pub temp: *mut libc::c_char,
        pub end_ptr: *mut libc::c_char,
        pub read_ptr: *mut libc::c_char,
        pub write_ptr: *mut libc::c_char,
        pub start_ptr: [libc::c_char; 0],
    }
    #[c2rust::src_loc = "75:1"]
    pub type rbuffer_callback
        =
        Option<unsafe extern "C" fn(_: *mut RBuffer, _: *mut libc::c_void)
                   -> ()>;
    #[c2rust::src_loc = "71:1"]
    pub type RBuffer = rbuffer;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "89:1"]
        pub fn rbuffer_size(buf: *mut RBuffer) -> size_t;
    }
    // NVIM_RBUFFER_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/stream.h:39"]
pub mod stream_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:8"]
    pub struct stream {
        pub closed: bool,
        pub did_eof: bool,
        pub uv: C2RustUnnamed_28,
        pub uvstream: *mut uv_stream_t,
        pub uvbuf: uv_buf_t,
        pub buffer: *mut RBuffer,
        pub fd: uv_file,
        pub read_cb: stream_read_cb,
        pub write_cb: stream_write_cb,
        pub cb_data: *mut libc::c_void,
        pub close_cb: stream_close_cb,
        pub internal_close_cb: stream_close_cb,
        pub close_cb_data: *mut libc::c_void,
        pub internal_data: *mut libc::c_void,
        pub fpos: size_t,
        pub curmem: size_t,
        pub maxmem: size_t,
        pub pending_reqs: size_t,
        pub num_bytes: size_t,
        pub events: *mut MultiQueue,
    }
    #[c2rust::src_loc = "30:1"]
    pub type stream_close_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut libc::c_void)
                   -> ()>;
    #[c2rust::src_loc = "12:1"]
    pub type Stream = stream;
    #[c2rust::src_loc = "29:1"]
    pub type stream_write_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut libc::c_void,
                                    _: libc::c_int) -> ()>;
    #[c2rust::src_loc = "20:1"]
    pub type stream_read_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut RBuffer,
                                    _: size_t, _: *mut libc::c_void, _: bool)
                   -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:3"]
    pub union C2RustUnnamed_28 {
        pub pipe: uv_pipe_t,
        pub tcp: uv_tcp_t,
        pub idle: uv_idle_t,
    }
    use super::uv_h::{uv_stream_t, uv_pipe_t, uv_tcp_t, uv_idle_t};
    use super::unix_h::{uv_buf_t, uv_file};
    use super::rbuffer_h::RBuffer;
    use super::stddef_h::size_t;
    use super::multiqueue_h::MultiQueue;
    // NVIM_EVENT_STREAM_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/process.h:39"]
pub mod process_h {
    #[c2rust::src_loc = "8:9"]
    pub type ProcessType = libc::c_uint;
    #[c2rust::src_loc = "10:3"]
    pub const kProcessTypePty: ProcessType = 1;
    #[c2rust::src_loc = "9:3"]
    pub const kProcessTypeUv: ProcessType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "17:8"]
    pub struct process {
        pub type_0: ProcessType,
        pub loop_0: *mut Loop,
        pub data: *mut libc::c_void,
        pub pid: libc::c_int,
        pub status: libc::c_int,
        pub refcount: libc::c_int,
        pub exit_signal: uint8_t,
        pub stopped_time: uint64_t,
        pub cwd: *const libc::c_char,
        pub argv: *mut *mut libc::c_char,
        pub env: *mut *mut libc::c_char,
        pub in_0: Stream,
        pub out: Stream,
        pub err: Stream,
        pub cb: process_exit_cb,
        pub internal_exit_cb: internal_process_cb,
        pub internal_close_cb: internal_process_cb,
        pub closed: bool,
        pub detach: bool,
        pub events: *mut MultiQueue,
    }
    #[c2rust::src_loc = "15:1"]
    pub type internal_process_cb
        =
        Option<unsafe extern "C" fn(_: *mut Process) -> ()>;
    #[c2rust::src_loc = "13:1"]
    pub type Process = process;
    #[c2rust::src_loc = "14:1"]
    pub type process_exit_cb
        =
        Option<unsafe extern "C" fn(_: *mut Process, _: libc::c_int,
                                    _: *mut libc::c_void) -> ()>;
    #[inline]
    #[c2rust::src_loc = "35:1"]
    pub unsafe extern "C" fn process_init(mut loop_0: *mut Loop,
                                          mut type_0: ProcessType,
                                          mut data: *mut libc::c_void)
     -> Process {
        return {
                   let mut init =
                       process{type_0: type_0,
                               loop_0: loop_0,
                               data: data,
                               pid: 0 as libc::c_int,
                               status: -(1 as libc::c_int),
                               refcount: 0 as libc::c_int,
                               exit_signal: 0,
                               stopped_time: 0 as libc::c_int as uint64_t,
                               cwd: NULL_0 as *const libc::c_char,
                               argv: NULL_0 as *mut *mut libc::c_char,
                               env: 0 as *mut *mut libc::c_char,
                               in_0:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_28{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               out:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_28{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               err:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_28{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           process_exit_cb>(NULL_0
                                                                                as
                                                                                libc::intptr_t),
                               internal_exit_cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           internal_process_cb>(NULL_0
                                                                                    as
                                                                                    libc::intptr_t),
                               internal_close_cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           internal_process_cb>(NULL_0
                                                                                    as
                                                                                    libc::intptr_t),
                               closed: false_0 != 0,
                               detach: false_0 != 0,
                               events: NULL_0 as *mut MultiQueue,};
                   init
               };
    }
    #[inline]
    #[c2rust::src_loc = "59:1"]
    pub unsafe extern "C" fn process_is_stopped(mut proc_0: *mut Process)
     -> bool {
        let mut exited = (*proc_0).status >= 0 as libc::c_int;
        return exited as libc::c_int != 0 ||
                   (*proc_0).stopped_time !=
                       0 as libc::c_int as libc::c_ulong;
    }
    use super::loop_h::Loop;
    use super::stdint_uintn_h::{uint8_t, uint64_t};
    use super::stream_h::{Stream, C2RustUnnamed_28, stream_read_cb,
                          stream_write_cb, stream_close_cb};
    use super::multiqueue_h::MultiQueue;
    use super::stddef_h::{NULL_0, size_t};
    use super::uv_h::{uv_stream_t, uv_pipe_t, uv_loop_t, uv_handle_type,
                      uv_close_cb, C2RustUnnamed_23, uv_handle_t, uv_alloc_cb,
                      uv_read_cb, uv_connect_t, uv_shutdown_t,
                      uv_connection_cb, UV_UNKNOWN_HANDLE};
    use super::unix_h::{uv_buf_t, uv_file, uv__io_t, uv__io_cb};
    use super::rbuffer_h::RBuffer;
    use super::stdbool_h::false_0;
    // NVIM_EVENT_PROCESS_H
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h:39"]
pub mod ioctl_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:8"]
    pub struct winsize {
        pub ws_row: libc::c_ushort,
        pub ws_col: libc::c_ushort,
        pub ws_xpixel: libc::c_ushort,
        pub ws_ypixel: libc::c_ushort,
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/pty_process_unix.h:39"]
pub mod pty_process_unix_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "8:16"]
    pub struct pty_process {
        pub process: Process,
        pub term_name: *mut libc::c_char,
        pub width: uint16_t,
        pub height: uint16_t,
        pub winsize: winsize,
        pub tty_fd: libc::c_int,
    }
    #[c2rust::src_loc = "8:1"]
    pub type PtyProcess = pty_process;
    #[inline]
    #[c2rust::src_loc = "16:1"]
    pub unsafe extern "C" fn pty_process_init(mut loop_0: *mut Loop,
                                              mut data: *mut libc::c_void)
     -> PtyProcess {
        let mut rv =
            PtyProcess{process:
                           Process{type_0: kProcessTypeUv,
                                   loop_0: 0 as *mut Loop,
                                   data: 0 as *mut libc::c_void,
                                   pid: 0,
                                   status: 0,
                                   refcount: 0,
                                   exit_signal: 0,
                                   stopped_time: 0,
                                   cwd: 0 as *const libc::c_char,
                                   argv: 0 as *mut *mut libc::c_char,
                                   env: 0 as *mut *mut libc::c_char,
                                   in_0:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_28{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   out:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_28{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   err:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_28{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   cb: None,
                                   internal_exit_cb: None,
                                   internal_close_cb: None,
                                   closed: false,
                                   detach: false,
                                   events: 0 as *mut MultiQueue,},
                       term_name: 0 as *mut libc::c_char,
                       width: 0,
                       height: 0,
                       winsize:
                           winsize{ws_row: 0,
                                   ws_col: 0,
                                   ws_xpixel: 0,
                                   ws_ypixel: 0,},
                       tty_fd: 0,};
        rv.process = process_init(loop_0, kProcessTypePty, data);
        rv.term_name = NULL_0 as *mut libc::c_char;
        rv.width = 80 as libc::c_int as uint16_t;
        rv.height = 24 as libc::c_int as uint16_t;
        rv.tty_fd = -(1 as libc::c_int);
        return rv;
    }
    use super::process_h::{Process, ProcessType, process_exit_cb,
                           internal_process_cb, process_init,
                           kProcessTypePty};
    use super::stdint_uintn_h::{uint16_t, uint8_t, uint64_t};
    use super::ioctl_types_h::winsize;
    use super::loop_h::Loop;
    use super::stream_h::{Stream, C2RustUnnamed_28, stream_read_cb,
                          stream_write_cb, stream_close_cb};
    use super::multiqueue_h::MultiQueue;
    use super::uv_h::uv_stream_t;
    use super::unix_h::{uv_buf_t, uv_file};
    use super::rbuffer_h::RBuffer;
    use super::stddef_h::{size_t, NULL_0};
    // NVIM_OS_PTY_PROCESS_UNIX_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/libuv_process.h:39"]
pub mod libuv_process_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "8:16"]
    pub struct libuv_process {
        pub process: Process,
        pub uv: uv_process_t,
        pub uvopts: uv_process_options_t,
        pub uvstdio: [uv_stdio_container_t; 3],
    }
    #[c2rust::src_loc = "8:1"]
    pub type LibuvProcess = libuv_process;
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn libuv_process_init(mut loop_0: *mut Loop,
                                                mut data: *mut libc::c_void)
     -> LibuvProcess {
        let mut rv =
            {
                let mut init =
                    libuv_process{process:
                                      process_init(loop_0, kProcessTypeUv,
                                                   data),
                                  uv:
                                      uv_process_t{data:
                                                       0 as *mut libc::c_void,
                                                   loop_0:
                                                       0 as *mut uv_loop_t,
                                                   type_0: UV_UNKNOWN_HANDLE,
                                                   close_cb: None,
                                                   handle_queue:
                                                       [0 as
                                                            *mut libc::c_void;
                                                           2],
                                                   u:
                                                       C2RustUnnamed_26{fd:
                                                                            0,},
                                                   next_closing:
                                                       0 as *mut uv_handle_t,
                                                   flags: 0,
                                                   exit_cb: None,
                                                   pid: 0,
                                                   queue:
                                                       [0 as
                                                            *mut libc::c_void;
                                                           2],
                                                   status: 0,},
                                  uvopts:
                                      uv_process_options_t{exit_cb: None,
                                                           file:
                                                               0 as
                                                                   *const libc::c_char,
                                                           args:
                                                               0 as
                                                                   *mut *mut libc::c_char,
                                                           env:
                                                               0 as
                                                                   *mut *mut libc::c_char,
                                                           cwd:
                                                               0 as
                                                                   *const libc::c_char,
                                                           flags: 0,
                                                           stdio_count: 0,
                                                           stdio:
                                                               0 as
                                                                   *mut uv_stdio_container_t,
                                                           uid: 0,
                                                           gid: 0,},
                                  uvstdio:
                                      [uv_stdio_container_t{flags: UV_IGNORE,
                                                            data:
                                                                C2RustUnnamed_27{stream:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_stream_t,},};
                                          3],};
                init
            };
        return rv;
    }
    use super::process_h::{Process, process_init, kProcessTypeUv,
                           ProcessType};
    use super::uv_h::{uv_process_t, uv_process_options_t,
                      uv_stdio_container_t, uv_loop_t, uv_handle_type,
                      uv_close_cb, C2RustUnnamed_26, uv_handle_t, uv_exit_cb,
                      uv_stdio_flags, C2RustUnnamed_27, UV_IGNORE,
                      uv_stream_t};
    use super::loop_h::Loop;
    use super::unix_h::{uv_uid_t, uv_gid_t};
    // NVIM_EVENT_LIBUV_PROCESS_H
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/zone.h:39"]
pub mod zone_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:16"]
    pub struct msgpack_zone_finalizer {
        pub func: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
        pub data: *mut libc::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "31:16"]
    pub struct msgpack_zone_finalizer_array {
        pub tail: *mut msgpack_zone_finalizer,
        pub end: *mut msgpack_zone_finalizer,
        pub array: *mut msgpack_zone_finalizer,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:16"]
    pub struct msgpack_zone_chunk_list {
        pub free: size_t,
        pub ptr: *mut libc::c_char,
        pub head: *mut msgpack_zone_chunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:16"]
    pub struct msgpack_zone {
        pub chunk_list: msgpack_zone_chunk_list,
        pub finalizer_array: msgpack_zone_finalizer_array,
        pub chunk_size: size_t,
    }
    #[inline]
    #[c2rust::src_loc = "106:1"]
    pub unsafe extern "C" fn msgpack_zone_malloc(mut zone: *mut msgpack_zone,
                                                 mut size: size_t)
     -> *mut libc::c_void {
        let mut aligned =
            ((*zone).chunk_list.ptr.offset(MSGPACK_ZONE_ALIGN.wrapping_sub(1
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_ulong)
                                               as isize) as
                 size_t).wrapping_div(MSGPACK_ZONE_ALIGN).wrapping_mul(MSGPACK_ZONE_ALIGN)
                as *mut libc::c_char;
        let mut adjusted_size =
            size.wrapping_add(aligned.wrapping_offset_from((*zone).chunk_list.ptr)
                                  as libc::c_long as libc::c_ulong);
        if (*zone).chunk_list.free >= adjusted_size {
            (*zone).chunk_list.free =
                ((*zone).chunk_list.free as
                     libc::c_ulong).wrapping_sub(adjusted_size) as size_t as
                    size_t;
            (*zone).chunk_list.ptr =
                (*zone).chunk_list.ptr.offset(adjusted_size as isize);
            return aligned as *mut libc::c_void
        }
        let mut ptr =
            msgpack_zone_malloc_expand(zone,
                                       size.wrapping_add(MSGPACK_ZONE_ALIGN.wrapping_sub(1
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_ulong)));
        if !ptr.is_null() {
            return (ptr as
                        size_t).wrapping_div(MSGPACK_ZONE_ALIGN).wrapping_mul(MSGPACK_ZONE_ALIGN)
                       as *mut libc::c_char as *mut libc::c_void
        }
        return NULL_0 as *mut libc::c_void;
    }
    #[c2rust::src_loc = "84:9"]
    pub const MSGPACK_ZONE_ALIGN: libc::c_ulong =
        ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong;
    #[inline]
    #[c2rust::src_loc = "90:1"]
    pub unsafe extern "C" fn msgpack_zone_malloc_no_align(mut zone:
                                                              *mut msgpack_zone,
                                                          mut size: size_t)
     -> *mut libc::c_void {
        let mut ptr = 0 as *mut libc::c_char;
        let mut cl: *mut msgpack_zone_chunk_list = &mut (*zone).chunk_list;
        if (*zone).chunk_list.free < size {
            return msgpack_zone_malloc_expand(zone, size)
        }
        ptr = (*cl).ptr;
        (*cl).free =
            ((*cl).free as libc::c_ulong).wrapping_sub(size) as size_t as
                size_t;
        (*cl).ptr = (*cl).ptr.offset(size as isize);
        return ptr as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "133:1"]
    pub unsafe extern "C" fn msgpack_zone_push_finalizer(mut zone:
                                                             *mut msgpack_zone,
                                                         mut func:
                                                             Option<unsafe extern "C" fn(_:
                                                                                             *mut libc::c_void)
                                                                        ->
                                                                            ()>,
                                                         mut data:
                                                             *mut libc::c_void)
     -> bool {
        let fa: *mut msgpack_zone_finalizer_array =
            &mut (*zone).finalizer_array;
        let mut fin = (*fa).tail;
        if fin == (*fa).end {
            return msgpack_zone_push_finalizer_expand(zone, func, data)
        }
        (*fin).func = func;
        (*fin).data = data;
        (*fa).tail = (*fa).tail.offset(1);
        return true_0 != 0;
    }
    #[inline]
    #[c2rust::src_loc = "151:1"]
    pub unsafe extern "C" fn msgpack_zone_swap(mut a: *mut msgpack_zone,
                                               mut b: *mut msgpack_zone) {
        let mut tmp = *a;
        *a = *b;
        *b = tmp;
    }
    use super::stddef_h::{size_t, NULL_0};
    use super::stdbool_h::true_0;
    extern "C" {
        #[c2rust::src_loc = "37:8"]
        pub type msgpack_zone_chunk;
        #[no_mangle]
        #[c2rust::src_loc = "64:1"]
        pub fn msgpack_zone_free(zone: *mut msgpack_zone);
        #[no_mangle]
        #[c2rust::src_loc = "88:1"]
        pub fn msgpack_zone_malloc_expand(zone: *mut msgpack_zone,
                                          size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "130:1"]
        pub fn msgpack_zone_push_finalizer_expand(zone: *mut msgpack_zone,
                                                  func:
                                                      Option<unsafe extern "C" fn(_:
                                                                                      *mut libc::c_void)
                                                                 -> ()>,
                                                  data: *mut libc::c_void)
         -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/object.h:39"]
pub mod object_h {
    #[c2rust::src_loc = "27:9"]
    pub type msgpack_object_type = libc::c_uint;
    #[c2rust::src_loc = "42:5"]
    pub const MSGPACK_OBJECT_EXT: msgpack_object_type = 9;
    #[c2rust::src_loc = "41:5"]
    pub const MSGPACK_OBJECT_BIN: msgpack_object_type = 8;
    #[c2rust::src_loc = "40:5"]
    pub const MSGPACK_OBJECT_MAP: msgpack_object_type = 7;
    #[c2rust::src_loc = "39:5"]
    pub const MSGPACK_OBJECT_ARRAY: msgpack_object_type = 6;
    #[c2rust::src_loc = "38:5"]
    pub const MSGPACK_OBJECT_STR: msgpack_object_type = 5;
    #[c2rust::src_loc = "34:5"]
    pub const MSGPACK_OBJECT_FLOAT: msgpack_object_type = 4;
    #[c2rust::src_loc = "33:5"]
    pub const MSGPACK_OBJECT_FLOAT64: msgpack_object_type = 4;
    #[c2rust::src_loc = "32:5"]
    pub const MSGPACK_OBJECT_FLOAT32: msgpack_object_type = 10;
    #[c2rust::src_loc = "31:5"]
    pub const MSGPACK_OBJECT_NEGATIVE_INTEGER: msgpack_object_type = 3;
    #[c2rust::src_loc = "30:5"]
    pub const MSGPACK_OBJECT_POSITIVE_INTEGER: msgpack_object_type = 2;
    #[c2rust::src_loc = "29:5"]
    pub const MSGPACK_OBJECT_BOOLEAN: msgpack_object_type = 1;
    #[c2rust::src_loc = "28:5"]
    pub const MSGPACK_OBJECT_NIL: msgpack_object_type = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "90:16"]
    pub struct msgpack_object {
        pub type_0: msgpack_object_type,
        pub via: msgpack_object_union,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "75:9"]
    pub union msgpack_object_union {
        pub boolean: bool,
        pub u64_0: uint64_t,
        pub i64_0: int64_t,
        pub f64_0: libc::c_double,
        pub array: msgpack_object_array,
        pub map: msgpack_object_map,
        pub str_0: msgpack_object_str,
        pub bin: msgpack_object_bin,
        pub ext: msgpack_object_ext,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "69:9"]
    pub struct msgpack_object_ext {
        pub type_0: int8_t,
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "64:9"]
    pub struct msgpack_object_bin {
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "59:9"]
    pub struct msgpack_object_str {
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "54:9"]
    pub struct msgpack_object_map {
        pub size: uint32_t,
        pub ptr: *mut msgpack_object_kv,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "95:16"]
    pub struct msgpack_object_kv {
        pub key: msgpack_object,
        pub val: msgpack_object,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "49:9"]
    pub struct msgpack_object_array {
        pub size: uint32_t,
        pub ptr: *mut msgpack_object,
    }
    use super::stdint_uintn_h::{uint64_t, uint32_t};
    use super::stdint_intn_h::{int64_t, int8_t};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/pack.h:39"]
pub mod pack_h {
    #[c2rust::src_loc = "35:1"]
    pub type msgpack_packer_write
        =
        Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                    _: *const libc::c_char, _: size_t)
                   -> libc::c_int>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:16"]
    pub struct msgpack_packer {
        pub data: *mut libc::c_void,
        pub callback: msgpack_packer_write,
    }
    #[inline]
    #[c2rust::src_loc = "124:1"]
    pub unsafe extern "C" fn msgpack_packer_init(mut pk: *mut msgpack_packer,
                                                 mut data: *mut libc::c_void,
                                                 mut callback:
                                                     msgpack_packer_write) {
        (*pk).data = data;
        (*pk).callback = callback;
    }
    #[inline]
    #[c2rust::src_loc = "130:1"]
    pub unsafe extern "C" fn msgpack_packer_new(mut data: *mut libc::c_void,
                                                mut callback:
                                                    msgpack_packer_write)
     -> *mut msgpack_packer {
        let mut pk =
            calloc(1 as libc::c_int as libc::c_ulong,
                   ::std::mem::size_of::<msgpack_packer>() as libc::c_ulong)
                as *mut msgpack_packer;
        if pk.is_null() { return NULL_0 as *mut msgpack_packer }
        msgpack_packer_init(pk, data, callback);
        return pk;
    }
    #[inline]
    #[c2rust::src_loc = "138:1"]
    pub unsafe extern "C" fn msgpack_packer_free(mut pk:
                                                     *mut msgpack_packer) {
        free(pk as *mut libc::c_void);
    }
    use super::stddef_h::{size_t, NULL_0};
    use super::stdlib_h::{calloc, free};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/pack_template.h:39"]
pub mod pack_template_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "654:5"]
    pub union C2RustUnnamed_29 {
        pub f: libc::c_float,
        pub i: uint32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "663:5"]
    pub union C2RustUnnamed_30 {
        pub f: libc::c_double,
        pub i: uint64_t,
    }
    #[inline]
    #[c2rust::src_loc = "369:1"]
    pub unsafe extern "C" fn msgpack_pack_char(mut x: *mut msgpack_packer,
                                               mut d: libc::c_char)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_char as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_char
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "382:1"]
    pub unsafe extern "C" fn msgpack_pack_signed_char(mut x:
                                                          *mut msgpack_packer,
                                                      mut d: libc::c_schar)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_schar as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_schar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "394:1"]
    pub unsafe extern "C" fn msgpack_pack_short(mut x: *mut msgpack_packer,
                                                mut d: libc::c_short)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            if (d as libc::c_int) < -((1 as libc::c_int) << 7 as libc::c_int)
               {
                let mut buf: [libc::c_uchar; 3] = [0; 3];
                buf[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val = ntohs(d as uint16_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_0: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_short as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_short
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf_1: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_short as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 3] = [0; 3];
            buf_2[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohs(d as uint16_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "425:1"]
    pub unsafe extern "C" fn msgpack_pack_int(mut x: *mut msgpack_packer,
                                              mut d: libc::c_int)
     -> libc::c_int {
        if d < -((1 as libc::c_int) << 5 as libc::c_int) {
            if d < -((1 as libc::c_int) << 15 as libc::c_int) {
                let mut buf: [libc::c_uchar; 5] = [0; 5];
                buf[0 as libc::c_int as usize] =
                    0xd2 as libc::c_int as libc::c_uchar;
                let mut val = ntohl(d as uint32_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint32_t as *const libc::c_void,
                       4 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   5
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else if d < -((1 as libc::c_int) << 7 as libc::c_int) {
                let mut buf_0: [libc::c_uchar; 3] = [0; 3];
                buf_0[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_0 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_0 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_1: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_int as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_int
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 8 as libc::c_int {
            let mut buf_2: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_int as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 16 as libc::c_int {
            let mut buf_3: [libc::c_uchar; 3] = [0; 3];
            buf_3[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_1 = ntohs(d as uint16_t);
            memcpy(&mut *buf_3.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_3.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_4: [libc::c_uchar; 5] = [0; 5];
            buf_4[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_2 = ntohl(d as uint32_t);
            memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_2 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_4.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "456:1"]
    pub unsafe extern "C" fn msgpack_pack_long(mut x: *mut msgpack_packer,
                                               mut d: libc::c_long)
     -> libc::c_int {
        if (d as libc::c_longlong) <
               -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if (d as libc::c_longlong) <
                   -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if (d as libc::c_longlong) <
                       -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_long {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_long as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_long
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_long
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 16 as libc::c_int {
            if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_long {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_long as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn msgpack_pack_long_long(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: libc::c_longlong)
     -> libc::c_int {
        if d < -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if d < -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if d < -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_longlong {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_longlong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 7 as libc::c_int) as
                          libc::c_longlong {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_longlong
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_longlong) << 16 as libc::c_int {
            if d <
                   ((1 as libc::c_int) << 8 as libc::c_int) as
                       libc::c_longlong {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_longlong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "387:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_char(mut x:
                                                            *mut msgpack_packer,
                                                        mut d: libc::c_uchar)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_uchar as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "518:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_short(mut x:
                                                             *mut msgpack_packer,
                                                         mut d:
                                                             libc::c_ushort)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_ushort
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_ushort as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "549:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_int(mut x:
                                                           *mut msgpack_packer,
                                                       mut d: libc::c_uint)
     -> libc::c_int {
        if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint {
            if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_uint
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_uint as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 16 as libc::c_int) as
                          libc::c_uint {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "580:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_long(mut x:
                                                            *mut msgpack_packer,
                                                        mut d: libc::c_ulong)
     -> libc::c_int {
        if (d as libc::c_ulonglong) <
               (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if (d as libc::c_ulonglong) <
                   (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_ulong
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_ulong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "611:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_long_long(mut x:
                                                                 *mut msgpack_packer,
                                                             mut d:
                                                                 libc::c_ulonglong)
     -> libc::c_int {
        if d < (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if d < (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_ulonglong
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_ulonglong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "329:1"]
    pub unsafe extern "C" fn msgpack_pack_uint8(mut x: *mut msgpack_packer,
                                                mut d: uint8_t)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "334:1"]
    pub unsafe extern "C" fn msgpack_pack_uint16(mut x: *mut msgpack_packer,
                                                 mut d: uint16_t)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut uint16_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut uint16_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "339:1"]
    pub unsafe extern "C" fn msgpack_pack_uint32(mut x: *mut msgpack_packer,
                                                 mut d: uint32_t)
     -> libc::c_int {
        if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint {
            if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut uint32_t
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut uint32_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 16 as libc::c_int) as
                          libc::c_uint {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "344:1"]
    pub unsafe extern "C" fn msgpack_pack_uint64(mut x: *mut msgpack_packer,
                                                 mut d: uint64_t)
     -> libc::c_int {
        if (d as libc::c_ulonglong) <
               (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if (d as libc::c_ulonglong) <
                   (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut uint64_t
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut uint64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "349:1"]
    pub unsafe extern "C" fn msgpack_pack_int8(mut x: *mut msgpack_packer,
                                               mut d: int8_t) -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int8_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int8_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "354:1"]
    pub unsafe extern "C" fn msgpack_pack_int16(mut x: *mut msgpack_packer,
                                                mut d: int16_t)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            if (d as libc::c_int) < -((1 as libc::c_int) << 7 as libc::c_int)
               {
                let mut buf: [libc::c_uchar; 3] = [0; 3];
                buf[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val = ntohs(d as uint16_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_0: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int16_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int16_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf_1: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int16_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 3] = [0; 3];
            buf_2[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohs(d as uint16_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "359:1"]
    pub unsafe extern "C" fn msgpack_pack_int32(mut x: *mut msgpack_packer,
                                                mut d: int32_t)
     -> libc::c_int {
        if d < -((1 as libc::c_int) << 5 as libc::c_int) {
            if d < -((1 as libc::c_int) << 15 as libc::c_int) {
                let mut buf: [libc::c_uchar; 5] = [0; 5];
                buf[0 as libc::c_int as usize] =
                    0xd2 as libc::c_int as libc::c_uchar;
                let mut val = ntohl(d as uint32_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint32_t as *const libc::c_void,
                       4 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   5
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else if d < -((1 as libc::c_int) << 7 as libc::c_int) {
                let mut buf_0: [libc::c_uchar; 3] = [0; 3];
                buf_0[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_0 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_0 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_1: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int32_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int32_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 8 as libc::c_int {
            let mut buf_2: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int32_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 16 as libc::c_int {
            let mut buf_3: [libc::c_uchar; 3] = [0; 3];
            buf_3[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_1 = ntohs(d as uint16_t);
            memcpy(&mut *buf_3.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_3.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_4: [libc::c_uchar; 5] = [0; 5];
            buf_4[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_2 = ntohl(d as uint32_t);
            memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_2 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_4.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "364:1"]
    pub unsafe extern "C" fn msgpack_pack_int64(mut x: *mut msgpack_packer,
                                                mut d: int64_t)
     -> libc::c_int {
        if (d as libc::c_longlong) <
               -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if (d as libc::c_longlong) <
                   -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if (d as libc::c_longlong) <
                       -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_long {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_long
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int64_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 16 as libc::c_int {
            if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_long {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "271:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint8(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: uint8_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 2] =
            [0xcc as libc::c_int as libc::c_uchar,
             *(&mut d as *mut uint8_t).offset(0 as libc::c_int as isize)];
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           2
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "277:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint16(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint16_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 3] = [0; 3];
        buf[0 as libc::c_int as usize] = 0xcd as libc::c_int as libc::c_uchar;
        let mut val = ntohs(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint16_t as *const libc::c_void,
               2 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           3
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "284:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint32(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint32_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        buf[0 as libc::c_int as usize] = 0xce as libc::c_int as libc::c_uchar;
        let mut val = ntohl(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "291:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint64(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint64_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        buf[0 as libc::c_int as usize] = 0xcf as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "298:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int8(mut x: *mut msgpack_packer,
                                                   mut d: int8_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 2] =
            [0xd0 as libc::c_int as libc::c_uchar,
             *(&mut d as *mut int8_t as
                   *mut uint8_t).offset(0 as libc::c_int as isize)];
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           2
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "304:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int16(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int16_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 3] = [0; 3];
        buf[0 as libc::c_int as usize] = 0xd1 as libc::c_int as libc::c_uchar;
        let mut val = ntohs(d as uint16_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint16_t as *const libc::c_void,
               2 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           3
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "311:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int32(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int32_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        buf[0 as libc::c_int as usize] = 0xd2 as libc::c_int as libc::c_uchar;
        let mut val = ntohl(d as uint32_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "318:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int64(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int64_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        buf[0 as libc::c_int as usize] = 0xd3 as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(d as __uint64_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "651:1"]
    pub unsafe extern "C" fn msgpack_pack_float(mut x: *mut msgpack_packer,
                                                mut d: libc::c_float)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        let mut mem = C2RustUnnamed_29{f: 0.,};
        mem.f = d;
        buf[0 as libc::c_int as usize] = 0xca as libc::c_int as libc::c_uchar;
        let mut val = ntohl(mem.i);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "660:1"]
    pub unsafe extern "C" fn msgpack_pack_double(mut x: *mut msgpack_packer,
                                                 mut d: libc::c_double)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        let mut mem = C2RustUnnamed_30{f: 0.,};
        mem.f = d;
        buf[0 as libc::c_int as usize] = 0xcb as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(mem.i);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "681:1"]
    pub unsafe extern "C" fn msgpack_pack_nil(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc0 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "692:1"]
    pub unsafe extern "C" fn msgpack_pack_true(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc3 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "698:1"]
    pub unsafe extern "C" fn msgpack_pack_false(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc2 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "709:1"]
    pub unsafe extern "C" fn msgpack_pack_array(mut x: *mut msgpack_packer,
                                                mut n: size_t)
     -> libc::c_int {
        if n < 16 as libc::c_int as libc::c_ulong {
            let mut d =
                (0x90 as libc::c_int | n as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut d
                                                                                                                   as
                                                                                                                   *mut libc::c_uchar
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if n < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xdc as libc::c_int as libc::c_uchar;
            let mut val = ntohs(n as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(n as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "730:1"]
    pub unsafe extern "C" fn msgpack_pack_map(mut x: *mut msgpack_packer,
                                              mut n: size_t) -> libc::c_int {
        if n < 16 as libc::c_int as libc::c_ulong {
            let mut d =
                (0x80 as libc::c_int | n as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if n < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xde as libc::c_int as libc::c_uchar;
            let mut val = ntohs(n as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdf as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(n as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "751:1"]
    pub unsafe extern "C" fn msgpack_pack_str(mut x: *mut msgpack_packer,
                                              mut l: size_t) -> libc::c_int {
        if l < 32 as libc::c_int as libc::c_ulong {
            let mut d =
                (0xa0 as libc::c_int | l as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 256 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 2] = [0; 2];
            buf[0 as libc::c_int as usize] =
                0xd9 as libc::c_int as libc::c_uchar;
            buf[1 as libc::c_int as usize] = l as uint8_t;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xda as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xdb as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "771:1"]
    pub unsafe extern "C" fn msgpack_pack_str_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "780:1"]
    pub unsafe extern "C" fn msgpack_pack_v4raw(mut x: *mut msgpack_packer,
                                                mut l: size_t)
     -> libc::c_int {
        if l < 32 as libc::c_int as libc::c_ulong {
            let mut d =
                (0xa0 as libc::c_int | l as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xda as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdb as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "796:1"]
    pub unsafe extern "C" fn msgpack_pack_v4raw_body(mut x:
                                                         *mut msgpack_packer,
                                                     mut b:
                                                         *const libc::c_void,
                                                     mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "805:1"]
    pub unsafe extern "C" fn msgpack_pack_bin(mut x: *mut msgpack_packer,
                                              mut l: size_t) -> libc::c_int {
        if l < 256 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 2] = [0; 2];
            buf[0 as libc::c_int as usize] =
                0xc4 as libc::c_int as libc::c_uchar;
            buf[1 as libc::c_int as usize] = l as uint8_t;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xc5 as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xc6 as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "822:1"]
    pub unsafe extern "C" fn msgpack_pack_bin_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "831:1"]
    pub unsafe extern "C" fn msgpack_pack_ext(mut x: *mut msgpack_packer,
                                              mut l: size_t,
                                              mut type_0: int8_t)
     -> libc::c_int {
        match l {
            1 => {
                let mut buf: [libc::c_uchar; 2] = [0; 2];
                buf[0 as libc::c_int as usize] =
                    0xd4 as libc::c_int as libc::c_uchar;
                buf[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            2 => {
                let mut buf_0: [libc::c_uchar; 2] = [0; 2];
                buf_0[0 as libc::c_int as usize] =
                    0xd5 as libc::c_int as libc::c_uchar;
                buf_0[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            4 => {
                let mut buf_1: [libc::c_uchar; 2] = [0; 2];
                buf_1[0 as libc::c_int as usize] =
                    0xd6 as libc::c_int as libc::c_uchar;
                buf_1[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            8 => {
                let mut buf_2: [libc::c_uchar; 2] = [0; 2];
                buf_2[0 as libc::c_int as usize] =
                    0xd7 as libc::c_int as libc::c_uchar;
                buf_2[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            16 => {
                let mut buf_3: [libc::c_uchar; 2] = [0; 2];
                buf_3[0 as libc::c_int as usize] =
                    0xd8 as libc::c_int as libc::c_uchar;
                buf_3[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            _ => {
                if l < 256 as libc::c_int as libc::c_ulong {
                    let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                    buf_4[0 as libc::c_int as usize] =
                        0xc7 as libc::c_int as libc::c_uchar;
                    buf_4[1 as libc::c_int as usize] = l as libc::c_uchar;
                    buf_4[2 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_4.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       3
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else if l < 65536 as libc::c_int as libc::c_ulong {
                    let mut buf_5: [libc::c_uchar; 4] = [0; 4];
                    buf_5[0 as libc::c_int as usize] =
                        0xc8 as libc::c_int as libc::c_uchar;
                    let mut val = ntohs(l as uint16_t);
                    memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint16_t as *const libc::c_void,
                           2 as libc::c_int as libc::c_ulong);
                    buf_5[3 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_5.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       4
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_6: [libc::c_uchar; 6] = [0; 6];
                    buf_6[0 as libc::c_int as usize] =
                        0xc9 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(l as uint32_t);
                    memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    buf_6[5 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_6.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       6
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            }
        };
    }
    #[inline]
    #[c2rust::src_loc = "888:1"]
    pub unsafe extern "C" fn msgpack_pack_ext_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    use super::stdint_uintn_h::{uint32_t, uint64_t, uint8_t, uint16_t};
    use super::pack_h::msgpack_packer;
    use super::stddef_h::size_t;
    use super::in_h::{ntohs, ntohl};
    use super::stdint_intn_h::{int16_t, int32_t, int8_t, int64_t};
    use super::string_h::memcpy;
    use super::byteswap_h::__bswap_64;
    use super::types_h::__uint64_t;
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/unpack.h:39"]
pub mod unpack_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "28:16"]
    pub struct msgpack_unpacked {
        pub zone: *mut msgpack_zone,
        pub data: msgpack_object,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:16"]
    pub struct msgpack_unpacker {
        pub buffer: *mut libc::c_char,
        pub used: size_t,
        pub free: size_t,
        pub off: size_t,
        pub parsed: size_t,
        pub z: *mut msgpack_zone,
        pub initial_buffer_size: size_t,
        pub ctx: *mut libc::c_void,
    }
    #[inline]
    #[c2rust::src_loc = "219:1"]
    pub unsafe extern "C" fn msgpack_unpacker_reserve_buffer(mut mpac:
                                                                 *mut msgpack_unpacker,
                                                             mut size: size_t)
     -> bool {
        if (*mpac).free >= size { return true_0 != 0 }
        return msgpack_unpacker_expand_buffer(mpac, size);
    }
    #[inline]
    #[c2rust::src_loc = "225:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer(mut mpac:
                                                         *mut msgpack_unpacker)
     -> *mut libc::c_char {
        return (*mpac).buffer.offset((*mpac).used as isize);
    }
    #[inline]
    #[c2rust::src_loc = "230:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer_capacity(mut mpac:
                                                                  *const msgpack_unpacker)
     -> size_t {
        return (*mpac).free;
    }
    #[inline]
    #[c2rust::src_loc = "235:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer_consumed(mut mpac:
                                                                  *mut msgpack_unpacker,
                                                              mut size:
                                                                  size_t) {
        (*mpac).used =
            ((*mpac).used as libc::c_ulong).wrapping_add(size) as size_t as
                size_t;
        (*mpac).free =
            ((*mpac).free as libc::c_ulong).wrapping_sub(size) as size_t as
                size_t;
    }
    #[inline]
    #[c2rust::src_loc = "252:1"]
    pub unsafe extern "C" fn msgpack_unpacked_init(mut result:
                                                       *mut msgpack_unpacked) {
        memset(result as *mut libc::c_void, 0 as libc::c_int,
               ::std::mem::size_of::<msgpack_unpacked>() as libc::c_ulong);
    }
    #[inline]
    #[c2rust::src_loc = "257:1"]
    pub unsafe extern "C" fn msgpack_unpacked_destroy(mut result:
                                                          *mut msgpack_unpacked) {
        if !(*result).zone.is_null() {
            msgpack_zone_free((*result).zone);
            (*result).zone = NULL_0 as *mut msgpack_zone;
            memset(&mut (*result).data as *mut msgpack_object as
                       *mut libc::c_void, 0 as libc::c_int,
                   ::std::mem::size_of::<msgpack_object>() as libc::c_ulong);
        };
    }
    #[inline]
    #[c2rust::src_loc = "266:1"]
    pub unsafe extern "C" fn msgpack_unpacked_release_zone(mut result:
                                                               *mut msgpack_unpacked)
     -> *mut msgpack_zone {
        if !(*result).zone.is_null() {
            let mut z = (*result).zone;
            (*result).zone = NULL_0 as *mut msgpack_zone;
            return z
        }
        return NULL_0 as *mut msgpack_zone;
    }
    #[inline]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn msgpack_unpacker_message_size(mut mpac:
                                                               *const msgpack_unpacker)
     -> size_t {
        return (*mpac).parsed.wrapping_sub((*mpac).off).wrapping_add((*mpac).used);
    }
    #[inline]
    #[c2rust::src_loc = "246:1"]
    pub unsafe extern "C" fn msgpack_unpacker_parsed_size(mut mpac:
                                                              *const msgpack_unpacker)
     -> size_t {
        return (*mpac).parsed;
    }
    use super::zone_h::{msgpack_zone, msgpack_zone_free};
    use super::object_h::msgpack_object;
    use super::stddef_h::{size_t, NULL_0};
    use super::stdbool_h::true_0;
    use super::string_h::memset;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "217:1"]
        pub fn msgpack_unpacker_expand_buffer(mpac: *mut msgpack_unpacker,
                                              size: size_t) -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/sbuffer.h:39"]
pub mod sbuffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:16"]
    pub struct msgpack_sbuffer {
        pub size: size_t,
        pub data: *mut libc::c_char,
        pub alloc: size_t,
    }
    #[inline]
    #[c2rust::src_loc = "33:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_init(mut sbuf:
                                                      *mut msgpack_sbuffer) {
        memset(sbuf as *mut libc::c_void, 0 as libc::c_int,
               ::std::mem::size_of::<msgpack_sbuffer>() as libc::c_ulong);
    }
    #[inline]
    #[c2rust::src_loc = "38:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_destroy(mut sbuf:
                                                         *mut msgpack_sbuffer) {
        free((*sbuf).data as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "43:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_new() -> *mut msgpack_sbuffer {
        return calloc(1 as libc::c_int as libc::c_ulong,
                      ::std::mem::size_of::<msgpack_sbuffer>() as
                          libc::c_ulong) as *mut msgpack_sbuffer;
    }
    #[inline]
    #[c2rust::src_loc = "48:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_free(mut sbuf:
                                                      *mut msgpack_sbuffer) {
        if sbuf.is_null() { return }
        msgpack_sbuffer_destroy(sbuf);
        free(sbuf as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "59:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_write(mut data:
                                                       *mut libc::c_void,
                                                   mut buf:
                                                       *const libc::c_char,
                                                   mut len: size_t)
     -> libc::c_int {
        let mut sbuf = data as *mut msgpack_sbuffer;
        if (*sbuf).alloc.wrapping_sub((*sbuf).size) < len {
            let mut tmp = 0 as *mut libc::c_void;
            let mut nsize =
                if (*sbuf).alloc != 0 {
                    (*sbuf).alloc.wrapping_mul(2 as libc::c_int as
                                                   libc::c_ulong)
                } else { MSGPACK_SBUFFER_INIT_SIZE as libc::c_ulong };
            while nsize < (*sbuf).size.wrapping_add(len) {
                let mut tmp_nsize =
                    nsize.wrapping_mul(2 as libc::c_int as libc::c_ulong);
                if tmp_nsize <= nsize {
                    nsize = (*sbuf).size.wrapping_add(len);
                    break ;
                } else { nsize = tmp_nsize }
            }
            tmp = realloc((*sbuf).data as *mut libc::c_void, nsize);
            if tmp.is_null() { return -(1 as libc::c_int) }
            (*sbuf).data = tmp as *mut libc::c_char;
            (*sbuf).alloc = nsize
        }
        memcpy((*sbuf).data.offset((*sbuf).size as isize) as
                   *mut libc::c_void, buf as *const libc::c_void, len);
        (*sbuf).size =
            ((*sbuf).size as libc::c_ulong).wrapping_add(len) as size_t as
                size_t;
        return 0 as libc::c_int;
    }
    #[c2rust::src_loc = "56:9"]
    pub const MSGPACK_SBUFFER_INIT_SIZE: libc::c_int = 8192 as libc::c_int;
    #[inline]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_release(mut sbuf:
                                                         *mut msgpack_sbuffer)
     -> *mut libc::c_char {
        let mut tmp = (*sbuf).data;
        (*sbuf).size = 0 as libc::c_int as size_t;
        (*sbuf).data = NULL_0 as *mut libc::c_char;
        (*sbuf).alloc = 0 as libc::c_int as size_t;
        return tmp;
    }
    #[inline]
    #[c2rust::src_loc = "98:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_clear(mut sbuf:
                                                       *mut msgpack_sbuffer) {
        (*sbuf).size = 0 as libc::c_int as size_t;
    }
    use super::stddef_h::{size_t, NULL_0};
    use super::string_h::{memset, memcpy};
    use super::stdlib_h::{free, calloc, realloc};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/vrefbuffer.h:39"]
pub mod vrefbuffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:16"]
    pub struct msgpack_vrefbuffer_inner_buffer {
        pub free: size_t,
        pub ptr: *mut libc::c_char,
        pub head: *mut msgpack_vrefbuffer_chunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "45:16"]
    pub struct msgpack_vrefbuffer {
        pub tail: *mut iovec,
        pub end: *mut iovec,
        pub array: *mut iovec,
        pub chunk_size: size_t,
        pub ref_size: size_t,
        pub inner_buffer: msgpack_vrefbuffer_inner_buffer,
    }
    #[inline]
    #[c2rust::src_loc = "96:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_new(mut ref_size: size_t,
                                                    mut chunk_size: size_t)
     -> *mut msgpack_vrefbuffer {
        let mut vbuf =
            malloc(::std::mem::size_of::<msgpack_vrefbuffer>() as
                       libc::c_ulong) as *mut msgpack_vrefbuffer;
        if vbuf.is_null() { return NULL_0 as *mut msgpack_vrefbuffer }
        if !msgpack_vrefbuffer_init(vbuf, ref_size, chunk_size) {
            free(vbuf as *mut libc::c_void);
            return NULL_0 as *mut msgpack_vrefbuffer
        }
        return vbuf;
    }
    #[inline]
    #[c2rust::src_loc = "107:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_free(mut vbuf:
                                                         *mut msgpack_vrefbuffer) {
        if vbuf.is_null() { return }
        msgpack_vrefbuffer_destroy(vbuf);
        free(vbuf as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "114:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_write(mut data:
                                                          *mut libc::c_void,
                                                      mut buf:
                                                          *const libc::c_char,
                                                      mut len: size_t)
     -> libc::c_int {
        let mut vbuf = data as *mut msgpack_vrefbuffer;
        if len < (*vbuf).ref_size {
            return msgpack_vrefbuffer_append_copy(vbuf, buf, len)
        } else { return msgpack_vrefbuffer_append_ref(vbuf, buf, len) };
    }
    #[inline]
    #[c2rust::src_loc = "125:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_vec(mut vref:
                                                        *const msgpack_vrefbuffer)
     -> *const iovec {
        return (*vref).array;
    }
    #[inline]
    #[c2rust::src_loc = "130:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_veclen(mut vref:
                                                           *const msgpack_vrefbuffer)
     -> size_t {
        return (*vref).tail.wrapping_offset_from((*vref).array) as
                   libc::c_long as size_t;
    }
    use super::stddef_h::{size_t, NULL_0};
    use super::struct_iovec_h::iovec;
    use super::stdlib_h::{malloc, free};
    extern "C" {
        #[c2rust::src_loc = "36:8"]
        pub type msgpack_vrefbuffer_chunk;
        #[no_mangle]
        #[c2rust::src_loc = "66:1"]
        pub fn msgpack_vrefbuffer_init(vbuf: *mut msgpack_vrefbuffer,
                                       ref_size: size_t, chunk_size: size_t)
         -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "69:1"]
        pub fn msgpack_vrefbuffer_destroy(vbuf: *mut msgpack_vrefbuffer);
        #[no_mangle]
        #[c2rust::src_loc = "84:1"]
        pub fn msgpack_vrefbuffer_append_ref(vbuf: *mut msgpack_vrefbuffer,
                                             buf: *const libc::c_char,
                                             len: size_t) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "80:1"]
        pub fn msgpack_vrefbuffer_append_copy(vbuf: *mut msgpack_vrefbuffer,
                                              buf: *const libc::c_char,
                                              len: size_t) -> libc::c_int;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/channel.h:39"]
pub mod channel_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "60:8"]
    pub struct Channel {
        pub id: uint64_t,
        pub refcount: size_t,
        pub events: *mut MultiQueue,
        pub streamtype: ChannelStreamType,
        pub stream: C2RustUnnamed_32,
        pub is_rpc: bool,
        pub rpc: RpcState,
        pub term: *mut Terminal,
        pub on_data: CallbackReader,
        pub on_stderr: CallbackReader,
        pub on_exit: Callback,
        pub exit_status: libc::c_int,
        pub callback_busy: bool,
        pub callback_scheduled: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:9"]
    pub struct CallbackReader {
        pub cb: Callback,
        pub self_0: *mut dict_T,
        pub buffer: garray_T,
        pub eof: bool,
        pub buffered: bool,
        pub type_0: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "66:3"]
    pub union C2RustUnnamed_32 {
        pub proc_0: Process,
        pub uv: LibuvProcess,
        pub pty: PtyProcess,
        pub socket: Stream,
        pub stdio: StdioPair,
        pub err: StderrState,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:9"]
    pub struct StderrState {
        pub closed: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub struct StdioPair {
        pub in_0: Stream,
        pub out: Stream,
    }
    #[c2rust::src_loc = "15:9"]
    pub type ChannelStreamType = libc::c_uint;
    #[c2rust::src_loc = "20:3"]
    pub const kChannelStreamInternal: ChannelStreamType = 4;
    #[c2rust::src_loc = "19:3"]
    pub const kChannelStreamStderr: ChannelStreamType = 3;
    #[c2rust::src_loc = "18:3"]
    pub const kChannelStreamStdio: ChannelStreamType = 2;
    #[c2rust::src_loc = "17:3"]
    pub const kChannelStreamSocket: ChannelStreamType = 1;
    #[c2rust::src_loc = "16:3"]
    pub const kChannelStreamProc: ChannelStreamType = 0;
    #[inline]
    #[c2rust::src_loc = "55:1"]
    pub unsafe extern "C" fn callback_reader_set(mut reader: CallbackReader)
     -> bool {
        return reader.cb.type_0 as libc::c_uint !=
                   kCallbackNone as libc::c_int as libc::c_uint ||
                   !reader.self_0.is_null();
    }
    // / @returns Channel with the id or NULL if not found
    #[inline]
    #[c2rust::src_loc = "95:1"]
    pub unsafe extern "C" fn find_channel(mut id: uint64_t) -> *mut Channel {
        return map_uint64_t_ptr_t_get(channels, id) as *mut Channel;
    }
    #[inline]
    #[c2rust::src_loc = "100:1"]
    pub unsafe extern "C" fn channel_instream(mut chan: *mut Channel)
     -> *mut Stream {
        match (*chan).streamtype as libc::c_uint {
            0 => { return &mut (*chan).stream.proc_0.in_0 }
            1 => { return &mut (*chan).stream.socket }
            2 => { return &mut (*chan).stream.stdio.out }
            4 | 3 => { abort(); }
            _ => { }
        }
        abort();
    }
    #[inline]
    #[c2rust::src_loc = "120:1"]
    pub unsafe extern "C" fn channel_outstream(mut chan: *mut Channel)
     -> *mut Stream {
        match (*chan).streamtype as libc::c_uint {
            0 => { return &mut (*chan).stream.proc_0.out }
            1 => { return &mut (*chan).stream.socket }
            2 => { return &mut (*chan).stream.stdio.in_0 }
            4 | 3 => { abort(); }
            _ => { }
        }
        abort();
    }
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    use super::multiqueue_h::MultiQueue;
    use super::channel_defs_h::RpcState;
    use super::terminal_h::Terminal;
    use super::typval_h::{Callback, dict_T, C2RustUnnamed_8, CallbackType,
                          kCallbackNone};
    use super::garray_h::garray_T;
    use super::process_h::Process;
    use super::libuv_process_h::LibuvProcess;
    use super::pty_process_unix_h::PtyProcess;
    use super::stream_h::Stream;
    use super::nvim_types_h::char_u;
    use super::map_h::{Map_uint64_t_ptr_t, map_uint64_t_ptr_t_get};
    use super::stdlib_h::abort;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "88:24"]
        pub static mut channels: *mut Map_uint64_t_ptr_t;
    }
    // NVIM_CHANNEL_H
}
#[c2rust::header_src =
  "/home/vole/neovim/src/nvim/msgpack_rpc/channel_defs.h:39"]
pub mod channel_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "29:9"]
    pub struct RpcState {
        pub subscribed_events: *mut Map_cstr_t_ptr_t,
        pub closed: bool,
        pub unpacker: *mut msgpack_unpacker,
        pub next_request_id: uint32_t,
        pub call_stack: C2RustUnnamed_31,
        pub info: Dictionary,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "34:3"]
    pub struct C2RustUnnamed_31 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut *mut ChannelCallFrame,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:9"]
    pub struct ChannelCallFrame {
        pub request_id: uint32_t,
        pub returned: bool,
        pub errored: bool,
        pub result: Object,
    }
    use super::map_h::Map_cstr_t_ptr_t;
    use super::unpack_h::msgpack_unpacker;
    use super::stdint_uintn_h::uint32_t;
    use super::defs_h::{Dictionary, Object};
    use super::stddef_h::size_t;
    // NVIM_MSGPACK_RPC_CHANNEL_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/fileio.h:39"]
pub mod fileio_h {
    // / Structure used to read from/write to file
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:9"]
    pub struct FileDescriptor {
        pub fd: libc::c_int,
        pub _error: libc::c_int,
        pub rv: *mut RBuffer,
        pub wr: bool,
        pub eof: bool,
        pub non_blocking: bool,
    }
    // / Check whether end of file was encountered
// /
// / @param[in]  fp  File to check.
// /
// / @return true if it was, false if it was not or read operation was never
// /         performed.
    #[inline]
    #[c2rust::src_loc = "49:1"]
    pub unsafe extern "C" fn file_eof(fp: *const FileDescriptor) -> bool {
        return (*fp).eof as libc::c_int != 0 &&
                   rbuffer_size((*fp).rv) ==
                       0 as libc::c_int as libc::c_ulong;
    }
    // / Return the file descriptor associated with the FileDescriptor structure
// /
// / @param[in]  fp  File to check.
// /
// / @return File descriptor.
    #[inline]
    #[c2rust::src_loc = "62:1"]
    pub unsafe extern "C" fn file_fd(fp: *const FileDescriptor)
     -> libc::c_int {
        return (*fp).fd;
    }
    use super::rbuffer_h::{RBuffer, rbuffer_size};
    // NVIM_OS_FILEIO_H
}
#[c2rust::header_src = "/usr/include/stdint.h:28"]
pub mod stdint_h {
    #[c2rust::src_loc = "227:11"]
    pub const SIZE_MAX: libc::c_ulong = 18446744073709551615 as libc::c_ulong;
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stdbool.h:29"]
pub mod stdbool_h {
    #[c2rust::src_loc = "32:9"]
    pub const true_0: libc::c_int = 1 as libc::c_int;
    #[c2rust::src_loc = "33:9"]
    pub const false_0: libc::c_int = 0 as libc::c_int;
}
#[c2rust::header_src = "/usr/include/string.h:30"]
pub mod string_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "121:14"]
        pub fn strcpy(_: *mut libc::c_char, _: *const libc::c_char)
         -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "136:12"]
        pub fn strcmp(_: *const libc::c_char, _: *const libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "139:12"]
        pub fn strncmp(_: *const libc::c_char, _: *const libc::c_char,
                       _: libc::c_ulong) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "225:14"]
        pub fn strchr(_: *const libc::c_char, _: libc::c_int)
         -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "384:15"]
        pub fn strlen(_: *const libc::c_char) -> libc::c_ulong;
        #[no_mangle]
        #[c2rust::src_loc = "42:14"]
        pub fn memcpy(_: *mut libc::c_void, _: *const libc::c_void,
                      _: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "60:14"]
        pub fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "46:14"]
        pub fn memmove(_: *mut libc::c_void, _: *const libc::c_void,
                       _: libc::c_ulong) -> *mut libc::c_void;
    }
}
#[c2rust::header_src = "/usr/include/strings.h:30"]
pub mod strings_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "120:12"]
        pub fn strncasecmp(_: *const libc::c_char, _: *const libc::c_char,
                           _: libc::c_ulong) -> libc::c_int;
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/byteswap.h:32"]
pub mod byteswap_h {
    #[inline]
    #[c2rust::src_loc = "48:1"]
    pub unsafe extern "C" fn __bswap_32(mut __bsx: __uint32_t) -> __uint32_t {
        return (__bsx & 0xff000000 as libc::c_uint) >> 24 as libc::c_int |
                   (__bsx & 0xff0000 as libc::c_uint) >> 8 as libc::c_int |
                   (__bsx & 0xff00 as libc::c_uint) << 8 as libc::c_int |
                   (__bsx & 0xff as libc::c_uint) << 24 as libc::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "33:1"]
    pub unsafe extern "C" fn __bswap_16(mut __bsx: __uint16_t) -> __uint16_t {
        return (__bsx as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int
                    |
                    (__bsx as libc::c_int & 0xff as libc::c_int) <<
                        8 as libc::c_int) as __uint16_t;
    }
    #[inline]
    #[c2rust::src_loc = "69:15"]
    pub unsafe extern "C" fn __bswap_64(mut __bsx: __uint64_t) -> __uint64_t {
        return ((__bsx as libc::c_ulonglong &
                     0xff00000000000000 as libc::c_ulonglong) >>
                    56 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff000000000000 as libc::c_ulonglong) >>
                        40 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff0000000000 as libc::c_ulonglong) >>
                        24 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff00000000 as libc::c_ulonglong) >>
                        8 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff000000 as libc::c_ulonglong) << 8 as libc::c_int
                    |
                    (__bsx as libc::c_ulonglong &
                         0xff0000 as libc::c_ulonglong) << 24 as libc::c_int |
                    (__bsx as libc::c_ulonglong & 0xff00 as libc::c_ulonglong)
                        << 40 as libc::c_int |
                    (__bsx as libc::c_ulonglong & 0xff as libc::c_ulonglong)
                        << 56 as libc::c_int) as __uint64_t;
    }
    use super::types_h::{__uint32_t, __uint16_t, __uint64_t};
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h:32"]
pub mod uintn_identity_h {
    #[inline]
    #[c2rust::src_loc = "44:1"]
    pub unsafe extern "C" fn __uint64_identity(mut __x: __uint64_t)
     -> __uint64_t {
        return __x;
    }
    #[inline]
    #[c2rust::src_loc = "38:1"]
    pub unsafe extern "C" fn __uint32_identity(mut __x: __uint32_t)
     -> __uint32_t {
        return __x;
    }
    #[inline]
    #[c2rust::src_loc = "32:1"]
    pub unsafe extern "C" fn __uint16_identity(mut __x: __uint16_t)
     -> __uint16_t {
        return __x;
    }
    use super::types_h::{__uint64_t, __uint32_t, __uint16_t};
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h:32"]
pub mod wctype_wchar_h {
    use super::wint_t_h::wint_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "166:1"]
        pub fn towlower(__wc: wint_t) -> wint_t;
        #[no_mangle]
        #[c2rust::src_loc = "169:1"]
        pub fn towupper(__wc: wint_t) -> wint_t;
    }
}
#[c2rust::header_src = "/usr/include/stdlib.h:34"]
pub mod stdlib_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "539:14"]
        pub fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "541:14"]
        pub fn calloc(_: libc::c_ulong, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "549:14"]
        pub fn realloc(_: *mut libc::c_void, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "563:1"]
        pub fn free(__ptr: *mut libc::c_void);
        #[no_mangle]
        #[c2rust::src_loc = "588:13"]
        pub fn abort() -> !;
    }
}
#[c2rust::header_src = "/usr/include/assert.h:34"]
pub mod assert_h {
    #[c2rust::src_loc = "129:12"]
    pub const __ASSERT_FUNCTION: [libc::c_char; 50] =
        unsafe {
            *::std::mem::transmute::<&[u8; 50],
                                     &[libc::c_char; 50]>(b"int utfc_ptr2char_len(const char_u *, int *, int)\x00")
        };
    #[c2rust::src_loc = "129:12"]
    pub const __ASSERT_FUNCTION_0: [libc::c_char; 58] =
        unsafe {
            *::std::mem::transmute::<&[u8; 58],
                                     &[libc::c_char; 58]>(b"void tv_list_set_lock(list_T *const, const VarLockStatus)\x00")
        };
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "69:1"]
        pub fn __assert_fail(__assertion: *const libc::c_char,
                             __file: *const libc::c_char,
                             __line: libc::c_uint,
                             __function: *const libc::c_char) -> !;
    }
}
#[c2rust::header_src = "/home/vole/neovim/build/include/log.h.generated.h:34"]
pub mod log_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn logmsg(log_level: libc::c_int, context: *const libc::c_char,
                      func_name: *const libc::c_char, line_num: libc::c_int,
                      eol: bool, fmt: *const libc::c_char, _: ...) -> bool;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/log.h:34"]
pub mod log_h {
    #[c2rust::src_loc = "11:9"]
    pub const WARN_LOG_LEVEL: libc::c_int = 2 as libc::c_int;
    // NVIM_LOG_H
}
#[c2rust::header_src = "/usr/include/errno.h:34"]
pub mod errno_h {
    #[c2rust::src_loc = "38:10"]
    pub const errno: libc::c_int = *__errno_location();
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "37:1"]
        pub fn __errno_location() -> *mut libc::c_int;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/macros.h:34"]
pub mod macros_h {
    #[c2rust::src_loc = "46:9"]
    pub const TOUPPER_LOC: unsafe extern "C" fn(_: libc::c_int) -> libc::c_int
              =
        toupper;
    #[c2rust::src_loc = "47:9"]
    pub const TOLOWER_LOC: unsafe extern "C" fn(_: libc::c_int) -> libc::c_int
              =
        tolower;
    use super::ctype_h::{toupper, tolower};
    // NVIM_MACROS_H
    // /
// / PRAGMA_DIAG_PUSH_IGNORE_MISSING_PROTOTYPES
// /
    // Type of read()/write() `count` param is platform-dependent.
    // Type of uv_buf_t.len is platform-dependent.
// Related: https://github.com/libuv/libuv/pull/1236
    // / Change type of structure pointers: cast `struct a *` to `struct b *`
// /
// / Used to silence PVS errors.
// /
// / @param  Type  Structure to cast to.
// / @param  obj  Object to cast.
// /
// / @return ((Type *)obj).
    // -V:STRUCT_CAST:641
    // Duplicated in os/win_defs.h to avoid include-order sensitivity.
    // / Get last array entry
// /
// / This should be called with a real array. Calling this with a pointer is an
// / error.
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/message.h.generated.h:34"]
pub mod message_h_generated_h {
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn msg(s: *mut char_u) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "22:1"]
        pub fn emsgf(fmt: *const libc::c_char, _: ...) -> bool;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/vim.h:34"]
pub mod vim_h {
    #[c2rust::src_loc = "91:10"]
    pub const OK: libc::c_int = 1 as libc::c_int;
    #[c2rust::src_loc = "93:9"]
    pub const FAIL: libc::c_int = 0 as libc::c_int;
    // NVIM_VIM_H
    // Replacement for nchar used by nv_replace().
    // BSD is supposed to cover FreeBSD and similar systems.
    // Lowest number used for window ID. Cannot have this many windows per tab.
    // only use "after" directories
    // skip "after" directories
    // do not use 'runtimepath'
    // also use "opt" directory in 'packpath'
    // also use "start" directory in 'packpath'
    // give an error message when none found
    // find directories instead of files
    // all matches, not just the first one
    // Used for flags in do_in_path()
    // Ex command defines
    // buffer and windows
    // This has to go after the include of proto.h, as proto/gui.pro declares
// functions of these names. The declarations would break if the defines had
// been seen at that stage.  But it must be before globals.h, where error_ga
// is declared.
    // / Maximum number of bytes in a multi-byte character.  It can be one 32-bit
// / character of up to 6 bytes, or one 16-bit character of up to three bytes
// / plus six following composing characters of three bytes each.
    // Enums need a typecast to be used as array index (for Ultrix).
    // / Compare file names
// /
// / On some systems case in a file name does not matter, on others it does.
// /
// / @note Does not account for maximum name lengths and things like "../dir",
// /       thus it is not 100% accurate. OS may also use different algorythm for
// /       case-insensitive comparison.
// /
// / @param[in]  x  First file name to compare.
// / @param[in]  y  Second file name to compare.
// /
// / @return 0 for equal file names, non-zero otherwise.
    // max nr of %<flag> in statusline
    // columns needed by shown command
    // Prefer using emsgf(), because perror() may send the output to the wrong
// destination and mess up the screen.
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/memory.h.generated.h:34"]
pub mod memory_h_generated_h {
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn xfree(ptr: *mut libc::c_void);
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn xmalloc(size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "9:1"]
        pub fn xcalloc(count: size_t, size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn xrealloc(ptr: *mut libc::c_void, size: size_t)
         -> *mut libc::c_void;
    }
}
#[c2rust::header_src = "/usr/include/asm-generic/errno-base.h:34"]
pub mod errno_base_h {
    #[c2rust::src_loc = "11:9"]
    pub const E2BIG: libc::c_int = 7 as libc::c_int;
    #[c2rust::src_loc = "26:9"]
    pub const EINVAL: libc::c_int = 22 as libc::c_int;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/iconv.h:34"]
pub mod nvim_iconv_h {
    // define some missing constants if necessary
    #[c2rust::src_loc = "15:11"]
    pub const ICONV_E2BIG: libc::c_int = E2BIG;
    #[c2rust::src_loc = "14:11"]
    pub const ICONV_ERRNO: libc::c_int = *__errno_location();
    #[c2rust::src_loc = "16:11"]
    pub const ICONV_EINVAL: libc::c_int = EINVAL;
    #[c2rust::src_loc = "17:11"]
    pub const ICONV_EILSEQ: libc::c_int = EILSEQ;
    use super::errno_base_h::{E2BIG, EINVAL};
    use super::errno_h::__errno_location;
    use super::asm_generic_errno_h::EILSEQ;
    // NVIM_ICONV_H
}
#[c2rust::header_src = "/usr/include/asm-generic/errno.h:34"]
pub mod asm_generic_errno_h {
    #[c2rust::src_loc = "67:9"]
    pub const EILSEQ: libc::c_int = 84 as libc::c_int;
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/strings.h.generated.h:34"]
pub mod strings_h_generated_h {
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "4:1"]
        pub fn vim_strsave(string: *const char_u) -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "15:1"]
        pub fn vim_strchr(string: *const char_u, c: libc::c_int)
         -> *mut char_u;
    }
}
#[c2rust::header_src = "/usr/include/libintl.h:34"]
pub mod libintl_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "39:1"]
        pub fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/strings.h:34"]
pub mod nvim_strings_h {
    // / Append string to string and return pointer to the next byte
// /
// / Unlike strcat, this one does *not* add NUL byte and returns pointer to the
// / past of the added string.
// /
// / @param[out]  dst  String to append to.
// / @param[in]  src  String to append.
// /
// / @return pointer to the byte just past the appended byte.
    #[inline]
    #[c2rust::src_loc = "20:1"]
    pub unsafe extern "C" fn strappend(dst: *mut libc::c_char,
                                       src: *const libc::c_char)
     -> *mut libc::c_char {
        let src_len = strlen(src);
        return (memmove(dst as *mut libc::c_void, src as *const libc::c_void,
                        src_len) as
                    *mut libc::c_char).offset(src_len as isize);
    }
    use super::string_h::{strlen, memmove};
    use super::stddef_h::size_t;
    // NVIM_STRINGS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/kvec.h:34"]
pub mod kvec_h {
    // The MIT License
//
// Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
    // An example:
//
//     #include "kvec.h"
//     int main() {
//       kvec_t(int) array = KV_INITIAL_VALUE;
//       kv_push(array, 10); // append
//       kv_a(array, 20) = 5; // dynamic
//       kv_A(array, 20) = 4; // static
//       kv_destroy(array);
//       return 0;
//     }
    // / Drop last n items from kvec without resizing
// /
// / Previously spelled as `(void)kv_pop(v)`, repeated n times.
// /
// / @param[out]  v  Kvec to drop items from.
// / @param[in]  n  Number of elements to drop.
    // / Type of a vector with a few first members allocated on stack
// /
// / Is compatible with #kv_A, #kv_pop, #kv_size, #kv_max, #kv_last.
// / Is not compatible with #kv_resize, #kv_resize_full, #kv_copy, #kv_push,
// / #kv_pushp, #kv_a, #kv_destroy.
// /
// / @param[in]  type  Type of vector elements.
// / @param[in]  init_size  Number of the elements in the initial array.
    // / Initialize vector with preallocated array
// /
// / @param[out]  v  Vector to initialize.
    // / Move data to a new destination and free source
    #[inline]
    #[c2rust::src_loc = "139:1"]
    pub unsafe extern "C" fn _memcpy_free(dest: *mut libc::c_void,
                                          src: *mut libc::c_void,
                                          size: size_t) -> *mut libc::c_void {
        memcpy(dest, src, size);
        let mut ptr_ =
            &src as *const *mut libc::c_void as *mut *mut libc::c_void;
        xfree(*ptr_);
        *ptr_ = NULL_1 as *mut libc::c_void;
        return dest;
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::string_h::memcpy;
    use super::memory_h_generated_h::xfree;
    // NVIM_LIB_KVEC_H
    // / Free array of elements of a vector with preallocated array if needed
// /
// / @param[out]  v  Vector to free.
    // / Push value to a vector with preallocated array
// /
// / @param[out]  v  Vector to push to.
// / @param[in]  x  Value to push.
    // / Get location where to store new element to a vector with preallocated array
// /
// / @param[in,out]  v  Vector to push to.
// /
// / @return Pointer to the place where new value should be stored.
    /* 2^x initial array size. */
    /* hard to fix this here and is not very necessary if users will use */
    /* capacity is not guaranteed to have size that is a power of 2, it is */
    /* not to bother with checking whether (v).capacity is 0. But now */
    /* Thus when vector is full capacity may not be zero and it is safe */
    /* ARRAY_SIZE((v).init_array) is the minimal capacity of this vector. */
    // / Resize vector with preallocated array when it is full
// /
// / @param[out]  v  Vector to resize.
    // / Resize vector with preallocated array
// /
// / @note May not resize to an array smaller then init_array: if requested,
// /       init_array will be used.
// /
// / @param[out]  v  Vector to resize.
// / @param[in]  s  New size.
    // -V:kvi_push:512
}
#[c2rust::header_src = "/usr/include/netinet/in.h:34"]
pub mod in_h {
    use super::stdint_uintn_h::{uint32_t, uint16_t};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "374:1"]
        pub fn ntohl(__netlong: uint32_t) -> uint32_t;
        #[no_mangle]
        #[c2rust::src_loc = "375:1"]
        pub fn ntohs(__netshort: uint16_t) -> uint16_t;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/ascii.h:35"]
pub mod ascii_h {
    // Definitions of various common control characters.
    #[c2rust::src_loc = "19:9"]
    pub const NUL: libc::c_int = '\u{0}' as i32;
    #[c2rust::src_loc = "22:9"]
    pub const TAB: libc::c_int = '\t' as i32;
    #[c2rust::src_loc = "23:9"]
    pub const NL: libc::c_int = '\n' as i32;
    /* CR is used by Mac OS X */
    #[c2rust::src_loc = "31:9"]
    pub const CSI: libc::c_int = 0x9b as libc::c_int;
    // Control Sequence Introducer
    /* Device Control String */
    /* String Terminator */
    /* '?' -> DEL, '@' -> ^@, etc. */
    /* @ */
    /* CTRL- [ Left Square Bracket == ESC*/
    /* \ BackSLash */
    /* ] Right Square Bracket */
    /* ^ */
    /*
 * Character that separates dir names in a path.
 */
    // / Checks if `c` is a space or tab character.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "117:1"]
    pub unsafe extern "C" fn ascii_iswhite(mut c: libc::c_int) -> bool {
        return c == ' ' as i32 || c == '\t' as i32;
    }
    // / Check whether character is a decimal digit.
// /
// / Library isdigit() function is officially locale-dependent and, for
// / example, returns true for superscript 1 (¹) in locales where encoding
// / contains it in lower 8 bits. Also avoids crashes in case c is below
// / 0 or above 255: library functions are officially defined as accepting
// / only EOF and unsigned char values (otherwise it is undefined behaviour)
// / what may be used for some optimizations (e.g. simple `return
// / isdigit_table[c];`).
    #[inline(always)]
    #[c2rust::src_loc = "131:1"]
    pub unsafe extern "C" fn ascii_isdigit(mut c: libc::c_int) -> bool {
        return c >= '0' as i32 && c <= '9' as i32;
    }
    // / Checks if `c` is a hexadecimal digit, that is, one of 0-9, a-f, A-F.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "139:1"]
    pub unsafe extern "C" fn ascii_isxdigit(mut c: libc::c_int) -> bool {
        return c >= '0' as i32 && c <= '9' as i32 ||
                   c >= 'a' as i32 && c <= 'f' as i32 ||
                   c >= 'A' as i32 && c <= 'F' as i32;
    }
    // / Checks if `c` is an “identifier” character
// /
// / That is, whether it is alphanumeric character or underscore.
    #[inline(always)]
    #[c2rust::src_loc = "149:1"]
    pub unsafe extern "C" fn ascii_isident(mut c: libc::c_int) -> bool {
        return c as libc::c_uint >= 'A' as i32 as libc::c_uint &&
                   c as libc::c_uint <= 'Z' as i32 as libc::c_uint ||
                   c as libc::c_uint >= 'a' as i32 as libc::c_uint &&
                       c as libc::c_uint <= 'z' as i32 as libc::c_uint ||
                   ascii_isdigit(c) as libc::c_int != 0 || c == '_' as i32;
    }
    // / Checks if `c` is a binary digit, that is, 0-1.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "157:1"]
    pub unsafe extern "C" fn ascii_isbdigit(mut c: libc::c_int) -> bool {
        return c == '0' as i32 || c == '1' as i32;
    }
    // / Checks if `c` is a white-space character, that is,
// / one of \f, \n, \r, \t, \v.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "166:1"]
    pub unsafe extern "C" fn ascii_isspace(mut c: libc::c_int) -> bool {
        return c >= 9 as libc::c_int && c <= 13 as libc::c_int ||
                   c == ' ' as i32;
    }
    /* NVIM_ASCII_H */
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/locale.h:37"]
pub mod locale_h {
    #[c2rust::src_loc = "26:9"]
    pub const __LC_CTYPE: libc::c_int = 0 as libc::c_int;
}
#[c2rust::header_src = "/usr/include/locale.h:37"]
pub mod include_locale_h {
    #[c2rust::src_loc = "35:9"]
    pub const LC_CTYPE: libc::c_int = __LC_CTYPE;
    use super::locale_h::__LC_CTYPE;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "122:1"]
        pub fn setlocale(__category: libc::c_int,
                         __locale: *const libc::c_char) -> *mut libc::c_char;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/charset.h:43"]
pub mod charset_h {
    // / Check if `c` is one of the characters in 'breakat'.
// / Used very often if 'linebreak' is set
    #[inline(always)]
    #[c2rust::src_loc = "106:1"]
    pub unsafe extern "C" fn vim_isbreak(mut c: libc::c_int) -> bool {
        return breakat_flags[c as char_u as usize] != 0;
    }
    use super::nvim_types_h::char_u;
    use super::stdint_uintn_h::uint64_t;
    use super::option_defs_h::breakat_flags;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "47:1"]
        pub fn char2cells(c: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "48:1"]
        pub fn ptr2cells(p: *const char_u) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "57:1"]
        pub fn vim_iswordc_tab(c: libc::c_int, chartab: *const uint64_t)
         -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "63:1"]
        pub fn vim_isprintc(c: libc::c_int) -> bool;
    }
    // NVIM_CHARSET_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/cursor.h.generated.h:44"]
pub mod cursor_h_generated_h {
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "22:1"]
        pub fn get_cursor_pos_ptr() -> *mut char_u;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/env.h.generated.h:45"]
pub mod env_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn os_getenv(name: *const libc::c_char) -> *const libc::c_char;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/memline.h.generated.h:47"]
pub mod memline_h_generated_h {
    use super::buffer_defs_h::buf_T;
    use super::pos_h::linenr_T;
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "21:1"]
        pub fn ml_get_buf(buf: *mut buf_T, lnum: linenr_T, will_change: bool)
         -> *mut char_u;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/misc1.h.generated.h:49"]
pub mod misc1_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "23:1"]
        pub fn beep_flush();
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/arabic.h.generated.h:56"]
pub mod arabic_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn arabic_combine(one: libc::c_int, two: libc::c_int) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "6:1"]
        pub fn arabic_maycombine(two: libc::c_int) -> bool;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/arabic.h:56"]
pub mod arabic_h {
    // / Whether c belongs to the range of Arabic characters that might be shaped.
    #[inline]
    #[c2rust::src_loc = "7:1"]
    pub unsafe extern "C" fn arabic_char(mut c: libc::c_int) -> bool {
        // return c >= a_HAMZA && c <= a_MINI_ALEF;
        return c >= 0x621 as libc::c_int && c <= 0x670 as libc::c_int;
    }
    // NVIM_ARABIC_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mark.h:57"]
pub mod mark_h {
    // for exarg_T
    // / Set fmark using given value
    // / Free and set fmark using given value
    // / Clear given fmark
    // / Set given extended mark (regular mark + file name)
    // / Free and set given extended mark (regular mark + file name)
    // / Convert mark name to the offset
    // / Convert local mark name to the offset
    #[inline]
    #[c2rust::src_loc = "66:1"]
    pub unsafe extern "C" fn mark_local_index(name: libc::c_char)
     -> libc::c_int {
        return if name as libc::c_uint >= 'a' as i32 as libc::c_uint &&
                      name as libc::c_uint <= 'z' as i32 as libc::c_uint {
                   (name as libc::c_int) - 'a' as i32
               } else if name as libc::c_int == '\"' as i32 {
                   NMARKS
               } else if name as libc::c_int == '^' as i32 {
                   (NMARKS) + 1 as libc::c_int
               } else if name as libc::c_int == '.' as i32 {
                   (NMARKS) + 2 as libc::c_int
               } else { -(1 as libc::c_int) };
    }
    // / Return true if position a is before (less than) position b.
    // / Return true if position a and b are equal.
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn equalpos(mut a: pos_T, mut b: pos_T) -> bool {
        return a.lnum == b.lnum && a.col == b.col && a.coladd == b.coladd;
    }
    // / Return true if position a is less than or equal to b.
    #[inline(always)]
    #[c2rust::src_loc = "107:1"]
    pub unsafe extern "C" fn ltoreq(mut a: pos_T, mut b: pos_T) -> bool {
        return lt(a, b) as libc::c_int != 0 ||
                   equalpos(a, b) as libc::c_int != 0;
    }
    // / Clear the pos_T structure pointed to by a.
    #[inline(always)]
    #[c2rust::src_loc = "113:1"]
    pub unsafe extern "C" fn clearpos(mut a: *mut pos_T) {
        (*a).lnum = 0 as libc::c_int as linenr_T;
        (*a).col = 0 as libc::c_int;
        (*a).coladd = 0 as libc::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "55:1"]
    pub unsafe extern "C" fn mark_global_index(name: libc::c_char)
     -> libc::c_int {
        return if name as libc::c_uint >= 'A' as i32 as libc::c_uint &&
                      name as libc::c_uint <= 'Z' as i32 as libc::c_uint {
                   (name as libc::c_int) - 'A' as i32
               } else if ascii_isdigit(name as libc::c_int) as libc::c_int !=
                             0 {
                   (NMARKS) + (name as libc::c_int - '0' as i32)
               } else { -(1 as libc::c_int) };
    }
    #[inline(always)]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn lt(mut a: pos_T, mut b: pos_T) -> bool {
        if a.lnum != b.lnum {
            return a.lnum < b.lnum
        } else if a.col != b.col {
            return a.col < b.col
        } else { return a.coladd < b.coladd };
    }
    use super::mark_defs_h::NMARKS;
    use super::pos_h::{pos_T, linenr_T, colnr_T};
    use super::ascii_h::ascii_isdigit;
    // NVIM_MARK_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/mark.h.generated.h:57"]
pub mod mark_h_generated_h {
    use super::buffer_defs_h::buf_T;
    use super::pos_h::pos_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "38:1"]
        pub fn mark_mb_adjustpos(buf: *mut buf_T, lp: *mut pos_T);
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/src/nvim/auto/unicode_tables.generated.h:73"]
pub mod unicode_tables_generated_h {
    #[c2rust::src_loc = "1:28"]
    pub static mut toLower: [convertStruct; 172] =
        [{
             let mut init =
                 convertStruct{rangeStart: 0x41 as libc::c_int,
                               rangeEnd: 0x5a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xc0 as libc::c_int,
                               rangeEnd: 0xd6 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xd8 as libc::c_int,
                               rangeEnd: 0xde as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x100 as libc::c_int,
                               rangeEnd: 0x12e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x130 as libc::c_int,
                               rangeEnd: 0x130 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(199 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x132 as libc::c_int,
                               rangeEnd: 0x136 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x139 as libc::c_int,
                               rangeEnd: 0x147 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x14a as libc::c_int,
                               rangeEnd: 0x176 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x178 as libc::c_int,
                               rangeEnd: 0x178 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(121 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x179 as libc::c_int,
                               rangeEnd: 0x17d as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x181 as libc::c_int,
                               rangeEnd: 0x181 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 210 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x182 as libc::c_int,
                               rangeEnd: 0x184 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x186 as libc::c_int,
                               rangeEnd: 0x186 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 206 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x187 as libc::c_int,
                               rangeEnd: 0x187 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x189 as libc::c_int,
                               rangeEnd: 0x18a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 205 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18b as libc::c_int,
                               rangeEnd: 0x18b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18e as libc::c_int,
                               rangeEnd: 0x18e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 79 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18f as libc::c_int,
                               rangeEnd: 0x18f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 202 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x190 as libc::c_int,
                               rangeEnd: 0x190 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 203 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x191 as libc::c_int,
                               rangeEnd: 0x191 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x193 as libc::c_int,
                               rangeEnd: 0x193 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 205 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x194 as libc::c_int,
                               rangeEnd: 0x194 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 207 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x196 as libc::c_int,
                               rangeEnd: 0x196 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 211 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x197 as libc::c_int,
                               rangeEnd: 0x197 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 209 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x198 as libc::c_int,
                               rangeEnd: 0x198 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19c as libc::c_int,
                               rangeEnd: 0x19c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 211 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19d as libc::c_int,
                               rangeEnd: 0x19d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 213 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19f as libc::c_int,
                               rangeEnd: 0x19f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 214 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a0 as libc::c_int,
                               rangeEnd: 0x1a4 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a6 as libc::c_int,
                               rangeEnd: 0x1a6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a7 as libc::c_int,
                               rangeEnd: 0x1a7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a9 as libc::c_int,
                               rangeEnd: 0x1a9 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ac as libc::c_int,
                               rangeEnd: 0x1ac as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ae as libc::c_int,
                               rangeEnd: 0x1ae as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1af as libc::c_int,
                               rangeEnd: 0x1af as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b1 as libc::c_int,
                               rangeEnd: 0x1b2 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 217 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b3 as libc::c_int,
                               rangeEnd: 0x1b5 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b7 as libc::c_int,
                               rangeEnd: 0x1b7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 219 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b8 as libc::c_int,
                               rangeEnd: 0x1bc as libc::c_int,
                               step: 4 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c4 as libc::c_int,
                               rangeEnd: 0x1c4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c5 as libc::c_int,
                               rangeEnd: 0x1c5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c7 as libc::c_int,
                               rangeEnd: 0x1c7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c8 as libc::c_int,
                               rangeEnd: 0x1c8 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ca as libc::c_int,
                               rangeEnd: 0x1ca as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cb as libc::c_int,
                               rangeEnd: 0x1db as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1de as libc::c_int,
                               rangeEnd: 0x1ee as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f1 as libc::c_int,
                               rangeEnd: 0x1f1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f2 as libc::c_int,
                               rangeEnd: 0x1f4 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f6 as libc::c_int,
                               rangeEnd: 0x1f6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(97 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f7 as libc::c_int,
                               rangeEnd: 0x1f7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(56 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f8 as libc::c_int,
                               rangeEnd: 0x21e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x220 as libc::c_int,
                               rangeEnd: 0x220 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(130 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x222 as libc::c_int,
                               rangeEnd: 0x232 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23a as libc::c_int,
                               rangeEnd: 0x23a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10795 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23b as libc::c_int,
                               rangeEnd: 0x23b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23d as libc::c_int,
                               rangeEnd: 0x23d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(163 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23e as libc::c_int,
                               rangeEnd: 0x23e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10792 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x241 as libc::c_int,
                               rangeEnd: 0x241 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x243 as libc::c_int,
                               rangeEnd: 0x243 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(195 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x244 as libc::c_int,
                               rangeEnd: 0x244 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 69 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x245 as libc::c_int,
                               rangeEnd: 0x245 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 71 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x246 as libc::c_int,
                               rangeEnd: 0x24e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x370 as libc::c_int,
                               rangeEnd: 0x372 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x376 as libc::c_int,
                               rangeEnd: 0x376 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x37f as libc::c_int,
                               rangeEnd: 0x37f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 116 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x386 as libc::c_int,
                               rangeEnd: 0x386 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 38 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x388 as libc::c_int,
                               rangeEnd: 0x38a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 37 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x38c as libc::c_int,
                               rangeEnd: 0x38c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 64 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x38e as libc::c_int,
                               rangeEnd: 0x38f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 63 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x391 as libc::c_int,
                               rangeEnd: 0x3a1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3a3 as libc::c_int,
                               rangeEnd: 0x3ab as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3cf as libc::c_int,
                               rangeEnd: 0x3cf as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d8 as libc::c_int,
                               rangeEnd: 0x3ee as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f4 as libc::c_int,
                               rangeEnd: 0x3f4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(60 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f7 as libc::c_int,
                               rangeEnd: 0x3f7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f9 as libc::c_int,
                               rangeEnd: 0x3f9 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3fa as libc::c_int,
                               rangeEnd: 0x3fa as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3fd as libc::c_int,
                               rangeEnd: 0x3ff as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(130 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x400 as libc::c_int,
                               rangeEnd: 0x40f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 80 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x410 as libc::c_int,
                               rangeEnd: 0x42f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x460 as libc::c_int,
                               rangeEnd: 0x480 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x48a as libc::c_int,
                               rangeEnd: 0x4be as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4c0 as libc::c_int,
                               rangeEnd: 0x4c0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 15 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4c1 as libc::c_int,
                               rangeEnd: 0x4cd as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4d0 as libc::c_int,
                               rangeEnd: 0x52e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x531 as libc::c_int,
                               rangeEnd: 0x556 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 48 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10a0 as libc::c_int,
                               rangeEnd: 0x10c5 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 7264 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10c7 as libc::c_int,
                               rangeEnd: 0x10cd as libc::c_int,
                               step: 6 as libc::c_int,
                               offset: 7264 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x13a0 as libc::c_int,
                               rangeEnd: 0x13ef as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 38864 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x13f0 as libc::c_int,
                               rangeEnd: 0x13f5 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c90 as libc::c_int,
                               rangeEnd: 0x1cba as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(3008 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cbd as libc::c_int,
                               rangeEnd: 0x1cbf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(3008 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e00 as libc::c_int,
                               rangeEnd: 0x1e94 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e9e as libc::c_int,
                               rangeEnd: 0x1e9e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7615 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ea0 as libc::c_int,
                               rangeEnd: 0x1efe as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f08 as libc::c_int,
                               rangeEnd: 0x1f0f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f18 as libc::c_int,
                               rangeEnd: 0x1f1d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f28 as libc::c_int,
                               rangeEnd: 0x1f2f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f38 as libc::c_int,
                               rangeEnd: 0x1f3f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f48 as libc::c_int,
                               rangeEnd: 0x1f4d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f59 as libc::c_int,
                               rangeEnd: 0x1f5f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f68 as libc::c_int,
                               rangeEnd: 0x1f6f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f88 as libc::c_int,
                               rangeEnd: 0x1f8f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f98 as libc::c_int,
                               rangeEnd: 0x1f9f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fa8 as libc::c_int,
                               rangeEnd: 0x1faf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fb8 as libc::c_int,
                               rangeEnd: 0x1fb9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fba as libc::c_int,
                               rangeEnd: 0x1fbb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(74 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fbc as libc::c_int,
                               rangeEnd: 0x1fbc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fc8 as libc::c_int,
                               rangeEnd: 0x1fcb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(86 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fcc as libc::c_int,
                               rangeEnd: 0x1fcc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fd8 as libc::c_int,
                               rangeEnd: 0x1fd9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fda as libc::c_int,
                               rangeEnd: 0x1fdb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(100 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fe8 as libc::c_int,
                               rangeEnd: 0x1fe9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fea as libc::c_int,
                               rangeEnd: 0x1feb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(112 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fec as libc::c_int,
                               rangeEnd: 0x1fec as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ff8 as libc::c_int,
                               rangeEnd: 0x1ff9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(128 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ffa as libc::c_int,
                               rangeEnd: 0x1ffb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(126 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ffc as libc::c_int,
                               rangeEnd: 0x1ffc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2126 as libc::c_int,
                               rangeEnd: 0x2126 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7517 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x212a as libc::c_int,
                               rangeEnd: 0x212a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(8383 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x212b as libc::c_int,
                               rangeEnd: 0x212b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(8262 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2132 as libc::c_int,
                               rangeEnd: 0x2132 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 28 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2160 as libc::c_int,
                               rangeEnd: 0x216f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 16 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2183 as libc::c_int,
                               rangeEnd: 0x2183 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x24b6 as libc::c_int,
                               rangeEnd: 0x24cf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 26 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c00 as libc::c_int,
                               rangeEnd: 0x2c2e as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 48 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c60 as libc::c_int,
                               rangeEnd: 0x2c60 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c62 as libc::c_int,
                               rangeEnd: 0x2c62 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10743 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c63 as libc::c_int,
                               rangeEnd: 0x2c63 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(3814 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c64 as libc::c_int,
                               rangeEnd: 0x2c64 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10727 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c67 as libc::c_int,
                               rangeEnd: 0x2c6b as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6d as libc::c_int,
                               rangeEnd: 0x2c6d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10780 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6e as libc::c_int,
                               rangeEnd: 0x2c6e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10749 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6f as libc::c_int,
                               rangeEnd: 0x2c6f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10783 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c70 as libc::c_int,
                               rangeEnd: 0x2c70 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10782 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c72 as libc::c_int,
                               rangeEnd: 0x2c75 as libc::c_int,
                               step: 3 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c7e as libc::c_int,
                               rangeEnd: 0x2c7f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(10815 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c80 as libc::c_int,
                               rangeEnd: 0x2ce2 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2ceb as libc::c_int,
                               rangeEnd: 0x2ced as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2cf2 as libc::c_int,
                               rangeEnd: 0xa640 as libc::c_int,
                               step: 31054 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa642 as libc::c_int,
                               rangeEnd: 0xa66c as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa680 as libc::c_int,
                               rangeEnd: 0xa69a as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa722 as libc::c_int,
                               rangeEnd: 0xa72e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa732 as libc::c_int,
                               rangeEnd: 0xa76e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa779 as libc::c_int,
                               rangeEnd: 0xa77b as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77d as libc::c_int,
                               rangeEnd: 0xa77d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(35332 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77e as libc::c_int,
                               rangeEnd: 0xa786 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa78b as libc::c_int,
                               rangeEnd: 0xa78b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa78d as libc::c_int,
                               rangeEnd: 0xa78d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42280 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa790 as libc::c_int,
                               rangeEnd: 0xa792 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa796 as libc::c_int,
                               rangeEnd: 0xa7a8 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7aa as libc::c_int,
                               rangeEnd: 0xa7aa as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42308 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ab as libc::c_int,
                               rangeEnd: 0xa7ab as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42319 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ac as libc::c_int,
                               rangeEnd: 0xa7ac as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42315 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ad as libc::c_int,
                               rangeEnd: 0xa7ad as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42305 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ae as libc::c_int,
                               rangeEnd: 0xa7ae as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42308 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b0 as libc::c_int,
                               rangeEnd: 0xa7b0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42258 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b1 as libc::c_int,
                               rangeEnd: 0xa7b1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42282 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b2 as libc::c_int,
                               rangeEnd: 0xa7b2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42261 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b3 as libc::c_int,
                               rangeEnd: 0xa7b3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 928 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b4 as libc::c_int,
                               rangeEnd: 0xa7be as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c2 as libc::c_int,
                               rangeEnd: 0xa7c2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c4 as libc::c_int,
                               rangeEnd: 0xa7c4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(48 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c5 as libc::c_int,
                               rangeEnd: 0xa7c5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42307 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c6 as libc::c_int,
                               rangeEnd: 0xa7c6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(35384 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xff21 as libc::c_int,
                               rangeEnd: 0xff3a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10400 as libc::c_int,
                               rangeEnd: 0x10427 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 40 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x104b0 as libc::c_int,
                               rangeEnd: 0x104d3 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 40 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10c80 as libc::c_int,
                               rangeEnd: 0x10cb2 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 64 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x118a0 as libc::c_int,
                               rangeEnd: 0x118bf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x16e40 as libc::c_int,
                               rangeEnd: 0x16e5f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e900 as libc::c_int,
                               rangeEnd: 0x1e921 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 34 as libc::c_int,};
             init
         }];
    #[c2rust::src_loc = "175:28"]
    pub static mut toUpper: [convertStruct; 187] =
        [{
             let mut init =
                 convertStruct{rangeStart: 0x61 as libc::c_int,
                               rangeEnd: 0x7a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xb5 as libc::c_int,
                               rangeEnd: 0xb5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 743 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xe0 as libc::c_int,
                               rangeEnd: 0xf6 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xf8 as libc::c_int,
                               rangeEnd: 0xfe as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xff as libc::c_int,
                               rangeEnd: 0xff as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 121 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x101 as libc::c_int,
                               rangeEnd: 0x12f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x131 as libc::c_int,
                               rangeEnd: 0x131 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(232 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x133 as libc::c_int,
                               rangeEnd: 0x137 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x13a as libc::c_int,
                               rangeEnd: 0x148 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x14b as libc::c_int,
                               rangeEnd: 0x177 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x17a as libc::c_int,
                               rangeEnd: 0x17e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x17f as libc::c_int,
                               rangeEnd: 0x17f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(300 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x180 as libc::c_int,
                               rangeEnd: 0x180 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 195 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x183 as libc::c_int,
                               rangeEnd: 0x185 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x188 as libc::c_int,
                               rangeEnd: 0x18c as libc::c_int,
                               step: 4 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x192 as libc::c_int,
                               rangeEnd: 0x192 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x195 as libc::c_int,
                               rangeEnd: 0x195 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 97 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x199 as libc::c_int,
                               rangeEnd: 0x199 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19a as libc::c_int,
                               rangeEnd: 0x19a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 163 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19e as libc::c_int,
                               rangeEnd: 0x19e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 130 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a1 as libc::c_int,
                               rangeEnd: 0x1a5 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a8 as libc::c_int,
                               rangeEnd: 0x1ad as libc::c_int,
                               step: 5 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b0 as libc::c_int,
                               rangeEnd: 0x1b4 as libc::c_int,
                               step: 4 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b6 as libc::c_int,
                               rangeEnd: 0x1b9 as libc::c_int,
                               step: 3 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1bd as libc::c_int,
                               rangeEnd: 0x1bd as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1bf as libc::c_int,
                               rangeEnd: 0x1bf as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 56 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c5 as libc::c_int,
                               rangeEnd: 0x1c5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c6 as libc::c_int,
                               rangeEnd: 0x1c6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(2 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c8 as libc::c_int,
                               rangeEnd: 0x1c8 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c9 as libc::c_int,
                               rangeEnd: 0x1c9 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(2 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cb as libc::c_int,
                               rangeEnd: 0x1cb as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cc as libc::c_int,
                               rangeEnd: 0x1cc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(2 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ce as libc::c_int,
                               rangeEnd: 0x1dc as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1dd as libc::c_int,
                               rangeEnd: 0x1dd as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(79 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1df as libc::c_int,
                               rangeEnd: 0x1ef as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f2 as libc::c_int,
                               rangeEnd: 0x1f2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f3 as libc::c_int,
                               rangeEnd: 0x1f3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(2 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f5 as libc::c_int,
                               rangeEnd: 0x1f9 as libc::c_int,
                               step: 4 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fb as libc::c_int,
                               rangeEnd: 0x21f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x223 as libc::c_int,
                               rangeEnd: 0x233 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23c as libc::c_int,
                               rangeEnd: 0x23c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23f as libc::c_int,
                               rangeEnd: 0x240 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 10815 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x242 as libc::c_int,
                               rangeEnd: 0x247 as libc::c_int,
                               step: 5 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x249 as libc::c_int,
                               rangeEnd: 0x24f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x250 as libc::c_int,
                               rangeEnd: 0x250 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10783 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x251 as libc::c_int,
                               rangeEnd: 0x251 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10780 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x252 as libc::c_int,
                               rangeEnd: 0x252 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10782 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x253 as libc::c_int,
                               rangeEnd: 0x253 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(210 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x254 as libc::c_int,
                               rangeEnd: 0x254 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(206 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x256 as libc::c_int,
                               rangeEnd: 0x257 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(205 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x259 as libc::c_int,
                               rangeEnd: 0x259 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(202 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x25b as libc::c_int,
                               rangeEnd: 0x25b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(203 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x25c as libc::c_int,
                               rangeEnd: 0x25c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42319 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x260 as libc::c_int,
                               rangeEnd: 0x260 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(205 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x261 as libc::c_int,
                               rangeEnd: 0x261 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42315 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x263 as libc::c_int,
                               rangeEnd: 0x263 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(207 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x265 as libc::c_int,
                               rangeEnd: 0x265 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42280 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x266 as libc::c_int,
                               rangeEnd: 0x266 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42308 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x268 as libc::c_int,
                               rangeEnd: 0x268 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(209 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x269 as libc::c_int,
                               rangeEnd: 0x269 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(211 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x26a as libc::c_int,
                               rangeEnd: 0x26a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42308 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x26b as libc::c_int,
                               rangeEnd: 0x26b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10743 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x26c as libc::c_int,
                               rangeEnd: 0x26c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42305 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x26f as libc::c_int,
                               rangeEnd: 0x26f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(211 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x271 as libc::c_int,
                               rangeEnd: 0x271 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10749 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x272 as libc::c_int,
                               rangeEnd: 0x272 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(213 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x275 as libc::c_int,
                               rangeEnd: 0x275 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(214 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x27d as libc::c_int,
                               rangeEnd: 0x27d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10727 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x280 as libc::c_int,
                               rangeEnd: 0x280 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(218 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x282 as libc::c_int,
                               rangeEnd: 0x282 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42307 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x283 as libc::c_int,
                               rangeEnd: 0x283 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(218 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x287 as libc::c_int,
                               rangeEnd: 0x287 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42282 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x288 as libc::c_int,
                               rangeEnd: 0x288 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(218 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x289 as libc::c_int,
                               rangeEnd: 0x289 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(69 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x28a as libc::c_int,
                               rangeEnd: 0x28b as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(217 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x28c as libc::c_int,
                               rangeEnd: 0x28c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(71 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x292 as libc::c_int,
                               rangeEnd: 0x292 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(219 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x29d as libc::c_int,
                               rangeEnd: 0x29d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42261 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x29e as libc::c_int,
                               rangeEnd: 0x29e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 42258 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x345 as libc::c_int,
                               rangeEnd: 0x345 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 84 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x371 as libc::c_int,
                               rangeEnd: 0x373 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x377 as libc::c_int,
                               rangeEnd: 0x377 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x37b as libc::c_int,
                               rangeEnd: 0x37d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 130 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3ac as libc::c_int,
                               rangeEnd: 0x3ac as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(38 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3ad as libc::c_int,
                               rangeEnd: 0x3af as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(37 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3b1 as libc::c_int,
                               rangeEnd: 0x3c1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3c2 as libc::c_int,
                               rangeEnd: 0x3c2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(31 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3c3 as libc::c_int,
                               rangeEnd: 0x3cb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3cc as libc::c_int,
                               rangeEnd: 0x3cc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(64 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3cd as libc::c_int,
                               rangeEnd: 0x3ce as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(63 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d0 as libc::c_int,
                               rangeEnd: 0x3d0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(62 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d1 as libc::c_int,
                               rangeEnd: 0x3d1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(57 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d5 as libc::c_int,
                               rangeEnd: 0x3d5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(47 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d6 as libc::c_int,
                               rangeEnd: 0x3d6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(54 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d7 as libc::c_int,
                               rangeEnd: 0x3d7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d9 as libc::c_int,
                               rangeEnd: 0x3ef as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f0 as libc::c_int,
                               rangeEnd: 0x3f0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(86 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f1 as libc::c_int,
                               rangeEnd: 0x3f1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(80 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f2 as libc::c_int,
                               rangeEnd: 0x3f2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 7 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f3 as libc::c_int,
                               rangeEnd: 0x3f3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(116 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f5 as libc::c_int,
                               rangeEnd: 0x3f5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(96 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f8 as libc::c_int,
                               rangeEnd: 0x3fb as libc::c_int,
                               step: 3 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x430 as libc::c_int,
                               rangeEnd: 0x44f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x450 as libc::c_int,
                               rangeEnd: 0x45f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(80 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x461 as libc::c_int,
                               rangeEnd: 0x481 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x48b as libc::c_int,
                               rangeEnd: 0x4bf as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4c2 as libc::c_int,
                               rangeEnd: 0x4ce as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4cf as libc::c_int,
                               rangeEnd: 0x4cf as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(15 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4d1 as libc::c_int,
                               rangeEnd: 0x52f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x561 as libc::c_int,
                               rangeEnd: 0x586 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(48 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10d0 as libc::c_int,
                               rangeEnd: 0x10fa as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 3008 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10fd as libc::c_int,
                               rangeEnd: 0x10ff as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 3008 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x13f8 as libc::c_int,
                               rangeEnd: 0x13fd as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c80 as libc::c_int,
                               rangeEnd: 0x1c80 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6254 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c81 as libc::c_int,
                               rangeEnd: 0x1c81 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6253 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c82 as libc::c_int,
                               rangeEnd: 0x1c82 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6244 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c83 as libc::c_int,
                               rangeEnd: 0x1c84 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(6242 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c85 as libc::c_int,
                               rangeEnd: 0x1c85 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6243 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c86 as libc::c_int,
                               rangeEnd: 0x1c86 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6236 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c87 as libc::c_int,
                               rangeEnd: 0x1c87 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6181 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c88 as libc::c_int,
                               rangeEnd: 0x1c88 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 35266 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1d79 as libc::c_int,
                               rangeEnd: 0x1d79 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 35332 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1d7d as libc::c_int,
                               rangeEnd: 0x1d7d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 3814 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1d8e as libc::c_int,
                               rangeEnd: 0x1d8e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 35384 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e01 as libc::c_int,
                               rangeEnd: 0x1e95 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e9b as libc::c_int,
                               rangeEnd: 0x1e9b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(59 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ea1 as libc::c_int,
                               rangeEnd: 0x1eff as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f00 as libc::c_int,
                               rangeEnd: 0x1f07 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f10 as libc::c_int,
                               rangeEnd: 0x1f15 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f20 as libc::c_int,
                               rangeEnd: 0x1f27 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f30 as libc::c_int,
                               rangeEnd: 0x1f37 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f40 as libc::c_int,
                               rangeEnd: 0x1f45 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f51 as libc::c_int,
                               rangeEnd: 0x1f57 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f60 as libc::c_int,
                               rangeEnd: 0x1f67 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f70 as libc::c_int,
                               rangeEnd: 0x1f71 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 74 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f72 as libc::c_int,
                               rangeEnd: 0x1f75 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 86 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f76 as libc::c_int,
                               rangeEnd: 0x1f77 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 100 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f78 as libc::c_int,
                               rangeEnd: 0x1f79 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 128 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f7a as libc::c_int,
                               rangeEnd: 0x1f7b as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 112 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f7c as libc::c_int,
                               rangeEnd: 0x1f7d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 126 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f80 as libc::c_int,
                               rangeEnd: 0x1f87 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f90 as libc::c_int,
                               rangeEnd: 0x1f97 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fa0 as libc::c_int,
                               rangeEnd: 0x1fa7 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fb0 as libc::c_int,
                               rangeEnd: 0x1fb1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fb3 as libc::c_int,
                               rangeEnd: 0x1fb3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 9 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fbe as libc::c_int,
                               rangeEnd: 0x1fbe as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7205 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fc3 as libc::c_int,
                               rangeEnd: 0x1fc3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 9 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fd0 as libc::c_int,
                               rangeEnd: 0x1fd1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fe0 as libc::c_int,
                               rangeEnd: 0x1fe1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fe5 as libc::c_int,
                               rangeEnd: 0x1fe5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 7 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ff3 as libc::c_int,
                               rangeEnd: 0x1ff3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 9 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x214e as libc::c_int,
                               rangeEnd: 0x214e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(28 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2170 as libc::c_int,
                               rangeEnd: 0x217f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(16 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2184 as libc::c_int,
                               rangeEnd: 0x2184 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x24d0 as libc::c_int,
                               rangeEnd: 0x24e9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(26 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c30 as libc::c_int,
                               rangeEnd: 0x2c5e as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(48 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c61 as libc::c_int,
                               rangeEnd: 0x2c61 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c65 as libc::c_int,
                               rangeEnd: 0x2c65 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10795 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c66 as libc::c_int,
                               rangeEnd: 0x2c66 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10792 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c68 as libc::c_int,
                               rangeEnd: 0x2c6c as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c73 as libc::c_int,
                               rangeEnd: 0x2c76 as libc::c_int,
                               step: 3 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c81 as libc::c_int,
                               rangeEnd: 0x2ce3 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2cec as libc::c_int,
                               rangeEnd: 0x2cee as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2cf3 as libc::c_int,
                               rangeEnd: 0x2cf3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2d00 as libc::c_int,
                               rangeEnd: 0x2d25 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(7264 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2d27 as libc::c_int,
                               rangeEnd: 0x2d2d as libc::c_int,
                               step: 6 as libc::c_int,
                               offset: -(7264 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa641 as libc::c_int,
                               rangeEnd: 0xa66d as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa681 as libc::c_int,
                               rangeEnd: 0xa69b as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa723 as libc::c_int,
                               rangeEnd: 0xa72f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa733 as libc::c_int,
                               rangeEnd: 0xa76f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77a as libc::c_int,
                               rangeEnd: 0xa77c as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77f as libc::c_int,
                               rangeEnd: 0xa787 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa78c as libc::c_int,
                               rangeEnd: 0xa791 as libc::c_int,
                               step: 5 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa793 as libc::c_int,
                               rangeEnd: 0xa793 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa794 as libc::c_int,
                               rangeEnd: 0xa794 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 48 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa797 as libc::c_int,
                               rangeEnd: 0xa7a9 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b5 as libc::c_int,
                               rangeEnd: 0xa7bf as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c3 as libc::c_int,
                               rangeEnd: 0xa7c3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(1 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xab53 as libc::c_int,
                               rangeEnd: 0xab53 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(928 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xab70 as libc::c_int,
                               rangeEnd: 0xabbf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(38864 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xff41 as libc::c_int,
                               rangeEnd: 0xff5a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10428 as libc::c_int,
                               rangeEnd: 0x1044f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(40 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x104d8 as libc::c_int,
                               rangeEnd: 0x104fb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(40 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10cc0 as libc::c_int,
                               rangeEnd: 0x10cf2 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(64 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x118c0 as libc::c_int,
                               rangeEnd: 0x118df as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x16e60 as libc::c_int,
                               rangeEnd: 0x16e7f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(32 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e922 as libc::c_int,
                               rangeEnd: 0x1e943 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(34 as libc::c_int),};
             init
         }];
    #[c2rust::src_loc = "364:30"]
    pub static mut combining: [interval; 280] =
        [{
             let mut init =
                 interval{first: 0x300 as libc::c_int as libc::c_long,
                          last: 0x36f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x483 as libc::c_int as libc::c_long,
                          last: 0x489 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x591 as libc::c_int as libc::c_long,
                          last: 0x5bd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x5bf as libc::c_int as libc::c_long,
                          last: 0x5bf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x5c1 as libc::c_int as libc::c_long,
                          last: 0x5c2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x5c4 as libc::c_int as libc::c_long,
                          last: 0x5c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x5c7 as libc::c_int as libc::c_long,
                          last: 0x5c7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x610 as libc::c_int as libc::c_long,
                          last: 0x61a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x64b as libc::c_int as libc::c_long,
                          last: 0x65f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x670 as libc::c_int as libc::c_long,
                          last: 0x670 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x6d6 as libc::c_int as libc::c_long,
                          last: 0x6dc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x6df as libc::c_int as libc::c_long,
                          last: 0x6e4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x6e7 as libc::c_int as libc::c_long,
                          last: 0x6e8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x6ea as libc::c_int as libc::c_long,
                          last: 0x6ed as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x711 as libc::c_int as libc::c_long,
                          last: 0x711 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x730 as libc::c_int as libc::c_long,
                          last: 0x74a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x7a6 as libc::c_int as libc::c_long,
                          last: 0x7b0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x7eb as libc::c_int as libc::c_long,
                          last: 0x7f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x7fd as libc::c_int as libc::c_long,
                          last: 0x7fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x816 as libc::c_int as libc::c_long,
                          last: 0x819 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x81b as libc::c_int as libc::c_long,
                          last: 0x823 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x825 as libc::c_int as libc::c_long,
                          last: 0x827 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x829 as libc::c_int as libc::c_long,
                          last: 0x82d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x859 as libc::c_int as libc::c_long,
                          last: 0x85b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x8d3 as libc::c_int as libc::c_long,
                          last: 0x8e1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x8e3 as libc::c_int as libc::c_long,
                          last: 0x903 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x93a as libc::c_int as libc::c_long,
                          last: 0x93c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x93e as libc::c_int as libc::c_long,
                          last: 0x94f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x951 as libc::c_int as libc::c_long,
                          last: 0x957 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x962 as libc::c_int as libc::c_long,
                          last: 0x963 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x981 as libc::c_int as libc::c_long,
                          last: 0x983 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9bc as libc::c_int as libc::c_long,
                          last: 0x9bc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9be as libc::c_int as libc::c_long,
                          last: 0x9c4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9c7 as libc::c_int as libc::c_long,
                          last: 0x9c8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9cb as libc::c_int as libc::c_long,
                          last: 0x9cd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9d7 as libc::c_int as libc::c_long,
                          last: 0x9d7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9e2 as libc::c_int as libc::c_long,
                          last: 0x9e3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x9fe as libc::c_int as libc::c_long,
                          last: 0x9fe as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa01 as libc::c_int as libc::c_long,
                          last: 0xa03 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa3c as libc::c_int as libc::c_long,
                          last: 0xa3c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa3e as libc::c_int as libc::c_long,
                          last: 0xa42 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa47 as libc::c_int as libc::c_long,
                          last: 0xa48 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa4b as libc::c_int as libc::c_long,
                          last: 0xa4d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa51 as libc::c_int as libc::c_long,
                          last: 0xa51 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa70 as libc::c_int as libc::c_long,
                          last: 0xa71 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa75 as libc::c_int as libc::c_long,
                          last: 0xa75 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa81 as libc::c_int as libc::c_long,
                          last: 0xa83 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xabc as libc::c_int as libc::c_long,
                          last: 0xabc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xabe as libc::c_int as libc::c_long,
                          last: 0xac5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xac7 as libc::c_int as libc::c_long,
                          last: 0xac9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xacb as libc::c_int as libc::c_long,
                          last: 0xacd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xae2 as libc::c_int as libc::c_long,
                          last: 0xae3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xafa as libc::c_int as libc::c_long,
                          last: 0xaff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb01 as libc::c_int as libc::c_long,
                          last: 0xb03 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb3c as libc::c_int as libc::c_long,
                          last: 0xb3c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb3e as libc::c_int as libc::c_long,
                          last: 0xb44 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb47 as libc::c_int as libc::c_long,
                          last: 0xb48 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb4b as libc::c_int as libc::c_long,
                          last: 0xb4d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb56 as libc::c_int as libc::c_long,
                          last: 0xb57 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb62 as libc::c_int as libc::c_long,
                          last: 0xb63 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb82 as libc::c_int as libc::c_long,
                          last: 0xb82 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xbbe as libc::c_int as libc::c_long,
                          last: 0xbc2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xbc6 as libc::c_int as libc::c_long,
                          last: 0xbc8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xbca as libc::c_int as libc::c_long,
                          last: 0xbcd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xbd7 as libc::c_int as libc::c_long,
                          last: 0xbd7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc00 as libc::c_int as libc::c_long,
                          last: 0xc04 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc3e as libc::c_int as libc::c_long,
                          last: 0xc44 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc46 as libc::c_int as libc::c_long,
                          last: 0xc48 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc4a as libc::c_int as libc::c_long,
                          last: 0xc4d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc55 as libc::c_int as libc::c_long,
                          last: 0xc56 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc62 as libc::c_int as libc::c_long,
                          last: 0xc63 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc81 as libc::c_int as libc::c_long,
                          last: 0xc83 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xcbc as libc::c_int as libc::c_long,
                          last: 0xcbc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xcbe as libc::c_int as libc::c_long,
                          last: 0xcc4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xcc6 as libc::c_int as libc::c_long,
                          last: 0xcc8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xcca as libc::c_int as libc::c_long,
                          last: 0xccd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xcd5 as libc::c_int as libc::c_long,
                          last: 0xcd6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xce2 as libc::c_int as libc::c_long,
                          last: 0xce3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd00 as libc::c_int as libc::c_long,
                          last: 0xd03 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd3b as libc::c_int as libc::c_long,
                          last: 0xd3c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd3e as libc::c_int as libc::c_long,
                          last: 0xd44 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd46 as libc::c_int as libc::c_long,
                          last: 0xd48 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd4a as libc::c_int as libc::c_long,
                          last: 0xd4d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd57 as libc::c_int as libc::c_long,
                          last: 0xd57 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd62 as libc::c_int as libc::c_long,
                          last: 0xd63 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd82 as libc::c_int as libc::c_long,
                          last: 0xd83 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xdca as libc::c_int as libc::c_long,
                          last: 0xdca as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xdcf as libc::c_int as libc::c_long,
                          last: 0xdd4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xdd6 as libc::c_int as libc::c_long,
                          last: 0xdd6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xdd8 as libc::c_int as libc::c_long,
                          last: 0xddf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xdf2 as libc::c_int as libc::c_long,
                          last: 0xdf3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe31 as libc::c_int as libc::c_long,
                          last: 0xe31 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe34 as libc::c_int as libc::c_long,
                          last: 0xe3a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe47 as libc::c_int as libc::c_long,
                          last: 0xe4e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xeb1 as libc::c_int as libc::c_long,
                          last: 0xeb1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xeb4 as libc::c_int as libc::c_long,
                          last: 0xebc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xec8 as libc::c_int as libc::c_long,
                          last: 0xecd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf18 as libc::c_int as libc::c_long,
                          last: 0xf19 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf35 as libc::c_int as libc::c_long,
                          last: 0xf35 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf37 as libc::c_int as libc::c_long,
                          last: 0xf37 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf39 as libc::c_int as libc::c_long,
                          last: 0xf39 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf3e as libc::c_int as libc::c_long,
                          last: 0xf3f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf71 as libc::c_int as libc::c_long,
                          last: 0xf84 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf86 as libc::c_int as libc::c_long,
                          last: 0xf87 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf8d as libc::c_int as libc::c_long,
                          last: 0xf97 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf99 as libc::c_int as libc::c_long,
                          last: 0xfbc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfc6 as libc::c_int as libc::c_long,
                          last: 0xfc6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x102b as libc::c_int as libc::c_long,
                          last: 0x103e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1056 as libc::c_int as libc::c_long,
                          last: 0x1059 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x105e as libc::c_int as libc::c_long,
                          last: 0x1060 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1062 as libc::c_int as libc::c_long,
                          last: 0x1064 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1067 as libc::c_int as libc::c_long,
                          last: 0x106d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1071 as libc::c_int as libc::c_long,
                          last: 0x1074 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1082 as libc::c_int as libc::c_long,
                          last: 0x108d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x108f as libc::c_int as libc::c_long,
                          last: 0x108f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x109a as libc::c_int as libc::c_long,
                          last: 0x109d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x135d as libc::c_int as libc::c_long,
                          last: 0x135f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1712 as libc::c_int as libc::c_long,
                          last: 0x1714 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1732 as libc::c_int as libc::c_long,
                          last: 0x1734 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1752 as libc::c_int as libc::c_long,
                          last: 0x1753 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1772 as libc::c_int as libc::c_long,
                          last: 0x1773 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x17b4 as libc::c_int as libc::c_long,
                          last: 0x17d3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x17dd as libc::c_int as libc::c_long,
                          last: 0x17dd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x180b as libc::c_int as libc::c_long,
                          last: 0x180d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1885 as libc::c_int as libc::c_long,
                          last: 0x1886 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x18a9 as libc::c_int as libc::c_long,
                          last: 0x18a9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1920 as libc::c_int as libc::c_long,
                          last: 0x192b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1930 as libc::c_int as libc::c_long,
                          last: 0x193b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1a17 as libc::c_int as libc::c_long,
                          last: 0x1a1b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1a55 as libc::c_int as libc::c_long,
                          last: 0x1a5e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1a60 as libc::c_int as libc::c_long,
                          last: 0x1a7c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1a7f as libc::c_int as libc::c_long,
                          last: 0x1a7f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1ab0 as libc::c_int as libc::c_long,
                          last: 0x1abe as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b00 as libc::c_int as libc::c_long,
                          last: 0x1b04 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b34 as libc::c_int as libc::c_long,
                          last: 0x1b44 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b6b as libc::c_int as libc::c_long,
                          last: 0x1b73 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b80 as libc::c_int as libc::c_long,
                          last: 0x1b82 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1ba1 as libc::c_int as libc::c_long,
                          last: 0x1bad as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1be6 as libc::c_int as libc::c_long,
                          last: 0x1bf3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1c24 as libc::c_int as libc::c_long,
                          last: 0x1c37 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1cd0 as libc::c_int as libc::c_long,
                          last: 0x1cd2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1cd4 as libc::c_int as libc::c_long,
                          last: 0x1ce8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1ced as libc::c_int as libc::c_long,
                          last: 0x1ced as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1cf4 as libc::c_int as libc::c_long,
                          last: 0x1cf4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1cf7 as libc::c_int as libc::c_long,
                          last: 0x1cf9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1dc0 as libc::c_int as libc::c_long,
                          last: 0x1df9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1dfb as libc::c_int as libc::c_long,
                          last: 0x1dff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x20d0 as libc::c_int as libc::c_long,
                          last: 0x20f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2cef as libc::c_int as libc::c_long,
                          last: 0x2cf1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2d7f as libc::c_int as libc::c_long,
                          last: 0x2d7f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2de0 as libc::c_int as libc::c_long,
                          last: 0x2dff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x302a as libc::c_int as libc::c_long,
                          last: 0x302f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3099 as libc::c_int as libc::c_long,
                          last: 0x309a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa66f as libc::c_int as libc::c_long,
                          last: 0xa672 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa674 as libc::c_int as libc::c_long,
                          last: 0xa67d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa69e as libc::c_int as libc::c_long,
                          last: 0xa69f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa6f0 as libc::c_int as libc::c_long,
                          last: 0xa6f1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa802 as libc::c_int as libc::c_long,
                          last: 0xa802 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa806 as libc::c_int as libc::c_long,
                          last: 0xa806 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa80b as libc::c_int as libc::c_long,
                          last: 0xa80b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa823 as libc::c_int as libc::c_long,
                          last: 0xa827 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa880 as libc::c_int as libc::c_long,
                          last: 0xa881 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa8b4 as libc::c_int as libc::c_long,
                          last: 0xa8c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa8e0 as libc::c_int as libc::c_long,
                          last: 0xa8f1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa8ff as libc::c_int as libc::c_long,
                          last: 0xa8ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa926 as libc::c_int as libc::c_long,
                          last: 0xa92d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa947 as libc::c_int as libc::c_long,
                          last: 0xa953 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa980 as libc::c_int as libc::c_long,
                          last: 0xa983 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa9b3 as libc::c_int as libc::c_long,
                          last: 0xa9c0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa9e5 as libc::c_int as libc::c_long,
                          last: 0xa9e5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaa29 as libc::c_int as libc::c_long,
                          last: 0xaa36 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaa43 as libc::c_int as libc::c_long,
                          last: 0xaa43 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaa4c as libc::c_int as libc::c_long,
                          last: 0xaa4d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaa7b as libc::c_int as libc::c_long,
                          last: 0xaa7d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaab0 as libc::c_int as libc::c_long,
                          last: 0xaab0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaab2 as libc::c_int as libc::c_long,
                          last: 0xaab4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaab7 as libc::c_int as libc::c_long,
                          last: 0xaab8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaabe as libc::c_int as libc::c_long,
                          last: 0xaabf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaac1 as libc::c_int as libc::c_long,
                          last: 0xaac1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaaeb as libc::c_int as libc::c_long,
                          last: 0xaaef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaaf5 as libc::c_int as libc::c_long,
                          last: 0xaaf6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xabe3 as libc::c_int as libc::c_long,
                          last: 0xabea as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xabec as libc::c_int as libc::c_long,
                          last: 0xabed as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfb1e as libc::c_int as libc::c_long,
                          last: 0xfb1e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe00 as libc::c_int as libc::c_long,
                          last: 0xfe0f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe20 as libc::c_int as libc::c_long,
                          last: 0xfe2f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x101fd as libc::c_int as libc::c_long,
                          last: 0x101fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x102e0 as libc::c_int as libc::c_long,
                          last: 0x102e0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10376 as libc::c_int as libc::c_long,
                          last: 0x1037a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10a01 as libc::c_int as libc::c_long,
                          last: 0x10a03 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10a05 as libc::c_int as libc::c_long,
                          last: 0x10a06 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10a0c as libc::c_int as libc::c_long,
                          last: 0x10a0f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10a38 as libc::c_int as libc::c_long,
                          last: 0x10a3a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10a3f as libc::c_int as libc::c_long,
                          last: 0x10a3f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10ae5 as libc::c_int as libc::c_long,
                          last: 0x10ae6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10d24 as libc::c_int as libc::c_long,
                          last: 0x10d27 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x10f46 as libc::c_int as libc::c_long,
                          last: 0x10f50 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11000 as libc::c_int as libc::c_long,
                          last: 0x11002 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11038 as libc::c_int as libc::c_long,
                          last: 0x11046 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1107f as libc::c_int as libc::c_long,
                          last: 0x11082 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x110b0 as libc::c_int as libc::c_long,
                          last: 0x110ba as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11100 as libc::c_int as libc::c_long,
                          last: 0x11102 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11127 as libc::c_int as libc::c_long,
                          last: 0x11134 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11145 as libc::c_int as libc::c_long,
                          last: 0x11146 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11173 as libc::c_int as libc::c_long,
                          last: 0x11173 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11180 as libc::c_int as libc::c_long,
                          last: 0x11182 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x111b3 as libc::c_int as libc::c_long,
                          last: 0x111c0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x111c9 as libc::c_int as libc::c_long,
                          last: 0x111cc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1122c as libc::c_int as libc::c_long,
                          last: 0x11237 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1123e as libc::c_int as libc::c_long,
                          last: 0x1123e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x112df as libc::c_int as libc::c_long,
                          last: 0x112ea as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11300 as libc::c_int as libc::c_long,
                          last: 0x11303 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1133b as libc::c_int as libc::c_long,
                          last: 0x1133c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1133e as libc::c_int as libc::c_long,
                          last: 0x11344 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11347 as libc::c_int as libc::c_long,
                          last: 0x11348 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1134b as libc::c_int as libc::c_long,
                          last: 0x1134d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11357 as libc::c_int as libc::c_long,
                          last: 0x11357 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11362 as libc::c_int as libc::c_long,
                          last: 0x11363 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11366 as libc::c_int as libc::c_long,
                          last: 0x1136c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11370 as libc::c_int as libc::c_long,
                          last: 0x11374 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11435 as libc::c_int as libc::c_long,
                          last: 0x11446 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1145e as libc::c_int as libc::c_long,
                          last: 0x1145e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x114b0 as libc::c_int as libc::c_long,
                          last: 0x114c3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x115af as libc::c_int as libc::c_long,
                          last: 0x115b5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x115b8 as libc::c_int as libc::c_long,
                          last: 0x115c0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x115dc as libc::c_int as libc::c_long,
                          last: 0x115dd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11630 as libc::c_int as libc::c_long,
                          last: 0x11640 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x116ab as libc::c_int as libc::c_long,
                          last: 0x116b7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1171d as libc::c_int as libc::c_long,
                          last: 0x1172b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1182c as libc::c_int as libc::c_long,
                          last: 0x1183a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x119d1 as libc::c_int as libc::c_long,
                          last: 0x119d7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x119da as libc::c_int as libc::c_long,
                          last: 0x119e0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x119e4 as libc::c_int as libc::c_long,
                          last: 0x119e4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a01 as libc::c_int as libc::c_long,
                          last: 0x11a0a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a33 as libc::c_int as libc::c_long,
                          last: 0x11a39 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a3b as libc::c_int as libc::c_long,
                          last: 0x11a3e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a47 as libc::c_int as libc::c_long,
                          last: 0x11a47 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a51 as libc::c_int as libc::c_long,
                          last: 0x11a5b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11a8a as libc::c_int as libc::c_long,
                          last: 0x11a99 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11c2f as libc::c_int as libc::c_long,
                          last: 0x11c36 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11c38 as libc::c_int as libc::c_long,
                          last: 0x11c3f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11c92 as libc::c_int as libc::c_long,
                          last: 0x11ca7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11ca9 as libc::c_int as libc::c_long,
                          last: 0x11cb6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d31 as libc::c_int as libc::c_long,
                          last: 0x11d36 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d3a as libc::c_int as libc::c_long,
                          last: 0x11d3a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d3c as libc::c_int as libc::c_long,
                          last: 0x11d3d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d3f as libc::c_int as libc::c_long,
                          last: 0x11d45 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d47 as libc::c_int as libc::c_long,
                          last: 0x11d47 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d8a as libc::c_int as libc::c_long,
                          last: 0x11d8e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d90 as libc::c_int as libc::c_long,
                          last: 0x11d91 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11d93 as libc::c_int as libc::c_long,
                          last: 0x11d97 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11ef3 as libc::c_int as libc::c_long,
                          last: 0x11ef6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16af0 as libc::c_int as libc::c_long,
                          last: 0x16af4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16b30 as libc::c_int as libc::c_long,
                          last: 0x16b36 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16f4f as libc::c_int as libc::c_long,
                          last: 0x16f4f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16f51 as libc::c_int as libc::c_long,
                          last: 0x16f87 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16f8f as libc::c_int as libc::c_long,
                          last: 0x16f92 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1bc9d as libc::c_int as libc::c_long,
                          last: 0x1bc9e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d165 as libc::c_int as libc::c_long,
                          last: 0x1d169 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d16d as libc::c_int as libc::c_long,
                          last: 0x1d172 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d17b as libc::c_int as libc::c_long,
                          last: 0x1d182 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d185 as libc::c_int as libc::c_long,
                          last: 0x1d18b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d1aa as libc::c_int as libc::c_long,
                          last: 0x1d1ad as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d242 as libc::c_int as libc::c_long,
                          last: 0x1d244 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da00 as libc::c_int as libc::c_long,
                          last: 0x1da36 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da3b as libc::c_int as libc::c_long,
                          last: 0x1da6c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da75 as libc::c_int as libc::c_long,
                          last: 0x1da75 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da84 as libc::c_int as libc::c_long,
                          last: 0x1da84 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da9b as libc::c_int as libc::c_long,
                          last: 0x1da9f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1daa1 as libc::c_int as libc::c_long,
                          last: 0x1daaf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e000 as libc::c_int as libc::c_long,
                          last: 0x1e006 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e008 as libc::c_int as libc::c_long,
                          last: 0x1e018 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e01b as libc::c_int as libc::c_long,
                          last: 0x1e021 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e023 as libc::c_int as libc::c_long,
                          last: 0x1e024 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e026 as libc::c_int as libc::c_long,
                          last: 0x1e02a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e130 as libc::c_int as libc::c_long,
                          last: 0x1e136 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e2ec as libc::c_int as libc::c_long,
                          last: 0x1e2ef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e8d0 as libc::c_int as libc::c_long,
                          last: 0x1e8d6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1e944 as libc::c_int as libc::c_long,
                          last: 0x1e94a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe0100 as libc::c_int as libc::c_long,
                          last: 0xe01ef as libc::c_int as libc::c_long,};
             init
         }];
    #[c2rust::src_loc = "646:28"]
    pub static mut foldCase: [convertStruct; 192] =
        [{
             let mut init =
                 convertStruct{rangeStart: 0x41 as libc::c_int,
                               rangeEnd: 0x5a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xb5 as libc::c_int,
                               rangeEnd: 0xb5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 775 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xc0 as libc::c_int,
                               rangeEnd: 0xd6 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xd8 as libc::c_int,
                               rangeEnd: 0xde as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x100 as libc::c_int,
                               rangeEnd: 0x12e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x132 as libc::c_int,
                               rangeEnd: 0x136 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x139 as libc::c_int,
                               rangeEnd: 0x147 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x14a as libc::c_int,
                               rangeEnd: 0x176 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x178 as libc::c_int,
                               rangeEnd: 0x178 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(121 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x179 as libc::c_int,
                               rangeEnd: 0x17d as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x17f as libc::c_int,
                               rangeEnd: 0x17f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(268 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x181 as libc::c_int,
                               rangeEnd: 0x181 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 210 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x182 as libc::c_int,
                               rangeEnd: 0x184 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x186 as libc::c_int,
                               rangeEnd: 0x186 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 206 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x187 as libc::c_int,
                               rangeEnd: 0x187 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x189 as libc::c_int,
                               rangeEnd: 0x18a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 205 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18b as libc::c_int,
                               rangeEnd: 0x18b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18e as libc::c_int,
                               rangeEnd: 0x18e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 79 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x18f as libc::c_int,
                               rangeEnd: 0x18f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 202 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x190 as libc::c_int,
                               rangeEnd: 0x190 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 203 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x191 as libc::c_int,
                               rangeEnd: 0x191 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x193 as libc::c_int,
                               rangeEnd: 0x193 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 205 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x194 as libc::c_int,
                               rangeEnd: 0x194 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 207 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x196 as libc::c_int,
                               rangeEnd: 0x196 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 211 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x197 as libc::c_int,
                               rangeEnd: 0x197 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 209 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x198 as libc::c_int,
                               rangeEnd: 0x198 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19c as libc::c_int,
                               rangeEnd: 0x19c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 211 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19d as libc::c_int,
                               rangeEnd: 0x19d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 213 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x19f as libc::c_int,
                               rangeEnd: 0x19f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 214 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a0 as libc::c_int,
                               rangeEnd: 0x1a4 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a6 as libc::c_int,
                               rangeEnd: 0x1a6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a7 as libc::c_int,
                               rangeEnd: 0x1a7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1a9 as libc::c_int,
                               rangeEnd: 0x1a9 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ac as libc::c_int,
                               rangeEnd: 0x1ac as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ae as libc::c_int,
                               rangeEnd: 0x1ae as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 218 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1af as libc::c_int,
                               rangeEnd: 0x1af as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b1 as libc::c_int,
                               rangeEnd: 0x1b2 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 217 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b3 as libc::c_int,
                               rangeEnd: 0x1b5 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b7 as libc::c_int,
                               rangeEnd: 0x1b7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 219 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1b8 as libc::c_int,
                               rangeEnd: 0x1bc as libc::c_int,
                               step: 4 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c4 as libc::c_int,
                               rangeEnd: 0x1c4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c5 as libc::c_int,
                               rangeEnd: 0x1c5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c7 as libc::c_int,
                               rangeEnd: 0x1c7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c8 as libc::c_int,
                               rangeEnd: 0x1c8 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ca as libc::c_int,
                               rangeEnd: 0x1ca as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cb as libc::c_int,
                               rangeEnd: 0x1db as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1de as libc::c_int,
                               rangeEnd: 0x1ee as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f1 as libc::c_int,
                               rangeEnd: 0x1f1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 2 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f2 as libc::c_int,
                               rangeEnd: 0x1f4 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f6 as libc::c_int,
                               rangeEnd: 0x1f6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(97 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f7 as libc::c_int,
                               rangeEnd: 0x1f7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(56 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f8 as libc::c_int,
                               rangeEnd: 0x21e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x220 as libc::c_int,
                               rangeEnd: 0x220 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(130 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x222 as libc::c_int,
                               rangeEnd: 0x232 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23a as libc::c_int,
                               rangeEnd: 0x23a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10795 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23b as libc::c_int,
                               rangeEnd: 0x23b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23d as libc::c_int,
                               rangeEnd: 0x23d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(163 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x23e as libc::c_int,
                               rangeEnd: 0x23e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 10792 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x241 as libc::c_int,
                               rangeEnd: 0x241 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x243 as libc::c_int,
                               rangeEnd: 0x243 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(195 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x244 as libc::c_int,
                               rangeEnd: 0x244 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 69 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x245 as libc::c_int,
                               rangeEnd: 0x245 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 71 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x246 as libc::c_int,
                               rangeEnd: 0x24e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x345 as libc::c_int,
                               rangeEnd: 0x345 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 116 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x370 as libc::c_int,
                               rangeEnd: 0x372 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x376 as libc::c_int,
                               rangeEnd: 0x376 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x37f as libc::c_int,
                               rangeEnd: 0x37f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 116 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x386 as libc::c_int,
                               rangeEnd: 0x386 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 38 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x388 as libc::c_int,
                               rangeEnd: 0x38a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 37 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x38c as libc::c_int,
                               rangeEnd: 0x38c as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 64 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x38e as libc::c_int,
                               rangeEnd: 0x38f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 63 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x391 as libc::c_int,
                               rangeEnd: 0x3a1 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3a3 as libc::c_int,
                               rangeEnd: 0x3ab as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3c2 as libc::c_int,
                               rangeEnd: 0x3c2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3cf as libc::c_int,
                               rangeEnd: 0x3cf as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 8 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d0 as libc::c_int,
                               rangeEnd: 0x3d0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(30 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d1 as libc::c_int,
                               rangeEnd: 0x3d1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(25 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d5 as libc::c_int,
                               rangeEnd: 0x3d5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(15 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d6 as libc::c_int,
                               rangeEnd: 0x3d6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(22 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3d8 as libc::c_int,
                               rangeEnd: 0x3ee as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f0 as libc::c_int,
                               rangeEnd: 0x3f0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(54 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f1 as libc::c_int,
                               rangeEnd: 0x3f1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(48 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f4 as libc::c_int,
                               rangeEnd: 0x3f4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(60 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f5 as libc::c_int,
                               rangeEnd: 0x3f5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(64 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f7 as libc::c_int,
                               rangeEnd: 0x3f7 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3f9 as libc::c_int,
                               rangeEnd: 0x3f9 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3fa as libc::c_int,
                               rangeEnd: 0x3fa as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x3fd as libc::c_int,
                               rangeEnd: 0x3ff as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(130 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x400 as libc::c_int,
                               rangeEnd: 0x40f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 80 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x410 as libc::c_int,
                               rangeEnd: 0x42f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x460 as libc::c_int,
                               rangeEnd: 0x480 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x48a as libc::c_int,
                               rangeEnd: 0x4be as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4c0 as libc::c_int,
                               rangeEnd: 0x4c0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 15 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4c1 as libc::c_int,
                               rangeEnd: 0x4cd as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x4d0 as libc::c_int,
                               rangeEnd: 0x52e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x531 as libc::c_int,
                               rangeEnd: 0x556 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 48 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10a0 as libc::c_int,
                               rangeEnd: 0x10c5 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 7264 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10c7 as libc::c_int,
                               rangeEnd: 0x10cd as libc::c_int,
                               step: 6 as libc::c_int,
                               offset: 7264 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x13f8 as libc::c_int,
                               rangeEnd: 0x13fd as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c80 as libc::c_int,
                               rangeEnd: 0x1c80 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6222 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c81 as libc::c_int,
                               rangeEnd: 0x1c81 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6221 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c82 as libc::c_int,
                               rangeEnd: 0x1c82 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6212 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c83 as libc::c_int,
                               rangeEnd: 0x1c84 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(6210 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c85 as libc::c_int,
                               rangeEnd: 0x1c85 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6211 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c86 as libc::c_int,
                               rangeEnd: 0x1c86 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6204 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c87 as libc::c_int,
                               rangeEnd: 0x1c87 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(6180 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c88 as libc::c_int,
                               rangeEnd: 0x1c88 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 35267 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1c90 as libc::c_int,
                               rangeEnd: 0x1cba as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(3008 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1cbd as libc::c_int,
                               rangeEnd: 0x1cbf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(3008 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e00 as libc::c_int,
                               rangeEnd: 0x1e94 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e9b as libc::c_int,
                               rangeEnd: 0x1e9b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(58 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e9e as libc::c_int,
                               rangeEnd: 0x1e9e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7615 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ea0 as libc::c_int,
                               rangeEnd: 0x1efe as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f08 as libc::c_int,
                               rangeEnd: 0x1f0f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f18 as libc::c_int,
                               rangeEnd: 0x1f1d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f28 as libc::c_int,
                               rangeEnd: 0x1f2f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f38 as libc::c_int,
                               rangeEnd: 0x1f3f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f48 as libc::c_int,
                               rangeEnd: 0x1f4d as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f59 as libc::c_int,
                               rangeEnd: 0x1f5f as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f68 as libc::c_int,
                               rangeEnd: 0x1f6f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f88 as libc::c_int,
                               rangeEnd: 0x1f8f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1f98 as libc::c_int,
                               rangeEnd: 0x1f9f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fa8 as libc::c_int,
                               rangeEnd: 0x1faf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fb8 as libc::c_int,
                               rangeEnd: 0x1fb9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fba as libc::c_int,
                               rangeEnd: 0x1fbb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(74 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fbc as libc::c_int,
                               rangeEnd: 0x1fbc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fbe as libc::c_int,
                               rangeEnd: 0x1fbe as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7173 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fc8 as libc::c_int,
                               rangeEnd: 0x1fcb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(86 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fcc as libc::c_int,
                               rangeEnd: 0x1fcc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fd8 as libc::c_int,
                               rangeEnd: 0x1fd9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fda as libc::c_int,
                               rangeEnd: 0x1fdb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(100 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fe8 as libc::c_int,
                               rangeEnd: 0x1fe9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(8 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fea as libc::c_int,
                               rangeEnd: 0x1feb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(112 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1fec as libc::c_int,
                               rangeEnd: 0x1fec as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ff8 as libc::c_int,
                               rangeEnd: 0x1ff9 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(128 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ffa as libc::c_int,
                               rangeEnd: 0x1ffb as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(126 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1ffc as libc::c_int,
                               rangeEnd: 0x1ffc as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(9 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2126 as libc::c_int,
                               rangeEnd: 0x2126 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(7517 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x212a as libc::c_int,
                               rangeEnd: 0x212a as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(8383 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x212b as libc::c_int,
                               rangeEnd: 0x212b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(8262 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2132 as libc::c_int,
                               rangeEnd: 0x2132 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 28 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2160 as libc::c_int,
                               rangeEnd: 0x216f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 16 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2183 as libc::c_int,
                               rangeEnd: 0x2183 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x24b6 as libc::c_int,
                               rangeEnd: 0x24cf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 26 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c00 as libc::c_int,
                               rangeEnd: 0x2c2e as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 48 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c60 as libc::c_int,
                               rangeEnd: 0x2c60 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c62 as libc::c_int,
                               rangeEnd: 0x2c62 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10743 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c63 as libc::c_int,
                               rangeEnd: 0x2c63 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(3814 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c64 as libc::c_int,
                               rangeEnd: 0x2c64 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10727 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c67 as libc::c_int,
                               rangeEnd: 0x2c6b as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6d as libc::c_int,
                               rangeEnd: 0x2c6d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10780 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6e as libc::c_int,
                               rangeEnd: 0x2c6e as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10749 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c6f as libc::c_int,
                               rangeEnd: 0x2c6f as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10783 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c70 as libc::c_int,
                               rangeEnd: 0x2c70 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(10782 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c72 as libc::c_int,
                               rangeEnd: 0x2c75 as libc::c_int,
                               step: 3 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c7e as libc::c_int,
                               rangeEnd: 0x2c7f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(10815 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2c80 as libc::c_int,
                               rangeEnd: 0x2ce2 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2ceb as libc::c_int,
                               rangeEnd: 0x2ced as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x2cf2 as libc::c_int,
                               rangeEnd: 0xa640 as libc::c_int,
                               step: 31054 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa642 as libc::c_int,
                               rangeEnd: 0xa66c as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa680 as libc::c_int,
                               rangeEnd: 0xa69a as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa722 as libc::c_int,
                               rangeEnd: 0xa72e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa732 as libc::c_int,
                               rangeEnd: 0xa76e as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa779 as libc::c_int,
                               rangeEnd: 0xa77b as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77d as libc::c_int,
                               rangeEnd: 0xa77d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(35332 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa77e as libc::c_int,
                               rangeEnd: 0xa786 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa78b as libc::c_int,
                               rangeEnd: 0xa78b as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa78d as libc::c_int,
                               rangeEnd: 0xa78d as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42280 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa790 as libc::c_int,
                               rangeEnd: 0xa792 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa796 as libc::c_int,
                               rangeEnd: 0xa7a8 as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7aa as libc::c_int,
                               rangeEnd: 0xa7aa as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42308 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ab as libc::c_int,
                               rangeEnd: 0xa7ab as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42319 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ac as libc::c_int,
                               rangeEnd: 0xa7ac as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42315 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ad as libc::c_int,
                               rangeEnd: 0xa7ad as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42305 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7ae as libc::c_int,
                               rangeEnd: 0xa7ae as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42308 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b0 as libc::c_int,
                               rangeEnd: 0xa7b0 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42258 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b1 as libc::c_int,
                               rangeEnd: 0xa7b1 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42282 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b2 as libc::c_int,
                               rangeEnd: 0xa7b2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42261 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b3 as libc::c_int,
                               rangeEnd: 0xa7b3 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 928 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7b4 as libc::c_int,
                               rangeEnd: 0xa7be as libc::c_int,
                               step: 2 as libc::c_int,
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c2 as libc::c_int,
                               rangeEnd: 0xa7c2 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: 1 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c4 as libc::c_int,
                               rangeEnd: 0xa7c4 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(48 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c5 as libc::c_int,
                               rangeEnd: 0xa7c5 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(42307 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xa7c6 as libc::c_int,
                               rangeEnd: 0xa7c6 as libc::c_int,
                               step: -(1 as libc::c_int),
                               offset: -(35384 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xab70 as libc::c_int,
                               rangeEnd: 0xabbf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: -(38864 as libc::c_int),};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0xff21 as libc::c_int,
                               rangeEnd: 0xff3a as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10400 as libc::c_int,
                               rangeEnd: 0x10427 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 40 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x104b0 as libc::c_int,
                               rangeEnd: 0x104d3 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 40 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x10c80 as libc::c_int,
                               rangeEnd: 0x10cb2 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 64 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x118a0 as libc::c_int,
                               rangeEnd: 0x118bf as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x16e40 as libc::c_int,
                               rangeEnd: 0x16e5f as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 32 as libc::c_int,};
             init
         },
         {
             let mut init =
                 convertStruct{rangeStart: 0x1e900 as libc::c_int,
                               rangeEnd: 0x1e921 as libc::c_int,
                               step: 1 as libc::c_int,
                               offset: 34 as libc::c_int,};
             init
         }];
    #[c2rust::src_loc = "840:30"]
    pub static mut doublewidth: [interval; 113] =
        [{
             let mut init =
                 interval{first: 0x1100 as libc::c_int as libc::c_long,
                          last: 0x115f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x231a as libc::c_int as libc::c_long,
                          last: 0x231b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2329 as libc::c_int as libc::c_long,
                          last: 0x232a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23e9 as libc::c_int as libc::c_long,
                          last: 0x23ec as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23f0 as libc::c_int as libc::c_long,
                          last: 0x23f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23f3 as libc::c_int as libc::c_long,
                          last: 0x23f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25fd as libc::c_int as libc::c_long,
                          last: 0x25fe as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2614 as libc::c_int as libc::c_long,
                          last: 0x2615 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2648 as libc::c_int as libc::c_long,
                          last: 0x2653 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x267f as libc::c_int as libc::c_long,
                          last: 0x267f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2693 as libc::c_int as libc::c_long,
                          last: 0x2693 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26a1 as libc::c_int as libc::c_long,
                          last: 0x26a1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26aa as libc::c_int as libc::c_long,
                          last: 0x26ab as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26bd as libc::c_int as libc::c_long,
                          last: 0x26be as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26c4 as libc::c_int as libc::c_long,
                          last: 0x26c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26ce as libc::c_int as libc::c_long,
                          last: 0x26ce as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26d4 as libc::c_int as libc::c_long,
                          last: 0x26d4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26ea as libc::c_int as libc::c_long,
                          last: 0x26ea as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f2 as libc::c_int as libc::c_long,
                          last: 0x26f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f5 as libc::c_int as libc::c_long,
                          last: 0x26f5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26fa as libc::c_int as libc::c_long,
                          last: 0x26fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26fd as libc::c_int as libc::c_long,
                          last: 0x26fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2705 as libc::c_int as libc::c_long,
                          last: 0x2705 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x270a as libc::c_int as libc::c_long,
                          last: 0x270b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2728 as libc::c_int as libc::c_long,
                          last: 0x2728 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x274c as libc::c_int as libc::c_long,
                          last: 0x274c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x274e as libc::c_int as libc::c_long,
                          last: 0x274e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2753 as libc::c_int as libc::c_long,
                          last: 0x2755 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2757 as libc::c_int as libc::c_long,
                          last: 0x2757 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2795 as libc::c_int as libc::c_long,
                          last: 0x2797 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x27b0 as libc::c_int as libc::c_long,
                          last: 0x27b0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x27bf as libc::c_int as libc::c_long,
                          last: 0x27bf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b1b as libc::c_int as libc::c_long,
                          last: 0x2b1c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b50 as libc::c_int as libc::c_long,
                          last: 0x2b50 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b55 as libc::c_int as libc::c_long,
                          last: 0x2b55 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2e80 as libc::c_int as libc::c_long,
                          last: 0x2e99 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2e9b as libc::c_int as libc::c_long,
                          last: 0x2ef3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2f00 as libc::c_int as libc::c_long,
                          last: 0x2fd5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2ff0 as libc::c_int as libc::c_long,
                          last: 0x2ffb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3000 as libc::c_int as libc::c_long,
                          last: 0x303e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3041 as libc::c_int as libc::c_long,
                          last: 0x3096 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3099 as libc::c_int as libc::c_long,
                          last: 0x30ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3105 as libc::c_int as libc::c_long,
                          last: 0x312f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3131 as libc::c_int as libc::c_long,
                          last: 0x318e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3190 as libc::c_int as libc::c_long,
                          last: 0x31ba as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x31c0 as libc::c_int as libc::c_long,
                          last: 0x31e3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x31f0 as libc::c_int as libc::c_long,
                          last: 0x321e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3220 as libc::c_int as libc::c_long,
                          last: 0x3247 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3250 as libc::c_int as libc::c_long,
                          last: 0x4dbf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x4e00 as libc::c_int as libc::c_long,
                          last: 0xa48c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa490 as libc::c_int as libc::c_long,
                          last: 0xa4c6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa960 as libc::c_int as libc::c_long,
                          last: 0xa97c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xac00 as libc::c_int as libc::c_long,
                          last: 0xd7a3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf900 as libc::c_int as libc::c_long,
                          last: 0xfaff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe10 as libc::c_int as libc::c_long,
                          last: 0xfe19 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe30 as libc::c_int as libc::c_long,
                          last: 0xfe52 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe54 as libc::c_int as libc::c_long,
                          last: 0xfe66 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe68 as libc::c_int as libc::c_long,
                          last: 0xfe6b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xff01 as libc::c_int as libc::c_long,
                          last: 0xff60 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xffe0 as libc::c_int as libc::c_long,
                          last: 0xffe6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16fe0 as libc::c_int as libc::c_long,
                          last: 0x16fe3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x17000 as libc::c_int as libc::c_long,
                          last: 0x187f7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x18800 as libc::c_int as libc::c_long,
                          last: 0x18af2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b000 as libc::c_int as libc::c_long,
                          last: 0x1b11e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b150 as libc::c_int as libc::c_long,
                          last: 0x1b152 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b164 as libc::c_int as libc::c_long,
                          last: 0x1b167 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1b170 as libc::c_int as libc::c_long,
                          last: 0x1b2fb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f004 as libc::c_int as libc::c_long,
                          last: 0x1f004 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f0cf as libc::c_int as libc::c_long,
                          last: 0x1f0cf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f18e as libc::c_int as libc::c_long,
                          last: 0x1f18e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f191 as libc::c_int as libc::c_long,
                          last: 0x1f19a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f200 as libc::c_int as libc::c_long,
                          last: 0x1f202 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f210 as libc::c_int as libc::c_long,
                          last: 0x1f23b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f240 as libc::c_int as libc::c_long,
                          last: 0x1f248 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f250 as libc::c_int as libc::c_long,
                          last: 0x1f251 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f260 as libc::c_int as libc::c_long,
                          last: 0x1f265 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f300 as libc::c_int as libc::c_long,
                          last: 0x1f320 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f32d as libc::c_int as libc::c_long,
                          last: 0x1f335 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f337 as libc::c_int as libc::c_long,
                          last: 0x1f37c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f37e as libc::c_int as libc::c_long,
                          last: 0x1f393 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3a0 as libc::c_int as libc::c_long,
                          last: 0x1f3ca as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3cf as libc::c_int as libc::c_long,
                          last: 0x1f3d3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3e0 as libc::c_int as libc::c_long,
                          last: 0x1f3f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f4 as libc::c_int as libc::c_long,
                          last: 0x1f3f4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f8 as libc::c_int as libc::c_long,
                          last: 0x1f43e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f440 as libc::c_int as libc::c_long,
                          last: 0x1f440 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f442 as libc::c_int as libc::c_long,
                          last: 0x1f4fc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f4ff as libc::c_int as libc::c_long,
                          last: 0x1f53d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f54b as libc::c_int as libc::c_long,
                          last: 0x1f54e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f550 as libc::c_int as libc::c_long,
                          last: 0x1f567 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f57a as libc::c_int as libc::c_long,
                          last: 0x1f57a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f595 as libc::c_int as libc::c_long,
                          last: 0x1f596 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5a4 as libc::c_int as libc::c_long,
                          last: 0x1f5a4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5fb as libc::c_int as libc::c_long,
                          last: 0x1f64f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f680 as libc::c_int as libc::c_long,
                          last: 0x1f6c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6cc as libc::c_int as libc::c_long,
                          last: 0x1f6cc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6d0 as libc::c_int as libc::c_long,
                          last: 0x1f6d2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6d5 as libc::c_int as libc::c_long,
                          last: 0x1f6d5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6eb as libc::c_int as libc::c_long,
                          last: 0x1f6ec as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6f4 as libc::c_int as libc::c_long,
                          last: 0x1f6fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f7e0 as libc::c_int as libc::c_long,
                          last: 0x1f7eb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f90d as libc::c_int as libc::c_long,
                          last: 0x1f971 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f973 as libc::c_int as libc::c_long,
                          last: 0x1f976 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f97a as libc::c_int as libc::c_long,
                          last: 0x1f9a2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9a5 as libc::c_int as libc::c_long,
                          last: 0x1f9aa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9ae as libc::c_int as libc::c_long,
                          last: 0x1f9ca as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9cd as libc::c_int as libc::c_long,
                          last: 0x1f9ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa70 as libc::c_int as libc::c_long,
                          last: 0x1fa73 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa78 as libc::c_int as libc::c_long,
                          last: 0x1fa7a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa80 as libc::c_int as libc::c_long,
                          last: 0x1fa82 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa90 as libc::c_int as libc::c_long,
                          last: 0x1fa95 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x20000 as libc::c_int as libc::c_long,
                          last: 0x2fffd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x30000 as libc::c_int as libc::c_long,
                          last: 0x3fffd as libc::c_int as libc::c_long,};
             init
         }];
    #[c2rust::src_loc = "955:30"]
    pub static mut ambiguous: [interval; 179] =
        [{
             let mut init =
                 interval{first: 0xa1 as libc::c_int as libc::c_long,
                          last: 0xa1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa4 as libc::c_int as libc::c_long,
                          last: 0xa4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa7 as libc::c_int as libc::c_long,
                          last: 0xa8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xaa as libc::c_int as libc::c_long,
                          last: 0xaa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xad as libc::c_int as libc::c_long,
                          last: 0xae as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb0 as libc::c_int as libc::c_long,
                          last: 0xb4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xb6 as libc::c_int as libc::c_long,
                          last: 0xba as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xbc as libc::c_int as libc::c_long,
                          last: 0xbf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xc6 as libc::c_int as libc::c_long,
                          last: 0xc6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd0 as libc::c_int as libc::c_long,
                          last: 0xd0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd7 as libc::c_int as libc::c_long,
                          last: 0xd8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xde as libc::c_int as libc::c_long,
                          last: 0xe1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe6 as libc::c_int as libc::c_long,
                          last: 0xe6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe8 as libc::c_int as libc::c_long,
                          last: 0xea as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xec as libc::c_int as libc::c_long,
                          last: 0xed as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf0 as libc::c_int as libc::c_long,
                          last: 0xf0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf2 as libc::c_int as libc::c_long,
                          last: 0xf3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf7 as libc::c_int as libc::c_long,
                          last: 0xfa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfc as libc::c_int as libc::c_long,
                          last: 0xfc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe as libc::c_int as libc::c_long,
                          last: 0xfe as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x101 as libc::c_int as libc::c_long,
                          last: 0x101 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x111 as libc::c_int as libc::c_long,
                          last: 0x111 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x113 as libc::c_int as libc::c_long,
                          last: 0x113 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x11b as libc::c_int as libc::c_long,
                          last: 0x11b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x126 as libc::c_int as libc::c_long,
                          last: 0x127 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x12b as libc::c_int as libc::c_long,
                          last: 0x12b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x131 as libc::c_int as libc::c_long,
                          last: 0x133 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x138 as libc::c_int as libc::c_long,
                          last: 0x138 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x13f as libc::c_int as libc::c_long,
                          last: 0x142 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x144 as libc::c_int as libc::c_long,
                          last: 0x144 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x148 as libc::c_int as libc::c_long,
                          last: 0x14b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x14d as libc::c_int as libc::c_long,
                          last: 0x14d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x152 as libc::c_int as libc::c_long,
                          last: 0x153 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x166 as libc::c_int as libc::c_long,
                          last: 0x167 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x16b as libc::c_int as libc::c_long,
                          last: 0x16b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1ce as libc::c_int as libc::c_long,
                          last: 0x1ce as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d0 as libc::c_int as libc::c_long,
                          last: 0x1d0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d2 as libc::c_int as libc::c_long,
                          last: 0x1d2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d4 as libc::c_int as libc::c_long,
                          last: 0x1d4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d6 as libc::c_int as libc::c_long,
                          last: 0x1d6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1d8 as libc::c_int as libc::c_long,
                          last: 0x1d8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1da as libc::c_int as libc::c_long,
                          last: 0x1da as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1dc as libc::c_int as libc::c_long,
                          last: 0x1dc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x251 as libc::c_int as libc::c_long,
                          last: 0x251 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x261 as libc::c_int as libc::c_long,
                          last: 0x261 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2c4 as libc::c_int as libc::c_long,
                          last: 0x2c4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2c7 as libc::c_int as libc::c_long,
                          last: 0x2c7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2c9 as libc::c_int as libc::c_long,
                          last: 0x2cb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2cd as libc::c_int as libc::c_long,
                          last: 0x2cd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2d0 as libc::c_int as libc::c_long,
                          last: 0x2d0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2d8 as libc::c_int as libc::c_long,
                          last: 0x2db as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2dd as libc::c_int as libc::c_long,
                          last: 0x2dd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2df as libc::c_int as libc::c_long,
                          last: 0x2df as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x300 as libc::c_int as libc::c_long,
                          last: 0x36f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x391 as libc::c_int as libc::c_long,
                          last: 0x3a1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3a3 as libc::c_int as libc::c_long,
                          last: 0x3a9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3b1 as libc::c_int as libc::c_long,
                          last: 0x3c1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3c3 as libc::c_int as libc::c_long,
                          last: 0x3c9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x401 as libc::c_int as libc::c_long,
                          last: 0x401 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x410 as libc::c_int as libc::c_long,
                          last: 0x44f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x451 as libc::c_int as libc::c_long,
                          last: 0x451 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2010 as libc::c_int as libc::c_long,
                          last: 0x2010 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2013 as libc::c_int as libc::c_long,
                          last: 0x2016 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2018 as libc::c_int as libc::c_long,
                          last: 0x2019 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x201c as libc::c_int as libc::c_long,
                          last: 0x201d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2020 as libc::c_int as libc::c_long,
                          last: 0x2022 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2024 as libc::c_int as libc::c_long,
                          last: 0x2027 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2030 as libc::c_int as libc::c_long,
                          last: 0x2030 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2032 as libc::c_int as libc::c_long,
                          last: 0x2033 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2035 as libc::c_int as libc::c_long,
                          last: 0x2035 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x203b as libc::c_int as libc::c_long,
                          last: 0x203b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x203e as libc::c_int as libc::c_long,
                          last: 0x203e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2074 as libc::c_int as libc::c_long,
                          last: 0x2074 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x207f as libc::c_int as libc::c_long,
                          last: 0x207f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2081 as libc::c_int as libc::c_long,
                          last: 0x2084 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x20ac as libc::c_int as libc::c_long,
                          last: 0x20ac as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2103 as libc::c_int as libc::c_long,
                          last: 0x2103 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2105 as libc::c_int as libc::c_long,
                          last: 0x2105 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2109 as libc::c_int as libc::c_long,
                          last: 0x2109 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2113 as libc::c_int as libc::c_long,
                          last: 0x2113 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2116 as libc::c_int as libc::c_long,
                          last: 0x2116 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2121 as libc::c_int as libc::c_long,
                          last: 0x2122 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2126 as libc::c_int as libc::c_long,
                          last: 0x2126 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x212b as libc::c_int as libc::c_long,
                          last: 0x212b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2153 as libc::c_int as libc::c_long,
                          last: 0x2154 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x215b as libc::c_int as libc::c_long,
                          last: 0x215e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2160 as libc::c_int as libc::c_long,
                          last: 0x216b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2170 as libc::c_int as libc::c_long,
                          last: 0x2179 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2189 as libc::c_int as libc::c_long,
                          last: 0x2189 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2190 as libc::c_int as libc::c_long,
                          last: 0x2199 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x21b8 as libc::c_int as libc::c_long,
                          last: 0x21b9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x21d2 as libc::c_int as libc::c_long,
                          last: 0x21d2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x21d4 as libc::c_int as libc::c_long,
                          last: 0x21d4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x21e7 as libc::c_int as libc::c_long,
                          last: 0x21e7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2200 as libc::c_int as libc::c_long,
                          last: 0x2200 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2202 as libc::c_int as libc::c_long,
                          last: 0x2203 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2207 as libc::c_int as libc::c_long,
                          last: 0x2208 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x220b as libc::c_int as libc::c_long,
                          last: 0x220b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x220f as libc::c_int as libc::c_long,
                          last: 0x220f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2211 as libc::c_int as libc::c_long,
                          last: 0x2211 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2215 as libc::c_int as libc::c_long,
                          last: 0x2215 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x221a as libc::c_int as libc::c_long,
                          last: 0x221a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x221d as libc::c_int as libc::c_long,
                          last: 0x2220 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2223 as libc::c_int as libc::c_long,
                          last: 0x2223 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2225 as libc::c_int as libc::c_long,
                          last: 0x2225 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2227 as libc::c_int as libc::c_long,
                          last: 0x222c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x222e as libc::c_int as libc::c_long,
                          last: 0x222e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2234 as libc::c_int as libc::c_long,
                          last: 0x2237 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x223c as libc::c_int as libc::c_long,
                          last: 0x223d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2248 as libc::c_int as libc::c_long,
                          last: 0x2248 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x224c as libc::c_int as libc::c_long,
                          last: 0x224c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2252 as libc::c_int as libc::c_long,
                          last: 0x2252 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2260 as libc::c_int as libc::c_long,
                          last: 0x2261 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2264 as libc::c_int as libc::c_long,
                          last: 0x2267 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x226a as libc::c_int as libc::c_long,
                          last: 0x226b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x226e as libc::c_int as libc::c_long,
                          last: 0x226f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2282 as libc::c_int as libc::c_long,
                          last: 0x2283 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2286 as libc::c_int as libc::c_long,
                          last: 0x2287 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2295 as libc::c_int as libc::c_long,
                          last: 0x2295 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2299 as libc::c_int as libc::c_long,
                          last: 0x2299 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x22a5 as libc::c_int as libc::c_long,
                          last: 0x22a5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x22bf as libc::c_int as libc::c_long,
                          last: 0x22bf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2312 as libc::c_int as libc::c_long,
                          last: 0x2312 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2460 as libc::c_int as libc::c_long,
                          last: 0x24e9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x24eb as libc::c_int as libc::c_long,
                          last: 0x254b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2550 as libc::c_int as libc::c_long,
                          last: 0x2573 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2580 as libc::c_int as libc::c_long,
                          last: 0x258f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2592 as libc::c_int as libc::c_long,
                          last: 0x2595 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25a0 as libc::c_int as libc::c_long,
                          last: 0x25a1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25a3 as libc::c_int as libc::c_long,
                          last: 0x25a9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25b2 as libc::c_int as libc::c_long,
                          last: 0x25b3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25b6 as libc::c_int as libc::c_long,
                          last: 0x25b7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25bc as libc::c_int as libc::c_long,
                          last: 0x25bd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25c0 as libc::c_int as libc::c_long,
                          last: 0x25c1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25c6 as libc::c_int as libc::c_long,
                          last: 0x25c8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25cb as libc::c_int as libc::c_long,
                          last: 0x25cb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25ce as libc::c_int as libc::c_long,
                          last: 0x25d1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25e2 as libc::c_int as libc::c_long,
                          last: 0x25e5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25ef as libc::c_int as libc::c_long,
                          last: 0x25ef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2605 as libc::c_int as libc::c_long,
                          last: 0x2606 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2609 as libc::c_int as libc::c_long,
                          last: 0x2609 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x260e as libc::c_int as libc::c_long,
                          last: 0x260f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x261c as libc::c_int as libc::c_long,
                          last: 0x261c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x261e as libc::c_int as libc::c_long,
                          last: 0x261e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2640 as libc::c_int as libc::c_long,
                          last: 0x2640 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2642 as libc::c_int as libc::c_long,
                          last: 0x2642 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2660 as libc::c_int as libc::c_long,
                          last: 0x2661 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2663 as libc::c_int as libc::c_long,
                          last: 0x2665 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2667 as libc::c_int as libc::c_long,
                          last: 0x266a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x266c as libc::c_int as libc::c_long,
                          last: 0x266d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x266f as libc::c_int as libc::c_long,
                          last: 0x266f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x269e as libc::c_int as libc::c_long,
                          last: 0x269f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26bf as libc::c_int as libc::c_long,
                          last: 0x26bf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26c6 as libc::c_int as libc::c_long,
                          last: 0x26cd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26cf as libc::c_int as libc::c_long,
                          last: 0x26d3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26d5 as libc::c_int as libc::c_long,
                          last: 0x26e1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26e3 as libc::c_int as libc::c_long,
                          last: 0x26e3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26e8 as libc::c_int as libc::c_long,
                          last: 0x26e9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26eb as libc::c_int as libc::c_long,
                          last: 0x26f1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f4 as libc::c_int as libc::c_long,
                          last: 0x26f4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f6 as libc::c_int as libc::c_long,
                          last: 0x26f9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26fb as libc::c_int as libc::c_long,
                          last: 0x26fc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26fe as libc::c_int as libc::c_long,
                          last: 0x26ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x273d as libc::c_int as libc::c_long,
                          last: 0x273d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2776 as libc::c_int as libc::c_long,
                          last: 0x277f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b56 as libc::c_int as libc::c_long,
                          last: 0x2b59 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3248 as libc::c_int as libc::c_long,
                          last: 0x324f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe000 as libc::c_int as libc::c_long,
                          last: 0xf8ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfe00 as libc::c_int as libc::c_long,
                          last: 0xfe0f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfffd as libc::c_int as libc::c_long,
                          last: 0xfffd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f100 as libc::c_int as libc::c_long,
                          last: 0x1f10a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f110 as libc::c_int as libc::c_long,
                          last: 0x1f12d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f130 as libc::c_int as libc::c_long,
                          last: 0x1f169 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f170 as libc::c_int as libc::c_long,
                          last: 0x1f18d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f18f as libc::c_int as libc::c_long,
                          last: 0x1f190 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f19b as libc::c_int as libc::c_long,
                          last: 0x1f1ac as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xe0100 as libc::c_int as libc::c_long,
                          last: 0xe01ef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xf0000 as libc::c_int as libc::c_long,
                          last: 0xffffd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x100000 as libc::c_int as libc::c_long,
                          last: 0x10fffd as libc::c_int as libc::c_long,};
             init
         }];
    #[c2rust::src_loc = "1136:30"]
    pub static mut emoji_all: [interval; 151] =
        [{
             let mut init =
                 interval{first: 0x23 as libc::c_int as libc::c_long,
                          last: 0x23 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2a as libc::c_int as libc::c_long,
                          last: 0x2a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x30 as libc::c_int as libc::c_long,
                          last: 0x39 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xa9 as libc::c_int as libc::c_long,
                          last: 0xa9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xae as libc::c_int as libc::c_long,
                          last: 0xae as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x203c as libc::c_int as libc::c_long,
                          last: 0x203c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2049 as libc::c_int as libc::c_long,
                          last: 0x2049 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2122 as libc::c_int as libc::c_long,
                          last: 0x2122 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2139 as libc::c_int as libc::c_long,
                          last: 0x2139 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2194 as libc::c_int as libc::c_long,
                          last: 0x2199 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x21a9 as libc::c_int as libc::c_long,
                          last: 0x21aa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x231a as libc::c_int as libc::c_long,
                          last: 0x231b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2328 as libc::c_int as libc::c_long,
                          last: 0x2328 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23cf as libc::c_int as libc::c_long,
                          last: 0x23cf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23e9 as libc::c_int as libc::c_long,
                          last: 0x23f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x23f8 as libc::c_int as libc::c_long,
                          last: 0x23fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x24c2 as libc::c_int as libc::c_long,
                          last: 0x24c2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25aa as libc::c_int as libc::c_long,
                          last: 0x25ab as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25b6 as libc::c_int as libc::c_long,
                          last: 0x25b6 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25c0 as libc::c_int as libc::c_long,
                          last: 0x25c0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x25fb as libc::c_int as libc::c_long,
                          last: 0x25fe as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2600 as libc::c_int as libc::c_long,
                          last: 0x2604 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x260e as libc::c_int as libc::c_long,
                          last: 0x260e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2611 as libc::c_int as libc::c_long,
                          last: 0x2611 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2614 as libc::c_int as libc::c_long,
                          last: 0x2615 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2618 as libc::c_int as libc::c_long,
                          last: 0x2618 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x261d as libc::c_int as libc::c_long,
                          last: 0x261d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2620 as libc::c_int as libc::c_long,
                          last: 0x2620 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2622 as libc::c_int as libc::c_long,
                          last: 0x2623 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2626 as libc::c_int as libc::c_long,
                          last: 0x2626 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x262a as libc::c_int as libc::c_long,
                          last: 0x262a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x262e as libc::c_int as libc::c_long,
                          last: 0x262f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2638 as libc::c_int as libc::c_long,
                          last: 0x263a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2640 as libc::c_int as libc::c_long,
                          last: 0x2640 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2642 as libc::c_int as libc::c_long,
                          last: 0x2642 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2648 as libc::c_int as libc::c_long,
                          last: 0x2653 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x265f as libc::c_int as libc::c_long,
                          last: 0x2660 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2663 as libc::c_int as libc::c_long,
                          last: 0x2663 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2665 as libc::c_int as libc::c_long,
                          last: 0x2666 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2668 as libc::c_int as libc::c_long,
                          last: 0x2668 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x267b as libc::c_int as libc::c_long,
                          last: 0x267b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x267e as libc::c_int as libc::c_long,
                          last: 0x267f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2692 as libc::c_int as libc::c_long,
                          last: 0x2697 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2699 as libc::c_int as libc::c_long,
                          last: 0x2699 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x269b as libc::c_int as libc::c_long,
                          last: 0x269c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26a0 as libc::c_int as libc::c_long,
                          last: 0x26a1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26aa as libc::c_int as libc::c_long,
                          last: 0x26ab as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26b0 as libc::c_int as libc::c_long,
                          last: 0x26b1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26bd as libc::c_int as libc::c_long,
                          last: 0x26be as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26c4 as libc::c_int as libc::c_long,
                          last: 0x26c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26c8 as libc::c_int as libc::c_long,
                          last: 0x26c8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26ce as libc::c_int as libc::c_long,
                          last: 0x26cf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26d1 as libc::c_int as libc::c_long,
                          last: 0x26d1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26d3 as libc::c_int as libc::c_long,
                          last: 0x26d4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26e9 as libc::c_int as libc::c_long,
                          last: 0x26ea as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f0 as libc::c_int as libc::c_long,
                          last: 0x26f5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26f7 as libc::c_int as libc::c_long,
                          last: 0x26fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x26fd as libc::c_int as libc::c_long,
                          last: 0x26fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2702 as libc::c_int as libc::c_long,
                          last: 0x2702 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2705 as libc::c_int as libc::c_long,
                          last: 0x2705 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2708 as libc::c_int as libc::c_long,
                          last: 0x270d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x270f as libc::c_int as libc::c_long,
                          last: 0x270f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2712 as libc::c_int as libc::c_long,
                          last: 0x2712 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2714 as libc::c_int as libc::c_long,
                          last: 0x2714 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2716 as libc::c_int as libc::c_long,
                          last: 0x2716 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x271d as libc::c_int as libc::c_long,
                          last: 0x271d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2721 as libc::c_int as libc::c_long,
                          last: 0x2721 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2728 as libc::c_int as libc::c_long,
                          last: 0x2728 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2733 as libc::c_int as libc::c_long,
                          last: 0x2734 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2744 as libc::c_int as libc::c_long,
                          last: 0x2744 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2747 as libc::c_int as libc::c_long,
                          last: 0x2747 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x274c as libc::c_int as libc::c_long,
                          last: 0x274c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x274e as libc::c_int as libc::c_long,
                          last: 0x274e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2753 as libc::c_int as libc::c_long,
                          last: 0x2755 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2757 as libc::c_int as libc::c_long,
                          last: 0x2757 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2763 as libc::c_int as libc::c_long,
                          last: 0x2764 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2795 as libc::c_int as libc::c_long,
                          last: 0x2797 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x27a1 as libc::c_int as libc::c_long,
                          last: 0x27a1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x27b0 as libc::c_int as libc::c_long,
                          last: 0x27b0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x27bf as libc::c_int as libc::c_long,
                          last: 0x27bf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2934 as libc::c_int as libc::c_long,
                          last: 0x2935 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b05 as libc::c_int as libc::c_long,
                          last: 0x2b07 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b1b as libc::c_int as libc::c_long,
                          last: 0x2b1c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b50 as libc::c_int as libc::c_long,
                          last: 0x2b50 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x2b55 as libc::c_int as libc::c_long,
                          last: 0x2b55 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3030 as libc::c_int as libc::c_long,
                          last: 0x3030 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x303d as libc::c_int as libc::c_long,
                          last: 0x303d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3297 as libc::c_int as libc::c_long,
                          last: 0x3297 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x3299 as libc::c_int as libc::c_long,
                          last: 0x3299 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f004 as libc::c_int as libc::c_long,
                          last: 0x1f004 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f0cf as libc::c_int as libc::c_long,
                          last: 0x1f0cf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f170 as libc::c_int as libc::c_long,
                          last: 0x1f171 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f17e as libc::c_int as libc::c_long,
                          last: 0x1f17f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f18e as libc::c_int as libc::c_long,
                          last: 0x1f18e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f191 as libc::c_int as libc::c_long,
                          last: 0x1f19a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f1e6 as libc::c_int as libc::c_long,
                          last: 0x1f1ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f201 as libc::c_int as libc::c_long,
                          last: 0x1f202 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f21a as libc::c_int as libc::c_long,
                          last: 0x1f21a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f22f as libc::c_int as libc::c_long,
                          last: 0x1f22f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f232 as libc::c_int as libc::c_long,
                          last: 0x1f23a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f250 as libc::c_int as libc::c_long,
                          last: 0x1f251 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f300 as libc::c_int as libc::c_long,
                          last: 0x1f321 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f324 as libc::c_int as libc::c_long,
                          last: 0x1f393 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f396 as libc::c_int as libc::c_long,
                          last: 0x1f397 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f399 as libc::c_int as libc::c_long,
                          last: 0x1f39b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f39e as libc::c_int as libc::c_long,
                          last: 0x1f3f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f3 as libc::c_int as libc::c_long,
                          last: 0x1f3f5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f7 as libc::c_int as libc::c_long,
                          last: 0x1f4fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f4ff as libc::c_int as libc::c_long,
                          last: 0x1f53d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f549 as libc::c_int as libc::c_long,
                          last: 0x1f54e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f550 as libc::c_int as libc::c_long,
                          last: 0x1f567 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f56f as libc::c_int as libc::c_long,
                          last: 0x1f570 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f573 as libc::c_int as libc::c_long,
                          last: 0x1f57a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f587 as libc::c_int as libc::c_long,
                          last: 0x1f587 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f58a as libc::c_int as libc::c_long,
                          last: 0x1f58d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f590 as libc::c_int as libc::c_long,
                          last: 0x1f590 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f595 as libc::c_int as libc::c_long,
                          last: 0x1f596 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5a4 as libc::c_int as libc::c_long,
                          last: 0x1f5a5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5a8 as libc::c_int as libc::c_long,
                          last: 0x1f5a8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5b1 as libc::c_int as libc::c_long,
                          last: 0x1f5b2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5bc as libc::c_int as libc::c_long,
                          last: 0x1f5bc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5c2 as libc::c_int as libc::c_long,
                          last: 0x1f5c4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5d1 as libc::c_int as libc::c_long,
                          last: 0x1f5d3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5dc as libc::c_int as libc::c_long,
                          last: 0x1f5de as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e1 as libc::c_int as libc::c_long,
                          last: 0x1f5e1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e3 as libc::c_int as libc::c_long,
                          last: 0x1f5e3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e8 as libc::c_int as libc::c_long,
                          last: 0x1f5e8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5ef as libc::c_int as libc::c_long,
                          last: 0x1f5ef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5f3 as libc::c_int as libc::c_long,
                          last: 0x1f5f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5fa as libc::c_int as libc::c_long,
                          last: 0x1f64f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f680 as libc::c_int as libc::c_long,
                          last: 0x1f6c5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6cb as libc::c_int as libc::c_long,
                          last: 0x1f6d2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6d5 as libc::c_int as libc::c_long,
                          last: 0x1f6d5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6e0 as libc::c_int as libc::c_long,
                          last: 0x1f6e5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6e9 as libc::c_int as libc::c_long,
                          last: 0x1f6e9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6eb as libc::c_int as libc::c_long,
                          last: 0x1f6ec as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6f0 as libc::c_int as libc::c_long,
                          last: 0x1f6f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6f3 as libc::c_int as libc::c_long,
                          last: 0x1f6fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f7e0 as libc::c_int as libc::c_long,
                          last: 0x1f7eb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f90d as libc::c_int as libc::c_long,
                          last: 0x1f93a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f93c as libc::c_int as libc::c_long,
                          last: 0x1f945 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f947 as libc::c_int as libc::c_long,
                          last: 0x1f971 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f973 as libc::c_int as libc::c_long,
                          last: 0x1f976 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f97a as libc::c_int as libc::c_long,
                          last: 0x1f9a2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9a5 as libc::c_int as libc::c_long,
                          last: 0x1f9aa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9ae as libc::c_int as libc::c_long,
                          last: 0x1f9ca as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f9cd as libc::c_int as libc::c_long,
                          last: 0x1f9ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa70 as libc::c_int as libc::c_long,
                          last: 0x1fa73 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa78 as libc::c_int as libc::c_long,
                          last: 0x1fa7a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa80 as libc::c_int as libc::c_long,
                          last: 0x1fa82 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1fa90 as libc::c_int as libc::c_long,
                          last: 0x1fa95 as libc::c_int as libc::c_long,};
             init
         }];
    #[c2rust::src_loc = "1289:30"]
    pub static mut emoji_width: [interval; 39] =
        [{
             let mut init =
                 interval{first: 0x1f1e6 as libc::c_int as libc::c_long,
                          last: 0x1f1ff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f321 as libc::c_int as libc::c_long,
                          last: 0x1f321 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f324 as libc::c_int as libc::c_long,
                          last: 0x1f32c as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f336 as libc::c_int as libc::c_long,
                          last: 0x1f336 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f37d as libc::c_int as libc::c_long,
                          last: 0x1f37d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f396 as libc::c_int as libc::c_long,
                          last: 0x1f397 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f399 as libc::c_int as libc::c_long,
                          last: 0x1f39b as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f39e as libc::c_int as libc::c_long,
                          last: 0x1f39f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3cb as libc::c_int as libc::c_long,
                          last: 0x1f3ce as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3d4 as libc::c_int as libc::c_long,
                          last: 0x1f3df as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f3 as libc::c_int as libc::c_long,
                          last: 0x1f3f5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f3f7 as libc::c_int as libc::c_long,
                          last: 0x1f3f7 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f43f as libc::c_int as libc::c_long,
                          last: 0x1f43f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f441 as libc::c_int as libc::c_long,
                          last: 0x1f441 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f4fd as libc::c_int as libc::c_long,
                          last: 0x1f4fd as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f549 as libc::c_int as libc::c_long,
                          last: 0x1f54a as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f56f as libc::c_int as libc::c_long,
                          last: 0x1f570 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f573 as libc::c_int as libc::c_long,
                          last: 0x1f579 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f587 as libc::c_int as libc::c_long,
                          last: 0x1f587 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f58a as libc::c_int as libc::c_long,
                          last: 0x1f58d as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f590 as libc::c_int as libc::c_long,
                          last: 0x1f590 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5a5 as libc::c_int as libc::c_long,
                          last: 0x1f5a5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5a8 as libc::c_int as libc::c_long,
                          last: 0x1f5a8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5b1 as libc::c_int as libc::c_long,
                          last: 0x1f5b2 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5bc as libc::c_int as libc::c_long,
                          last: 0x1f5bc as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5c2 as libc::c_int as libc::c_long,
                          last: 0x1f5c4 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5d1 as libc::c_int as libc::c_long,
                          last: 0x1f5d3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5dc as libc::c_int as libc::c_long,
                          last: 0x1f5de as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e1 as libc::c_int as libc::c_long,
                          last: 0x1f5e1 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e3 as libc::c_int as libc::c_long,
                          last: 0x1f5e3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5e8 as libc::c_int as libc::c_long,
                          last: 0x1f5e8 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5ef as libc::c_int as libc::c_long,
                          last: 0x1f5ef as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5f3 as libc::c_int as libc::c_long,
                          last: 0x1f5f3 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f5fa as libc::c_int as libc::c_long,
                          last: 0x1f5fa as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6cb as libc::c_int as libc::c_long,
                          last: 0x1f6cf as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6e0 as libc::c_int as libc::c_long,
                          last: 0x1f6e5 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6e9 as libc::c_int as libc::c_long,
                          last: 0x1f6e9 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6f0 as libc::c_int as libc::c_long,
                          last: 0x1f6f0 as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x1f6f3 as libc::c_int as libc::c_long,
                          last: 0x1f6f3 as libc::c_int as libc::c_long,};
             init
         }];
    use super::{convertStruct, interval};
}
pub use self::internal::{__builtin_va_list, __va_list_tag};
pub use self::types_h::{__int8_t, __uint8_t, __int16_t, __uint16_t, __int32_t,
                        __uint32_t, __int64_t, __uint64_t, __uid_t, __gid_t,
                        __time_t, __ssize_t};
pub use self::stdint_intn_h::{int8_t, int16_t, int32_t, int64_t};
pub use self::stdint_uintn_h::{uint8_t, uint16_t, uint32_t, uint64_t};
pub use self::stddef_h::{size_t, NULL_0, NULL, NULL_1, NULL_2};
pub use self::stdarg_h::va_list;
pub use self::wint_t_h::wint_t;
pub use self::nvim_types_h::{char_u, handle_T, LuaRef};
pub use self::typval_h::{sctx_T, scid_T, dict_T, dictvar_S, ScopeType,
                         VAR_DEF_SCOPE, VAR_SCOPE, VAR_NO_SCOPE,
                         VarLockStatus, VAR_FIXED, VAR_LOCKED, VAR_UNLOCKED,
                         ScopeDictDictItem, typval_T, typval_vval_union,
                         partial_T, partial_S, ufunc_T, ufunc, funccall_T,
                         list_T, listvar_S, listitem_T, listitem_S,
                         listwatch_T, listwatch_S, float_T, SpecialVarValue,
                         kSpecialVarNull, kSpecialVarTrue, kSpecialVarFalse,
                         varnumber_T, VarType, VAR_PARTIAL, VAR_SPECIAL,
                         VAR_FLOAT, VAR_DICT, VAR_LIST, VAR_FUNC, VAR_STRING,
                         VAR_NUMBER, VAR_UNKNOWN, Callback, CallbackType,
                         kCallbackPartial, kCallbackFuncref, kCallbackNone,
                         C2RustUnnamed_8, dict_watcher, DictWatcher,
                         tv_list_ref, tv_list_set_ret, tv_list_locked,
                         tv_list_set_lock, tv_list_set_copyid, tv_list_len,
                         tv_list_copyid, tv_list_latest_copy, tv_list_uidx,
                         tv_list_has_watchers, tv_list_first, tv_list_last,
                         tv_dict_set_ret, tv_dict_len, tv_dict_is_watched,
                         tv_init, tv_get_float_chk, tv_dict_watcher_node_data,
                         tv_is_func, funccall_S};
pub use self::pos_h::{linenr_T, colnr_T, C2RustUnnamed, MAXCOL, pos_T,
                      lpos_T};
pub use self::ctype_h::{C2RustUnnamed_0, _ISalnum, _ISpunct, _IScntrl,
                        _ISblank, _ISgraph, _ISprint, _ISspace, _ISxdigit,
                        _ISdigit, _ISalpha, _ISlower, _ISupper, __ctype_b_loc,
                        toupper, tolower};
pub use self::stdio_h::{ssize_t, sprintf};
pub use self::sys_types_h::{gid_t, uid_t};
pub use self::time_t_h::time_t;
pub use self::pthreadtypes_arch_h::__pthread_rwlock_arch_t;
pub use self::thread_shared_types_h::{__pthread_internal_list,
                                      __pthread_list_t, __pthread_mutex_s};
pub use self::pthreadtypes_h::{pthread_mutex_t, pthread_rwlock_t};
pub use self::hashtab_h::{hash_T, hashitem_S, hashitem_T, hashtable_S,
                          hashtab_T};
pub use self::garray_h::{growarray, garray_T, ga_append_via_ptr, ga_grow};
pub use self::iconv_h::{iconv_t, iconv_open, iconv, iconv_close};
pub use self::mbyte_h::{C2RustUnnamed_1, CONV_ICONV, CONV_TO_LATIN9,
                        CONV_TO_LATIN1, CONV_9_TO_UTF8, CONV_TO_UTF8,
                        CONV_NONE, vimconv_T, ENC_8BIT, ENC_DBCS,
                        ENC_MACROMAN, ENC_4BYTE, ENC_ENDIAN_L, ENC_UNICODE,
                        ENC_ENDIAN_B, ENC_2WORD, ENC_2BYTE, ENC_LATIN9,
                        ENC_LATIN1, mb_ptr2len, mb_strcmp_ic};
pub use self::buffer_defs_h::{buf_T, file_buffer, C2RustUnnamed_3,
                              BufUpdateCallbacks, C2RustUnnamed_4, synblock_T,
                              win_T, window_S, qf_info_T, FloatConfig,
                              WinStyle, kWinStyleMinimal, kWinStyleUnused,
                              FloatRelative, kFloatRelativeCursor,
                              kFloatRelativeWindow, kFloatRelativeEditor,
                              FloatAnchor, taggy_T, taggy, matchitem_T,
                              matchitem, match_T, posmatch_T, posmatch,
                              llpos_T, winopt_T, alist_T, arglist, wline_T,
                              w_line, pos_save_T, C2RustUnnamed_5,
                              C2RustUnnamed_6, frame_T, frame_S, disptick_T,
                              syn_time_T, mapblock_T, mapblock, wininfo_T,
                              wininfo_S, ChangedtickDictItem, win_hl_attr,
                              qf_info_S};
pub use self::map_h::{Map_uint64_t_ExtmarkNs, kh_uint64_t_ExtmarkNs_map_t,
                      ExtmarkNs, Map_uint64_t_uint64_t,
                      kh_uint64_t_uint64_t_map_t, Map_uint64_t_ExtmarkItem,
                      kh_uint64_t_ExtmarkItem_map_t, Map_uint64_t_ptr_t,
                      kh_uint64_t_ptr_t_map_t, kh_cstr_t_ptr_t_map_t,
                      Map_cstr_t_ptr_t, map_uint64_t_ptr_t_get};
pub use self::khash_h::{khint32_t, khint_t, __ac_X31_hash_string,
                        __ac_Wang_hash};
pub use self::extmark_defs_h::{ExtmarkItem, VirtText, VirtTextChunk,
                               extmark_undo_vec_t, ExtmarkUndoObject,
                               undo_object};
pub use self::marktree_h::{MarkTree, mtnode_t, mtnode_s, mtkey_t, mtpos_t};
pub use self::map_defs_h::{ptr_t, cstr_t};
pub use self::queue_h::{QUEUE, _queue, QUEUE_EMPTY, QUEUE_INIT, QUEUE_ADD,
                        QUEUE_INSERT_HEAD, QUEUE_INSERT_TAIL, QUEUE_REMOVE};
pub use self::terminal_h::{Terminal, terminal};
pub use self::sign_defs_h::{signlist_T, signlist, signgroup_T, signgroup_S};
pub use self::regexp_defs_h::{regprog_T, regprog, regengine_T, regengine,
                              regmmatch_T, regmatch_T, reg_extmatch_T,
                              reg_extmatch};
pub use self::profile_h::proftime_T;
pub use self::defs_h::{Window, Boolean, Integer, Float, String_0, object,
                       C2RustUnnamed_14, Dictionary, KeyValuePair,
                       key_value_pair, Object, Array, ObjectType,
                       kObjectTypeTabpage, kObjectTypeWindow,
                       kObjectTypeBuffer, kObjectTypeLuaRef,
                       kObjectTypeDictionary, kObjectTypeArray,
                       kObjectTypeString, kObjectTypeFloat,
                       kObjectTypeInteger, kObjectTypeBoolean, kObjectTypeNil,
                       is_internal_call};
pub use self::grid_defs_h::{ScreenGrid, sattr_T, schar_T, MAX_MCO};
pub use self::mark_defs_h::{fmark_T, filemark, xfmark_T, xfilemark, NMARKS};
pub use self::time_h::Timestamp;
pub use self::option_defs_h::{LastSet, CMP_INTERNAL, CMP_KEEPASCII, p_ambw,
                              p_emoji, cmp_flags, p_enc, breakat_flags};
pub use self::syntax_defs_h::{synstate_T, syn_state, C2RustUnnamed_7,
                              bufstate_T, buf_state};
pub use self::undo_defs_h::{u_header_T, u_header, visualinfo_T, u_entry_T,
                            u_entry, C2RustUnnamed_9, C2RustUnnamed_10,
                            C2RustUnnamed_11, C2RustUnnamed_12};
pub use self::fs_defs_h::FileID;
pub use self::memline_defs_h::{memline_T, memline, chunksize_T, ml_chunksize,
                               infoptr_T, info_pointer};
pub use self::memfile_defs_h::{bhdr_T, bhdr, mf_hashitem_T, mf_hashitem,
                               blocknr_T, memfile_T, memfile, mf_hashtab_T,
                               mf_hashtab};
pub use self::globals_h::{WorkingStatus, kBroken, kWorking, kUnknown, IOSIZE,
                          DBCS_JPN, DBCS_JPNU, DBCS_KOR, DBCS_KORU, DBCS_CHS,
                          DBCS_CHSU, DBCS_CHT, DBCS_CHTU, DBCS_DEBUG, curwin,
                          curbuf, fenc_default, IObuff};
pub use self::keymap_h::{KE_CSI, key_extra, KE_COMMAND, KE_EVENT, KE_NOP,
                         KE_DROP, KE_X2RELEASE, KE_X2DRAG, KE_X2MOUSE,
                         KE_X1RELEASE, KE_X1DRAG, KE_X1MOUSE, KE_C_END,
                         KE_C_HOME, KE_C_RIGHT, KE_C_LEFT, KE_CMDWIN, KE_PLUG,
                         KE_SNR, KE_KDEL, KE_KINS, KE_MOUSERIGHT,
                         KE_MOUSELEFT, KE_MOUSEUP, KE_MOUSEDOWN, KE_S_XF4,
                         KE_S_XF3, KE_S_XF2, KE_S_XF1, KE_LEFTRELEASE_NM,
                         KE_LEFTMOUSE_NM, KE_XRIGHT, KE_XLEFT, KE_XDOWN,
                         KE_XUP, KE_ZHOME, KE_XHOME, KE_ZEND, KE_XEND, KE_XF4,
                         KE_XF3, KE_XF2, KE_XF1, KE_S_TAB_OLD, KE_TAB,
                         KE_IGNORE, KE_RIGHTRELEASE, KE_RIGHTDRAG,
                         KE_RIGHTMOUSE, KE_MIDDLERELEASE, KE_MIDDLEDRAG,
                         KE_MIDDLEMOUSE, KE_LEFTRELEASE, KE_LEFTDRAG,
                         KE_LEFTMOUSE, KE_MOUSE, KE_S_F37, KE_S_F36, KE_S_F35,
                         KE_S_F34, KE_S_F33, KE_S_F32, KE_S_F31, KE_S_F30,
                         KE_S_F29, KE_S_F28, KE_S_F27, KE_S_F26, KE_S_F25,
                         KE_S_F24, KE_S_F23, KE_S_F22, KE_S_F21, KE_S_F20,
                         KE_S_F19, KE_S_F18, KE_S_F17, KE_S_F16, KE_S_F15,
                         KE_S_F14, KE_S_F13, KE_S_F12, KE_S_F11, KE_S_F10,
                         KE_S_F9, KE_S_F8, KE_S_F7, KE_S_F6, KE_S_F5, KE_S_F4,
                         KE_S_F3, KE_S_F2, KE_S_F1, KE_S_DOWN, KE_S_UP,
                         KE_NAME, K_SPECIAL, KS_EXTRA, KE_FILLER, KS_SPECIAL};
pub use self::langinfo_h::{CODESET, C2RustUnnamed_33, _NL_NUM,
                           _NL_NUM_LC_IDENTIFICATION,
                           _NL_IDENTIFICATION_CODESET,
                           _NL_IDENTIFICATION_CATEGORY,
                           _NL_IDENTIFICATION_DATE,
                           _NL_IDENTIFICATION_REVISION,
                           _NL_IDENTIFICATION_ABBREVIATION,
                           _NL_IDENTIFICATION_APPLICATION,
                           _NL_IDENTIFICATION_AUDIENCE,
                           _NL_IDENTIFICATION_TERRITORY,
                           _NL_IDENTIFICATION_LANGUAGE,
                           _NL_IDENTIFICATION_FAX, _NL_IDENTIFICATION_TEL,
                           _NL_IDENTIFICATION_EMAIL,
                           _NL_IDENTIFICATION_CONTACT,
                           _NL_IDENTIFICATION_ADDRESS,
                           _NL_IDENTIFICATION_SOURCE,
                           _NL_IDENTIFICATION_TITLE, _NL_NUM_LC_MEASUREMENT,
                           _NL_MEASUREMENT_CODESET,
                           _NL_MEASUREMENT_MEASUREMENT, _NL_NUM_LC_TELEPHONE,
                           _NL_TELEPHONE_CODESET, _NL_TELEPHONE_INT_PREFIX,
                           _NL_TELEPHONE_INT_SELECT,
                           _NL_TELEPHONE_TEL_DOM_FMT,
                           _NL_TELEPHONE_TEL_INT_FMT, _NL_NUM_LC_ADDRESS,
                           _NL_ADDRESS_CODESET, _NL_ADDRESS_LANG_LIB,
                           _NL_ADDRESS_LANG_TERM, _NL_ADDRESS_LANG_AB,
                           _NL_ADDRESS_LANG_NAME, _NL_ADDRESS_COUNTRY_ISBN,
                           _NL_ADDRESS_COUNTRY_NUM, _NL_ADDRESS_COUNTRY_CAR,
                           _NL_ADDRESS_COUNTRY_AB3, _NL_ADDRESS_COUNTRY_AB2,
                           _NL_ADDRESS_COUNTRY_POST, _NL_ADDRESS_COUNTRY_NAME,
                           _NL_ADDRESS_POSTAL_FMT, _NL_NUM_LC_NAME,
                           _NL_NAME_CODESET, _NL_NAME_NAME_MS,
                           _NL_NAME_NAME_MISS, _NL_NAME_NAME_MRS,
                           _NL_NAME_NAME_MR, _NL_NAME_NAME_GEN,
                           _NL_NAME_NAME_FMT, _NL_NUM_LC_PAPER,
                           _NL_PAPER_CODESET, _NL_PAPER_WIDTH,
                           _NL_PAPER_HEIGHT, _NL_NUM_LC_MESSAGES,
                           _NL_MESSAGES_CODESET, __NOSTR, __YESSTR, __NOEXPR,
                           __YESEXPR, _NL_NUM_LC_NUMERIC, _NL_NUMERIC_CODESET,
                           _NL_NUMERIC_THOUSANDS_SEP_WC,
                           _NL_NUMERIC_DECIMAL_POINT_WC, __GROUPING, THOUSEP,
                           __THOUSANDS_SEP, RADIXCHAR, __DECIMAL_POINT,
                           _NL_NUM_LC_MONETARY, _NL_MONETARY_CODESET,
                           _NL_MONETARY_THOUSANDS_SEP_WC,
                           _NL_MONETARY_DECIMAL_POINT_WC,
                           _NL_MONETARY_CONVERSION_RATE,
                           _NL_MONETARY_DUO_VALID_TO,
                           _NL_MONETARY_DUO_VALID_FROM,
                           _NL_MONETARY_UNO_VALID_TO,
                           _NL_MONETARY_UNO_VALID_FROM,
                           _NL_MONETARY_DUO_INT_N_SIGN_POSN,
                           _NL_MONETARY_DUO_INT_P_SIGN_POSN,
                           _NL_MONETARY_DUO_N_SIGN_POSN,
                           _NL_MONETARY_DUO_P_SIGN_POSN,
                           _NL_MONETARY_DUO_INT_N_SEP_BY_SPACE,
                           _NL_MONETARY_DUO_INT_N_CS_PRECEDES,
                           _NL_MONETARY_DUO_INT_P_SEP_BY_SPACE,
                           _NL_MONETARY_DUO_INT_P_CS_PRECEDES,
                           _NL_MONETARY_DUO_N_SEP_BY_SPACE,
                           _NL_MONETARY_DUO_N_CS_PRECEDES,
                           _NL_MONETARY_DUO_P_SEP_BY_SPACE,
                           _NL_MONETARY_DUO_P_CS_PRECEDES,
                           _NL_MONETARY_DUO_FRAC_DIGITS,
                           _NL_MONETARY_DUO_INT_FRAC_DIGITS,
                           _NL_MONETARY_DUO_CURRENCY_SYMBOL,
                           _NL_MONETARY_DUO_INT_CURR_SYMBOL,
                           __INT_N_SIGN_POSN, __INT_P_SIGN_POSN,
                           __INT_N_SEP_BY_SPACE, __INT_N_CS_PRECEDES,
                           __INT_P_SEP_BY_SPACE, __INT_P_CS_PRECEDES,
                           _NL_MONETARY_CRNCYSTR, __N_SIGN_POSN,
                           __P_SIGN_POSN, __N_SEP_BY_SPACE, __N_CS_PRECEDES,
                           __P_SEP_BY_SPACE, __P_CS_PRECEDES, __FRAC_DIGITS,
                           __INT_FRAC_DIGITS, __NEGATIVE_SIGN,
                           __POSITIVE_SIGN, __MON_GROUPING,
                           __MON_THOUSANDS_SEP, __MON_DECIMAL_POINT,
                           __CURRENCY_SYMBOL, __INT_CURR_SYMBOL,
                           _NL_NUM_LC_CTYPE, _NL_CTYPE_EXTRA_MAP_14,
                           _NL_CTYPE_EXTRA_MAP_13, _NL_CTYPE_EXTRA_MAP_12,
                           _NL_CTYPE_EXTRA_MAP_11, _NL_CTYPE_EXTRA_MAP_10,
                           _NL_CTYPE_EXTRA_MAP_9, _NL_CTYPE_EXTRA_MAP_8,
                           _NL_CTYPE_EXTRA_MAP_7, _NL_CTYPE_EXTRA_MAP_6,
                           _NL_CTYPE_EXTRA_MAP_5, _NL_CTYPE_EXTRA_MAP_4,
                           _NL_CTYPE_EXTRA_MAP_3, _NL_CTYPE_EXTRA_MAP_2,
                           _NL_CTYPE_EXTRA_MAP_1, _NL_CTYPE_NONASCII_CASE,
                           _NL_CTYPE_MAP_TO_NONASCII,
                           _NL_CTYPE_TRANSLIT_IGNORE,
                           _NL_CTYPE_TRANSLIT_IGNORE_LEN,
                           _NL_CTYPE_TRANSLIT_DEFAULT_MISSING,
                           _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN,
                           _NL_CTYPE_TRANSLIT_TO_TBL,
                           _NL_CTYPE_TRANSLIT_TO_IDX,
                           _NL_CTYPE_TRANSLIT_FROM_TBL,
                           _NL_CTYPE_TRANSLIT_FROM_IDX,
                           _NL_CTYPE_TRANSLIT_TAB_SIZE,
                           _NL_CTYPE_OUTDIGIT9_WC, _NL_CTYPE_OUTDIGIT8_WC,
                           _NL_CTYPE_OUTDIGIT7_WC, _NL_CTYPE_OUTDIGIT6_WC,
                           _NL_CTYPE_OUTDIGIT5_WC, _NL_CTYPE_OUTDIGIT4_WC,
                           _NL_CTYPE_OUTDIGIT3_WC, _NL_CTYPE_OUTDIGIT2_WC,
                           _NL_CTYPE_OUTDIGIT1_WC, _NL_CTYPE_OUTDIGIT0_WC,
                           _NL_CTYPE_OUTDIGIT9_MB, _NL_CTYPE_OUTDIGIT8_MB,
                           _NL_CTYPE_OUTDIGIT7_MB, _NL_CTYPE_OUTDIGIT6_MB,
                           _NL_CTYPE_OUTDIGIT5_MB, _NL_CTYPE_OUTDIGIT4_MB,
                           _NL_CTYPE_OUTDIGIT3_MB, _NL_CTYPE_OUTDIGIT2_MB,
                           _NL_CTYPE_OUTDIGIT1_MB, _NL_CTYPE_OUTDIGIT0_MB,
                           _NL_CTYPE_INDIGITS9_WC, _NL_CTYPE_INDIGITS8_WC,
                           _NL_CTYPE_INDIGITS7_WC, _NL_CTYPE_INDIGITS6_WC,
                           _NL_CTYPE_INDIGITS5_WC, _NL_CTYPE_INDIGITS4_WC,
                           _NL_CTYPE_INDIGITS3_WC, _NL_CTYPE_INDIGITS2_WC,
                           _NL_CTYPE_INDIGITS1_WC, _NL_CTYPE_INDIGITS0_WC,
                           _NL_CTYPE_INDIGITS_WC_LEN, _NL_CTYPE_INDIGITS9_MB,
                           _NL_CTYPE_INDIGITS8_MB, _NL_CTYPE_INDIGITS7_MB,
                           _NL_CTYPE_INDIGITS6_MB, _NL_CTYPE_INDIGITS5_MB,
                           _NL_CTYPE_INDIGITS4_MB, _NL_CTYPE_INDIGITS3_MB,
                           _NL_CTYPE_INDIGITS2_MB, _NL_CTYPE_INDIGITS1_MB,
                           _NL_CTYPE_INDIGITS0_MB, _NL_CTYPE_INDIGITS_MB_LEN,
                           _NL_CTYPE_MAP_OFFSET, _NL_CTYPE_CLASS_OFFSET,
                           _NL_CTYPE_TOLOWER32, _NL_CTYPE_TOUPPER32,
                           _NL_CTYPE_CODESET_NAME, _NL_CTYPE_MB_CUR_MAX,
                           _NL_CTYPE_WIDTH, _NL_CTYPE_MAP_NAMES,
                           _NL_CTYPE_CLASS_NAMES, _NL_CTYPE_GAP6,
                           _NL_CTYPE_GAP5, _NL_CTYPE_GAP4, _NL_CTYPE_GAP3,
                           _NL_CTYPE_CLASS32, _NL_CTYPE_GAP2,
                           _NL_CTYPE_TOLOWER, _NL_CTYPE_GAP1,
                           _NL_CTYPE_TOUPPER, _NL_CTYPE_CLASS,
                           _NL_NUM_LC_COLLATE, _NL_COLLATE_CODESET,
                           _NL_COLLATE_COLLSEQWC, _NL_COLLATE_COLLSEQMB,
                           _NL_COLLATE_SYMB_EXTRAMB, _NL_COLLATE_SYMB_TABLEMB,
                           _NL_COLLATE_SYMB_HASH_SIZEMB,
                           _NL_COLLATE_INDIRECTWC, _NL_COLLATE_EXTRAWC,
                           _NL_COLLATE_WEIGHTWC, _NL_COLLATE_TABLEWC,
                           _NL_COLLATE_GAP3, _NL_COLLATE_GAP2,
                           _NL_COLLATE_GAP1, _NL_COLLATE_INDIRECTMB,
                           _NL_COLLATE_EXTRAMB, _NL_COLLATE_WEIGHTMB,
                           _NL_COLLATE_TABLEMB, _NL_COLLATE_RULESETS,
                           _NL_COLLATE_NRULES, _NL_NUM_LC_TIME,
                           _NL_WABALTMON_12, _NL_WABALTMON_11,
                           _NL_WABALTMON_10, _NL_WABALTMON_9, _NL_WABALTMON_8,
                           _NL_WABALTMON_7, _NL_WABALTMON_6, _NL_WABALTMON_5,
                           _NL_WABALTMON_4, _NL_WABALTMON_3, _NL_WABALTMON_2,
                           _NL_WABALTMON_1, _NL_ABALTMON_12, _NL_ABALTMON_11,
                           _NL_ABALTMON_10, _NL_ABALTMON_9, _NL_ABALTMON_8,
                           _NL_ABALTMON_7, _NL_ABALTMON_6, _NL_ABALTMON_5,
                           _NL_ABALTMON_4, _NL_ABALTMON_3, _NL_ABALTMON_2,
                           _NL_ABALTMON_1, _NL_WALTMON_12, _NL_WALTMON_11,
                           _NL_WALTMON_10, _NL_WALTMON_9, _NL_WALTMON_8,
                           _NL_WALTMON_7, _NL_WALTMON_6, _NL_WALTMON_5,
                           _NL_WALTMON_4, _NL_WALTMON_3, _NL_WALTMON_2,
                           _NL_WALTMON_1, __ALTMON_12, __ALTMON_11,
                           __ALTMON_10, __ALTMON_9, __ALTMON_8, __ALTMON_7,
                           __ALTMON_6, __ALTMON_5, __ALTMON_4, __ALTMON_3,
                           __ALTMON_2, __ALTMON_1, _NL_TIME_CODESET,
                           _NL_W_DATE_FMT, _DATE_FMT, _NL_TIME_TIMEZONE,
                           _NL_TIME_CAL_DIRECTION, _NL_TIME_FIRST_WORKDAY,
                           _NL_TIME_FIRST_WEEKDAY, _NL_TIME_WEEK_1STWEEK,
                           _NL_TIME_WEEK_1STDAY, _NL_TIME_WEEK_NDAYS,
                           _NL_WERA_T_FMT, _NL_WERA_D_T_FMT, _NL_WALT_DIGITS,
                           _NL_WERA_D_FMT, _NL_WERA_YEAR, _NL_WT_FMT_AMPM,
                           _NL_WT_FMT, _NL_WD_FMT, _NL_WD_T_FMT, _NL_WPM_STR,
                           _NL_WAM_STR, _NL_WMON_12, _NL_WMON_11, _NL_WMON_10,
                           _NL_WMON_9, _NL_WMON_8, _NL_WMON_7, _NL_WMON_6,
                           _NL_WMON_5, _NL_WMON_4, _NL_WMON_3, _NL_WMON_2,
                           _NL_WMON_1, _NL_WABMON_12, _NL_WABMON_11,
                           _NL_WABMON_10, _NL_WABMON_9, _NL_WABMON_8,
                           _NL_WABMON_7, _NL_WABMON_6, _NL_WABMON_5,
                           _NL_WABMON_4, _NL_WABMON_3, _NL_WABMON_2,
                           _NL_WABMON_1, _NL_WDAY_7, _NL_WDAY_6, _NL_WDAY_5,
                           _NL_WDAY_4, _NL_WDAY_3, _NL_WDAY_2, _NL_WDAY_1,
                           _NL_WABDAY_7, _NL_WABDAY_6, _NL_WABDAY_5,
                           _NL_WABDAY_4, _NL_WABDAY_3, _NL_WABDAY_2,
                           _NL_WABDAY_1, _NL_TIME_ERA_ENTRIES,
                           _NL_TIME_ERA_NUM_ENTRIES, ERA_T_FMT, ERA_D_T_FMT,
                           ALT_DIGITS, ERA_D_FMT, __ERA_YEAR, ERA, T_FMT_AMPM,
                           T_FMT, D_FMT, D_T_FMT, PM_STR, AM_STR, MON_12,
                           MON_11, MON_10, MON_9, MON_8, MON_7, MON_6, MON_5,
                           MON_4, MON_3, MON_2, MON_1, ABMON_12, ABMON_11,
                           ABMON_10, ABMON_9, ABMON_8, ABMON_7, ABMON_6,
                           ABMON_5, ABMON_4, ABMON_3, ABMON_2, ABMON_1, DAY_7,
                           DAY_6, DAY_5, DAY_4, DAY_3, DAY_2, DAY_1, ABDAY_7,
                           ABDAY_6, ABDAY_5, ABDAY_4, ABDAY_3, ABDAY_2,
                           ABDAY_1, CODESET_0, nl_langinfo};
pub use self::nl_types_h::nl_item;
pub use self::struct_iovec_h::iovec;
pub use self::uv_h::{uv_loop_s, uv_signal_t, uv_signal_s, C2RustUnnamed_15,
                     uv_signal_cb, uv_handle_t, uv_handle_s, C2RustUnnamed_16,
                     uv_close_cb, uv_handle_type, UV_HANDLE_TYPE_MAX, UV_FILE,
                     UV_SIGNAL, UV_UDP, UV_TTY, UV_TIMER, UV_TCP, UV_STREAM,
                     UV_PROCESS, UV_PREPARE, UV_POLL, UV_NAMED_PIPE, UV_IDLE,
                     UV_HANDLE, UV_FS_POLL, UV_FS_EVENT, UV_CHECK, UV_ASYNC,
                     UV_UNKNOWN_HANDLE, uv_loop_t, C2RustUnnamed_17,
                     C2RustUnnamed_18, uv_async_t, uv_async_s, uv_async_cb,
                     C2RustUnnamed_19, C2RustUnnamed_20, uv_req_type,
                     UV_REQ_TYPE_MAX, UV_GETNAMEINFO, UV_GETADDRINFO, UV_WORK,
                     UV_FS, UV_UDP_SEND, UV_SHUTDOWN, UV_WRITE, UV_CONNECT,
                     UV_REQ, UV_UNKNOWN_REQ, uv_stream_s, uv_connection_cb,
                     uv_stream_t, uv_shutdown_t, uv_shutdown_s,
                     uv_shutdown_cb, uv_connect_t, uv_connect_s,
                     uv_connect_cb, uv_read_cb, uv_alloc_cb, C2RustUnnamed_21,
                     uv_tcp_s, C2RustUnnamed_22, uv_tcp_t, uv_pipe_s,
                     C2RustUnnamed_23, uv_pipe_t, uv_timer_s, uv_timer_cb,
                     uv_timer_t, C2RustUnnamed_24, uv_idle_s, uv_idle_cb,
                     uv_idle_t, C2RustUnnamed_25, uv_process_s, uv_exit_cb,
                     uv_process_t, C2RustUnnamed_26, uv_stdio_flags,
                     UV_OVERLAPPED_PIPE, UV_WRITABLE_PIPE, UV_READABLE_PIPE,
                     UV_INHERIT_STREAM, UV_INHERIT_FD, UV_CREATE_PIPE,
                     UV_IGNORE, uv_stdio_container_s, C2RustUnnamed_27,
                     uv_stdio_container_t, uv_process_options_s,
                     uv_process_options_t};
pub use self::unix_h::{uv__io_t, uv__io_s, uv__io_cb, uv_rwlock_t, uv_mutex_t,
                       uv_buf_t, uv_file, uv_gid_t, uv_uid_t};
pub use self::event_defs_h::{argv_callback, message, Event, event_create};
pub use self::multiqueue_h::{MultiQueue, multiqueue};
pub use self::loop_h::{WatcherPtr, __kl1_WatcherPtr, kl1_WatcherPtr,
                       kmp_WatcherPtr_t, kl_WatcherPtr_t, loop_0, Loop,
                       kmp_init_WatcherPtr, kmp_destroy_WatcherPtr,
                       kmp_alloc_WatcherPtr, kmp_free_WatcherPtr,
                       kl_init_WatcherPtr, kl_destroy_WatcherPtr,
                       kl_push_WatcherPtr, kl_shift_at_WatcherPtr};
pub use self::rbuffer_h::{rbuffer, rbuffer_callback, RBuffer, rbuffer_size};
pub use self::stream_h::{stream, stream_close_cb, Stream, stream_write_cb,
                         stream_read_cb, C2RustUnnamed_28};
pub use self::process_h::{ProcessType, kProcessTypePty, kProcessTypeUv,
                          process, internal_process_cb, Process,
                          process_exit_cb, process_init, process_is_stopped};
pub use self::ioctl_types_h::winsize;
pub use self::pty_process_unix_h::{pty_process, PtyProcess, pty_process_init};
pub use self::libuv_process_h::{libuv_process, LibuvProcess,
                                libuv_process_init};
pub use self::zone_h::{msgpack_zone_finalizer, msgpack_zone_finalizer_array,
                       msgpack_zone_chunk_list, msgpack_zone,
                       msgpack_zone_malloc, MSGPACK_ZONE_ALIGN,
                       msgpack_zone_malloc_no_align,
                       msgpack_zone_push_finalizer, msgpack_zone_swap,
                       msgpack_zone_chunk, msgpack_zone_free,
                       msgpack_zone_malloc_expand,
                       msgpack_zone_push_finalizer_expand};
pub use self::object_h::{msgpack_object_type, MSGPACK_OBJECT_EXT,
                         MSGPACK_OBJECT_BIN, MSGPACK_OBJECT_MAP,
                         MSGPACK_OBJECT_ARRAY, MSGPACK_OBJECT_STR,
                         MSGPACK_OBJECT_FLOAT, MSGPACK_OBJECT_FLOAT64,
                         MSGPACK_OBJECT_FLOAT32,
                         MSGPACK_OBJECT_NEGATIVE_INTEGER,
                         MSGPACK_OBJECT_POSITIVE_INTEGER,
                         MSGPACK_OBJECT_BOOLEAN, MSGPACK_OBJECT_NIL,
                         msgpack_object, msgpack_object_union,
                         msgpack_object_ext, msgpack_object_bin,
                         msgpack_object_str, msgpack_object_map,
                         msgpack_object_kv, msgpack_object_array};
pub use self::pack_h::{msgpack_packer_write, msgpack_packer,
                       msgpack_packer_init, msgpack_packer_new,
                       msgpack_packer_free};
pub use self::pack_template_h::{C2RustUnnamed_29, C2RustUnnamed_30,
                                msgpack_pack_char, msgpack_pack_signed_char,
                                msgpack_pack_short, msgpack_pack_int,
                                msgpack_pack_long, msgpack_pack_long_long,
                                msgpack_pack_unsigned_char,
                                msgpack_pack_unsigned_short,
                                msgpack_pack_unsigned_int,
                                msgpack_pack_unsigned_long,
                                msgpack_pack_unsigned_long_long,
                                msgpack_pack_uint8, msgpack_pack_uint16,
                                msgpack_pack_uint32, msgpack_pack_uint64,
                                msgpack_pack_int8, msgpack_pack_int16,
                                msgpack_pack_int32, msgpack_pack_int64,
                                msgpack_pack_fix_uint8,
                                msgpack_pack_fix_uint16,
                                msgpack_pack_fix_uint32,
                                msgpack_pack_fix_uint64,
                                msgpack_pack_fix_int8, msgpack_pack_fix_int16,
                                msgpack_pack_fix_int32,
                                msgpack_pack_fix_int64, msgpack_pack_float,
                                msgpack_pack_double, msgpack_pack_nil,
                                msgpack_pack_true, msgpack_pack_false,
                                msgpack_pack_array, msgpack_pack_map,
                                msgpack_pack_str, msgpack_pack_str_body,
                                msgpack_pack_v4raw, msgpack_pack_v4raw_body,
                                msgpack_pack_bin, msgpack_pack_bin_body,
                                msgpack_pack_ext, msgpack_pack_ext_body};
pub use self::unpack_h::{msgpack_unpacked, msgpack_unpacker,
                         msgpack_unpacker_reserve_buffer,
                         msgpack_unpacker_buffer,
                         msgpack_unpacker_buffer_capacity,
                         msgpack_unpacker_buffer_consumed,
                         msgpack_unpacked_init, msgpack_unpacked_destroy,
                         msgpack_unpacked_release_zone,
                         msgpack_unpacker_message_size,
                         msgpack_unpacker_parsed_size,
                         msgpack_unpacker_expand_buffer};
pub use self::sbuffer_h::{msgpack_sbuffer, msgpack_sbuffer_init,
                          msgpack_sbuffer_destroy, msgpack_sbuffer_new,
                          msgpack_sbuffer_free, msgpack_sbuffer_write,
                          MSGPACK_SBUFFER_INIT_SIZE, msgpack_sbuffer_release,
                          msgpack_sbuffer_clear};
pub use self::vrefbuffer_h::{msgpack_vrefbuffer_inner_buffer,
                             msgpack_vrefbuffer, msgpack_vrefbuffer_new,
                             msgpack_vrefbuffer_free,
                             msgpack_vrefbuffer_write, msgpack_vrefbuffer_vec,
                             msgpack_vrefbuffer_veclen,
                             msgpack_vrefbuffer_chunk,
                             msgpack_vrefbuffer_init,
                             msgpack_vrefbuffer_destroy,
                             msgpack_vrefbuffer_append_ref,
                             msgpack_vrefbuffer_append_copy};
pub use self::channel_h::{Channel, CallbackReader, C2RustUnnamed_32,
                          StderrState, StdioPair, ChannelStreamType,
                          kChannelStreamInternal, kChannelStreamStderr,
                          kChannelStreamStdio, kChannelStreamSocket,
                          kChannelStreamProc, callback_reader_set,
                          find_channel, channel_instream, channel_outstream,
                          channels};
pub use self::channel_defs_h::{RpcState, C2RustUnnamed_31, ChannelCallFrame};
pub use self::fileio_h::{FileDescriptor, file_eof, file_fd};
pub use self::stdint_h::SIZE_MAX;
pub use self::stdbool_h::{true_0, false_0};
use self::string_h::{strcpy, strcmp, strncmp, strchr, strlen, memcpy, memset,
                     memmove};
use self::strings_h::strncasecmp;
pub use self::byteswap_h::{__bswap_32, __bswap_16, __bswap_64};
pub use self::uintn_identity_h::{__uint64_identity, __uint32_identity,
                                 __uint16_identity};
use self::wctype_wchar_h::{towlower, towupper};
use self::stdlib_h::{malloc, calloc, realloc, free, abort};
pub use self::assert_h::{__ASSERT_FUNCTION, __ASSERT_FUNCTION_0,
                         __assert_fail};
use self::log_h_generated_h::logmsg;
pub use self::log_h::WARN_LOG_LEVEL;
pub use self::errno_h::{errno, __errno_location};
pub use self::macros_h::{TOUPPER_LOC, TOLOWER_LOC};
use self::message_h_generated_h::{msg, emsgf};
pub use self::vim_h::{OK, FAIL};
use self::memory_h_generated_h::{xfree, xmalloc, xcalloc, xrealloc};
pub use self::errno_base_h::{E2BIG, EINVAL};
pub use self::nvim_iconv_h::{ICONV_E2BIG, ICONV_ERRNO, ICONV_EINVAL,
                             ICONV_EILSEQ};
pub use self::asm_generic_errno_h::EILSEQ;
use self::strings_h_generated_h::{vim_strsave, vim_strchr};
use self::libintl_h::gettext;
pub use self::nvim_strings_h::strappend;
pub use self::kvec_h::_memcpy_free;
use self::in_h::{ntohl, ntohs};
pub use self::ascii_h::{NUL, TAB, NL, CSI, ascii_iswhite, ascii_isdigit,
                        ascii_isxdigit, ascii_isident, ascii_isbdigit,
                        ascii_isspace};
pub use self::locale_h::__LC_CTYPE;
pub use self::include_locale_h::{LC_CTYPE, setlocale};
pub use self::charset_h::{vim_isbreak, char2cells, ptr2cells, vim_iswordc_tab,
                          vim_isprintc};
use self::cursor_h_generated_h::get_cursor_pos_ptr;
use self::env_h_generated_h::os_getenv;
use self::memline_h_generated_h::ml_get_buf;
use self::misc1_h_generated_h::beep_flush;
use self::arabic_h_generated_h::{arabic_combine, arabic_maycombine};
pub use self::arabic_h::arabic_char;
pub use self::mark_h::{mark_local_index, equalpos, ltoreq, clearpos,
                       mark_global_index, lt};
use self::mark_h_generated_h::mark_mb_adjustpos;
pub use self::unicode_tables_generated_h::{toLower, toUpper, combining,
                                           foldCase, doublewidth, ambiguous,
                                           emoji_all, emoji_width};
/*
 * Canonical encoding names and their properties.
 * "iso-8859-n" is handled by enc_canonize() directly.
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "128:8"]
pub struct C2RustUnnamed_2 {
    pub name: *const libc::c_char,
    pub prop: libc::c_int,
    pub codepage: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "66:8"]
pub struct interval {
    pub first: libc::c_long,
    pub last: libc::c_long,
}
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "1071:17"]
pub struct clinterval {
    pub first: libc::c_uint,
    pub last: libc::c_uint,
    pub class: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "59:9"]
pub struct convertStruct {
    pub rangeStart: libc::c_int,
    pub rangeEnd: libc::c_int,
    pub step: libc::c_int,
    pub offset: libc::c_int,
}
/*
 * Aliases for encoding names.
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "264:8"]
pub struct C2RustUnnamed_13 {
    pub name: *const libc::c_char,
    pub canon: libc::c_int,
}
#[no_mangle]
#[c2rust::src_loc = "76:8"]
pub static mut e_loadlib: [char_u; 32] =
    unsafe {
        *::std::mem::transmute::<&[u8; 32],
                                 &mut [char_u; 32]>(b"E370: Could not load library %s\x00")
    };
#[no_mangle]
#[c2rust::src_loc = "77:8"]
pub static mut e_loadfunc: [char_u; 41] =
    unsafe {
        *::std::mem::transmute::<&[u8; 41],
                                 &mut [char_u; 41]>(b"E448: Could not load library function %s\x00")
    };
// To speed up BYTELEN(); keep a lookup table to quickly get the length in
// bytes of a UTF-8 character from the first byte of a UTF-8 string.  Bytes
// which are illegal when used as the first byte have a 1.  The NUL byte has
// length 1.
#[no_mangle]
#[c2rust::src_loc = "83:15"]
pub static mut utf8len_tab: [uint8_t; 256] =
    [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     5 as libc::c_int as uint8_t, 5 as libc::c_int as uint8_t,
     5 as libc::c_int as uint8_t, 5 as libc::c_int as uint8_t,
     6 as libc::c_int as uint8_t, 6 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t];
// Like utf8len_tab above, but using a zero for illegal lead bytes.
#[no_mangle]
#[c2rust::src_loc = "104:15"]
pub static mut utf8len_tab_zero: [uint8_t; 256] =
    [1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     1 as libc::c_int as uint8_t, 1 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     2 as libc::c_int as uint8_t, 2 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     3 as libc::c_int as uint8_t, 3 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     4 as libc::c_int as uint8_t, 4 as libc::c_int as uint8_t,
     5 as libc::c_int as uint8_t, 5 as libc::c_int as uint8_t,
     5 as libc::c_int as uint8_t, 5 as libc::c_int as uint8_t,
     6 as libc::c_int as uint8_t, 6 as libc::c_int as uint8_t,
     0 as libc::c_int as uint8_t, 0 as libc::c_int as uint8_t];
#[c2rust::src_loc = "130:1"]
static mut enc_canon_table: [C2RustUnnamed_2; 59] =
    [{
         let mut init =
             C2RustUnnamed_2{name:
                                 b"latin1\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT + ENC_LATIN1,
                             codepage: 1252 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-2\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-3\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-4\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-5\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-6\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-7\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-8\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-9\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-10\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-11\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-13\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-14\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"iso-8859-15\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT + ENC_LATIN9,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"koi8-r\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"koi8-u\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"utf-8\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"ucs-2\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_B + ENC_2BYTE,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"ucs-2le\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_L + ENC_2BYTE,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"utf-16\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_B + ENC_2WORD,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"utf-16le\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_L + ENC_2WORD,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"ucs-4\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_B + ENC_4BYTE,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"ucs-4le\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_UNICODE + ENC_ENDIAN_L + ENC_4BYTE,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"debug\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_DEBUG,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"euc-jp\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_JPNU,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"sjis\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_JPN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"euc-kr\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_KORU,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"euc-cn\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_CHSU,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"euc-tw\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_CHTU,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"big5\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_CHT,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp437\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 437 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp737\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 737 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp775\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 775 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp850\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 850 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp852\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 852 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp855\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 855 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp857\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 857 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp860\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 860 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp861\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 861 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp862\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 862 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp863\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 863 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp865\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 865 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp866\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 866 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp869\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 869 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp874\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 874 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp932\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_JPN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp936\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_CHS,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp949\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_KOR,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp950\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_DBCS,
                             codepage: DBCS_CHT,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1250\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1250 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1251\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1251 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1253\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1253 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1254\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1254 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1255\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1255 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1256\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1256 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1257\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1257 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"cp1258\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 1258 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"macroman\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT + ENC_MACROMAN,
                             codepage: 0 as libc::c_int,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_2{name:
                                 b"hp-roman8\x00" as *const u8 as
                                     *const libc::c_char,
                             prop: ENC_8BIT,
                             codepage: 0 as libc::c_int,};
         init
     }];
#[c2rust::src_loc = "132:9"]
pub const IDX_LATIN_1: libc::c_int = 0 as libc::c_int;
#[c2rust::src_loc = "134:9"]
pub const IDX_ISO_2: libc::c_int = 1 as libc::c_int;
#[c2rust::src_loc = "136:9"]
pub const IDX_ISO_3: libc::c_int = 2 as libc::c_int;
#[c2rust::src_loc = "138:9"]
pub const IDX_ISO_4: libc::c_int = 3 as libc::c_int;
#[c2rust::src_loc = "140:9"]
pub const IDX_ISO_5: libc::c_int = 4 as libc::c_int;
#[c2rust::src_loc = "142:9"]
pub const IDX_ISO_6: libc::c_int = 5 as libc::c_int;
#[c2rust::src_loc = "144:9"]
pub const IDX_ISO_7: libc::c_int = 6 as libc::c_int;
#[c2rust::src_loc = "146:9"]
pub const IDX_ISO_8: libc::c_int = 7 as libc::c_int;
#[c2rust::src_loc = "148:9"]
pub const IDX_ISO_9: libc::c_int = 8 as libc::c_int;
#[c2rust::src_loc = "150:9"]
pub const IDX_ISO_10: libc::c_int = 9 as libc::c_int;
#[c2rust::src_loc = "152:9"]
pub const IDX_ISO_11: libc::c_int = 10 as libc::c_int;
#[c2rust::src_loc = "154:9"]
pub const IDX_ISO_13: libc::c_int = 11 as libc::c_int;
#[c2rust::src_loc = "156:9"]
pub const IDX_ISO_14: libc::c_int = 12 as libc::c_int;
#[c2rust::src_loc = "158:9"]
pub const IDX_ISO_15: libc::c_int = 13 as libc::c_int;
#[c2rust::src_loc = "164:9"]
pub const IDX_UTF8: libc::c_int = 16 as libc::c_int;
#[c2rust::src_loc = "166:9"]
pub const IDX_UCS2: libc::c_int = 17 as libc::c_int;
#[c2rust::src_loc = "168:9"]
pub const IDX_UCS2LE: libc::c_int = 18 as libc::c_int;
#[c2rust::src_loc = "170:9"]
pub const IDX_UTF16: libc::c_int = 19 as libc::c_int;
#[c2rust::src_loc = "172:9"]
pub const IDX_UTF16LE: libc::c_int = 20 as libc::c_int;
#[c2rust::src_loc = "174:9"]
pub const IDX_UCS4: libc::c_int = 21 as libc::c_int;
#[c2rust::src_loc = "176:9"]
pub const IDX_UCS4LE: libc::c_int = 22 as libc::c_int;
#[c2rust::src_loc = "182:9"]
pub const IDX_EUC_JP: libc::c_int = 24 as libc::c_int;
#[c2rust::src_loc = "184:9"]
pub const IDX_SJIS: libc::c_int = 25 as libc::c_int;
#[c2rust::src_loc = "186:9"]
pub const IDX_EUC_KR: libc::c_int = 26 as libc::c_int;
#[c2rust::src_loc = "188:9"]
pub const IDX_EUC_CN: libc::c_int = 27 as libc::c_int;
#[c2rust::src_loc = "190:9"]
pub const IDX_EUC_TW: libc::c_int = 28 as libc::c_int;
#[c2rust::src_loc = "192:9"]
pub const IDX_BIG5: libc::c_int = 29 as libc::c_int;
#[c2rust::src_loc = "228:9"]
pub const IDX_CP932: libc::c_int = 45 as libc::c_int;
#[c2rust::src_loc = "230:9"]
pub const IDX_CP936: libc::c_int = 46 as libc::c_int;
#[c2rust::src_loc = "232:9"]
pub const IDX_CP949: libc::c_int = 47 as libc::c_int;
#[c2rust::src_loc = "234:9"]
pub const IDX_CP950: libc::c_int = 48 as libc::c_int;
#[c2rust::src_loc = "254:9"]
pub const IDX_MACROMAN: libc::c_int = 57 as libc::c_int;
#[c2rust::src_loc = "258:9"]
pub const IDX_COUNT: libc::c_int = 59 as libc::c_int;
#[c2rust::src_loc = "266:1"]
static mut enc_alias_table: [C2RustUnnamed_13; 64] =
    [{
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ansi\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_LATIN_1,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"iso-8859-1\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_LATIN_1,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin2\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_2,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin3\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_3,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin4\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"cyrillic\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_5,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"arabic\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_6,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"greek\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_7,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"hebrew\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_8,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin5\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_9,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"turkish\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_9,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin6\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_10,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"nordic\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_10,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"thai\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_11,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin7\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_13,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin8\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_14,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"latin9\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_ISO_15,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf8\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UTF8,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"unicode\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS2,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs2\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS2,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs2be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS2,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs-2be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS2,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs2le\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS2LE,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf16\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UTF16,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf16be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UTF16,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf-16be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UTF16,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf16le\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UTF16LE,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs4\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs4be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs-4be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ucs4le\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4LE,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf32\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf-32\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf32be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf-32be\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf32le\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4LE,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"utf-32le\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_UCS4LE,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"932\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_CP932,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"949\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_CP949,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"936\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_CP936,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"gbk\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_CP936,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"950\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_CP950,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"eucjp\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_JP,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"unix-jis\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_JP,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"ujis\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_JP,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"shift-jis\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_SJIS,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"pck\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_SJIS,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"euckr\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_KR,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"5601\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_KR,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"euccn\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_CN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"gb2312\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_CN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"euctw\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_TW,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"japan\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_JP,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"korea\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_KR,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"prc\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_CN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"zh-cn\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_CN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"chinese\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_CN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"zh-tw\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_TW,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"taiwan\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_EUC_TW,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"cp950\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_BIG5,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"950\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_BIG5,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"mac\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_MACROMAN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name:
                                  b"mac-roman\x00" as *const u8 as
                                      *const libc::c_char,
                              canon: IDX_MACROMAN,};
         init
     },
     {
         let mut init =
             C2RustUnnamed_13{name: NULL_0 as *const libc::c_char,
                              canon: 0 as libc::c_int,};
         init
     }];
/*
 * Find encoding "name" in the list of canonical encoding names.
 * Returns -1 if not found.
 */
#[c2rust::src_loc = "338:1"]
unsafe extern "C" fn enc_canon_search(mut name: *const char_u)
 -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < IDX_COUNT {
        if strcmp(name as *mut libc::c_char,
                  enc_canon_table[i as usize].name as *mut libc::c_char) ==
               0 as libc::c_int {
            return i
        }
        i += 1
    }
    return -(1 as libc::c_int);
}
/*
 * Find canonical encoding "name" in the list and return its properties.
 * Returns 0 if not found.
 */
#[no_mangle]
#[c2rust::src_loc = "354:1"]
pub unsafe extern "C" fn enc_canon_props(mut name: *const char_u)
 -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = enc_canon_search(name);
    if i >= 0 as libc::c_int { return enc_canon_table[i as usize].prop }
    if strncmp(name as *mut libc::c_char,
               b"2byte-\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 6 as libc::c_int as size_t) ==
           0 as libc::c_int {
        return ENC_DBCS
    }
    if strncmp(name as *mut libc::c_char,
               b"8bit-\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 5 as libc::c_int as size_t) ==
           0 as libc::c_int ||
           strncmp(name as *mut libc::c_char,
                   b"iso-8859-\x00" as *const u8 as *const libc::c_char as
                       *mut libc::c_char, 9 as libc::c_int as size_t) ==
               0 as libc::c_int {
        return ENC_8BIT
    }
    return 0 as libc::c_int;
}
/*
 * Return the size of the BOM for the current buffer:
 * 0 - no BOM
 * 2 - UCS-2 or UTF-16 BOM
 * 4 - UCS-4 BOM
 * 3 - UTF-8 BOM
 */
#[no_mangle]
#[c2rust::src_loc = "375:1"]
pub unsafe extern "C" fn bomb_size() -> libc::c_int {
    let mut n = 0 as libc::c_int;
    if (*curbuf).b_p_bomb != 0 && (*curbuf).b_p_bin == 0 {
        if *(*curbuf).b_p_fenc as libc::c_int == NUL ||
               strcmp((*curbuf).b_p_fenc as *mut libc::c_char,
                      b"utf-8\x00" as *const u8 as *const libc::c_char as
                          *mut libc::c_char) == 0 as libc::c_int {
            n = 3 as libc::c_int
        } else if strncmp((*curbuf).b_p_fenc as *mut libc::c_char,
                          b"ucs-2\x00" as *const u8 as *const libc::c_char as
                              *mut libc::c_char, 5 as libc::c_int as size_t)
                      == 0 as libc::c_int ||
                      strncmp((*curbuf).b_p_fenc as *mut libc::c_char,
                              b"utf-16\x00" as *const u8 as
                                  *const libc::c_char as *mut libc::c_char,
                              6 as libc::c_int as size_t) == 0 as libc::c_int
         {
            n = 2 as libc::c_int
        } else if strncmp((*curbuf).b_p_fenc as *mut libc::c_char,
                          b"ucs-4\x00" as *const u8 as *const libc::c_char as
                              *mut libc::c_char, 5 as libc::c_int as size_t)
                      == 0 as libc::c_int {
            n = 4 as libc::c_int
        }
    }
    return n;
}
/*
 * Remove all BOM from "s" by moving remaining text.
 */
#[no_mangle]
#[c2rust::src_loc = "396:1"]
pub unsafe extern "C" fn remove_bom(mut s: *mut char_u) {
    let mut p = s as *mut libc::c_char;
    loop  {
        p = strchr(p, 0xef as libc::c_int);
        if p.is_null() { break ; }
        if *p.offset(1 as libc::c_int as isize) as uint8_t as libc::c_int ==
               0xbb as libc::c_int &&
               *p.offset(2 as libc::c_int as isize) as uint8_t as libc::c_int
                   == 0xbf as libc::c_int {
            memmove(p as *mut libc::c_void,
                    p.offset(3 as libc::c_int as isize) as
                        *const libc::c_void,
                    strlen(p.offset(3 as libc::c_int as
                                        isize)).wrapping_add(1 as libc::c_int
                                                                 as
                                                                 libc::c_ulong));
        } else { p = p.offset(1) }
    };
}
/*
 * Get class of pointer:
 * 0 for blank or NUL
 * 1 for punctuation
 * 2 for an (ASCII) word character
 * >2 for other word characters
 */
#[no_mangle]
#[c2rust::src_loc = "416:1"]
pub unsafe extern "C" fn mb_get_class(mut p: *const char_u) -> libc::c_int {
    return mb_get_class_tab(p, (*curbuf).b_chartab.as_mut_ptr());
}
#[no_mangle]
#[c2rust::src_loc = "421:1"]
pub unsafe extern "C" fn mb_get_class_tab(mut p: *const char_u,
                                          chartab: *const uint64_t)
 -> libc::c_int {
    if utf8len_tab[*p.offset(0 as libc::c_int as isize) as usize] as
           libc::c_int == 1 as libc::c_int {
        if *p.offset(0 as libc::c_int as isize) as libc::c_int == NUL ||
               ascii_iswhite(*p.offset(0 as libc::c_int as isize) as
                                 libc::c_int) as libc::c_int != 0 {
            return 0 as libc::c_int
        }
        if vim_iswordc_tab(*p.offset(0 as libc::c_int as isize) as
                               libc::c_int, chartab) {
            return 2 as libc::c_int
        }
        return 1 as libc::c_int
    }
    return utf_class_tab(utf_ptr2char(p), chartab);
}
/*
 * Return true if "c" is in "table".
 */
#[c2rust::src_loc = "438:1"]
unsafe extern "C" fn intable(mut table: *const interval, mut n_items: size_t,
                             mut c: libc::c_int) -> bool {
    let mut mid: libc::c_int = 0;
    let mut bot: libc::c_int = 0;
    let mut top: libc::c_int = 0;
    /* first quick check for Latin1 etc. characters */
    if (c as libc::c_long) < (*table.offset(0 as libc::c_int as isize)).first
       {
        return false_0 != 0
    }
    /* binary search in table */
    bot = 0 as libc::c_int;
    top =
        n_items.wrapping_sub(1 as libc::c_int as libc::c_ulong) as
            libc::c_int;
    while top >= bot {
        mid = (bot + top) / 2 as libc::c_int;
        if (*table.offset(mid as isize)).last < c as libc::c_long {
            bot = mid + 1 as libc::c_int
        } else if (*table.offset(mid as isize)).first > c as libc::c_long {
            top = mid - 1 as libc::c_int
        } else { return true_0 != 0 }
    }
    return false_0 != 0;
}
// / For UTF-8 character "c" return 2 for a double-width character, 1 for others.
// / Returns 4 or 6 for an unprintable character.
// / Is only correct for characters >= 0x80.
// / When p_ambw is "double", return 2 for a character with East Asian Width
// / class 'A'(mbiguous).
// /
// / @note Tables `doublewidth` and `ambiguous` are generated by
// /       gen_unicode_tables.lua, which must be manually invoked as needed.
#[no_mangle]
#[c2rust::src_loc = "469:1"]
pub unsafe extern "C" fn utf_char2cells(mut c: libc::c_int) -> libc::c_int {
    if c >= 0x100 as libc::c_int {
        if !utf_printable(c) {
            return 6 as libc::c_int
            // unprintable, displays <xxxx>
        }
        if intable(doublewidth.as_ptr(),
                   (::std::mem::size_of::<[interval; 113]>() as
                        libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                        as
                                                        libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 113]>()
                                                                                          as
                                                                                          libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                          as
                                                                                                                          libc::c_ulong)
                                                                                         ==
                                                                                         0)
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        size_t),
                   c) {
            return 2 as libc::c_int
        }
        if p_emoji != 0 &&
               intable(emoji_width.as_ptr(),
                       (::std::mem::size_of::<[interval; 39]>() as
                            libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                            as
                                                            libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 39]>()
                                                                                              as
                                                                                              libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                              as
                                                                                                                              libc::c_ulong)
                                                                                             ==
                                                                                             0)
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            size_t),
                       c) as libc::c_int != 0 {
            return 2 as libc::c_int
        }
    } else if c >= 0x80 as libc::c_int && !vim_isprintc(c) {
        // Characters below 0x100 are influenced by 'isprint' option.
        return 4 as libc::c_int
        // unprintable, displays <xx>
    }
    if c >= 0x80 as libc::c_int && *p_ambw as libc::c_int == 'd' as i32 &&
           intable(ambiguous.as_ptr(),
                   (::std::mem::size_of::<[interval; 179]>() as
                        libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                        as
                                                        libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 179]>()
                                                                                          as
                                                                                          libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                          as
                                                                                                                          libc::c_ulong)
                                                                                         ==
                                                                                         0)
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        size_t),
                   c) as libc::c_int != 0 {
        return 2 as libc::c_int
    }
    return 1 as libc::c_int;
}
// / Return the number of display cells character at "*p" occupies.
// / This doesn't take care of unprintable characters, use ptr2cells() for that.
#[no_mangle]
#[c2rust::src_loc = "511:1"]
pub unsafe extern "C" fn utf_ptr2cells(mut p: *const char_u) -> libc::c_int {
    let mut c: libc::c_int = 0;
    /* Need to convert to a wide character. */
    if *p as libc::c_int >= 0x80 as libc::c_int {
        c = utf_ptr2char(p);
        /* An illegal byte is displayed as <xx>. */
        if utf_ptr2len(p) == 1 as libc::c_int || c == NUL {
            return 4 as libc::c_int
        }
        /* If the char is ASCII it must be an overlong sequence. */
        if c < 0x80 as libc::c_int { return char2cells(c) }
        return utf_char2cells(c)
    }
    return 1 as libc::c_int;
}
// / Like utf_ptr2cells(), but limit string length to "size".
// / For an empty string or truncated character returns 1.
#[no_mangle]
#[c2rust::src_loc = "531:1"]
pub unsafe extern "C" fn utf_ptr2cells_len(mut p: *const char_u,
                                           mut size: libc::c_int)
 -> libc::c_int {
    let mut c: libc::c_int = 0;
    /* Need to convert to a wide character. */
    if size > 0 as libc::c_int && *p as libc::c_int >= 0x80 as libc::c_int {
        if utf_ptr2len_len(p, size) < utf8len_tab[*p as usize] as libc::c_int
           {
            return 1 as libc::c_int
        } /* truncated */
        c = utf_ptr2char(p);
        /* An illegal byte is displayed as <xx>. */
        if utf_ptr2len(p) == 1 as libc::c_int || c == NUL {
            return 4 as libc::c_int
        }
        /* If the char is ASCII it must be an overlong sequence. */
        if c < 0x80 as libc::c_int { return char2cells(c) }
        return utf_char2cells(c)
    }
    return 1 as libc::c_int;
}
// / Calculate the number of cells occupied by string `str`.
// /
// / @param str The source string, may not be NULL, must be a NUL-terminated
// /            string.
// / @return The number of cells occupied by string `str`
#[no_mangle]
#[c2rust::src_loc = "556:1"]
pub unsafe extern "C" fn mb_string2cells(mut str: *const char_u) -> size_t {
    let mut clen = 0 as libc::c_int as size_t;
    let mut p = str;
    while *p as libc::c_int != NUL {
        clen =
            (clen as
                 libc::c_ulong).wrapping_add(utf_ptr2cells(p) as
                                                 libc::c_ulong) as size_t as
                size_t;
        p =
            p.offset(Some(Some(mb_ptr2len).expect("non-null function pointer")).expect("non-null function pointer")(p)
                         as isize)
    }
    return clen;
}
// / Get the number of cells occupied by string `str` with maximum length `size`
// /
// / @param str The source string, may not be NULL, must be a NUL-terminated
// /            string.
// / @param size maximum length of string. It will terminate on earlier NUL.
// / @return The number of cells occupied by string `str`
#[no_mangle]
#[c2rust::src_loc = "573:1"]
pub unsafe extern "C" fn mb_string2cells_len(mut str: *const char_u,
                                             mut size: size_t) -> size_t {
    let mut clen = 0 as libc::c_int as size_t;
    let mut p = str;
    while *p as libc::c_int != NUL && p < str.offset(size as isize) {
        clen =
            (clen as
                 libc::c_ulong).wrapping_add(utf_ptr2cells(p) as
                                                 libc::c_ulong) as size_t as
                size_t;
        p =
            p.offset(utf_ptr2len_len(p,
                                     size.wrapping_add(p.wrapping_offset_from(str)
                                                           as libc::c_long as
                                                           libc::c_ulong) as
                                         libc::c_int) as isize)
    }
    return clen;
}
// / Convert a UTF-8 byte sequence to a wide character
// /
// / If the sequence is illegal or truncated by a NUL then the first byte is
// / returned.
// / For an overlong sequence this may return zero.
// / Does not include composing characters for obvious reasons.
// /
// / @param[in]  p  String to convert.
// /
// / @return Unicode codepoint or byte value.
#[no_mangle]
#[c2rust::src_loc = "595:1"]
pub unsafe extern "C" fn utf_ptr2char(p: *const char_u) -> libc::c_int {
    if (*p.offset(0 as libc::c_int as isize) as libc::c_int) <
           0x80 as libc::c_int {
        // Be quick for ASCII.
        return *p.offset(0 as libc::c_int as isize) as libc::c_int
    }
    let len = utf8len_tab_zero[*p.offset(0 as libc::c_int as isize) as usize];
    if len as libc::c_int > 1 as libc::c_int &&
           *p.offset(1 as libc::c_int as isize) as libc::c_int &
               0xc0 as libc::c_int == 0x80 as libc::c_int {
        if len as libc::c_int == 2 as libc::c_int {
            return ((*p.offset(0 as libc::c_int as isize) as libc::c_int &
                         0x1f as libc::c_int) << 6 as libc::c_int) +
                       (*p.offset(1 as libc::c_int as isize) as libc::c_int &
                            0x3f as libc::c_int)
        }
        if *p.offset(2 as libc::c_int as isize) as libc::c_int &
               0xc0 as libc::c_int == 0x80 as libc::c_int {
            if len as libc::c_int == 3 as libc::c_int {
                return ((*p.offset(0 as libc::c_int as isize) as libc::c_int &
                             0xf as libc::c_int) << 12 as libc::c_int) +
                           ((*p.offset(1 as libc::c_int as isize) as
                                 libc::c_int & 0x3f as libc::c_int) <<
                                6 as libc::c_int) +
                           (*p.offset(2 as libc::c_int as isize) as
                                libc::c_int & 0x3f as libc::c_int)
            }
            if *p.offset(3 as libc::c_int as isize) as libc::c_int &
                   0xc0 as libc::c_int == 0x80 as libc::c_int {
                if len as libc::c_int == 4 as libc::c_int {
                    return ((*p.offset(0 as libc::c_int as isize) as
                                 libc::c_int & 0x7 as libc::c_int) <<
                                18 as libc::c_int) +
                               ((*p.offset(1 as libc::c_int as isize) as
                                     libc::c_int & 0x3f as libc::c_int) <<
                                    12 as libc::c_int) +
                               ((*p.offset(2 as libc::c_int as isize) as
                                     libc::c_int & 0x3f as libc::c_int) <<
                                    6 as libc::c_int) +
                               (*p.offset(3 as libc::c_int as isize) as
                                    libc::c_int & 0x3f as libc::c_int)
                }
                if *p.offset(4 as libc::c_int as isize) as libc::c_int &
                       0xc0 as libc::c_int == 0x80 as libc::c_int {
                    if len as libc::c_int == 5 as libc::c_int {
                        return ((*p.offset(0 as libc::c_int as isize) as
                                     libc::c_int & 0x3 as libc::c_int) <<
                                    24 as libc::c_int) +
                                   ((*p.offset(1 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        18 as libc::c_int) +
                                   ((*p.offset(2 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        12 as libc::c_int) +
                                   ((*p.offset(3 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        6 as libc::c_int) +
                                   (*p.offset(4 as libc::c_int as isize) as
                                        libc::c_int & 0x3f as libc::c_int)
                    }
                    if *p.offset(5 as libc::c_int as isize) as libc::c_int &
                           0xc0 as libc::c_int == 0x80 as libc::c_int &&
                           len as libc::c_int == 6 as libc::c_int {
                        return ((*p.offset(0 as libc::c_int as isize) as
                                     libc::c_int & 0x1 as libc::c_int) <<
                                    30 as libc::c_int) +
                                   ((*p.offset(1 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        24 as libc::c_int) +
                                   ((*p.offset(2 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        18 as libc::c_int) +
                                   ((*p.offset(3 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        12 as libc::c_int) +
                                   ((*p.offset(4 as libc::c_int as isize) as
                                         libc::c_int & 0x3f as libc::c_int) <<
                                        6 as libc::c_int) +
                                   (*p.offset(5 as libc::c_int as isize) as
                                        libc::c_int & 0x3f as libc::c_int)
                    }
                }
            }
        }
    }
    // Illegal value: just return the first byte.
    return *p.offset(0 as libc::c_int as isize) as libc::c_int;
}
/*
 * Convert a UTF-8 byte sequence to a wide character.
 * String is assumed to be terminated by NUL or after "n" bytes, whichever
 * comes first.
 * The function is safe in the sense that it never accesses memory beyond the
 * first "n" bytes of "s".
 *
 * On success, returns decoded codepoint, advances "s" to the beginning of
 * next character and decreases "n" accordingly.
 *
 * If end of string was reached, returns 0 and, if "n" > 0, advances "s" past
 * NUL byte.
 *
 * If byte sequence is illegal or incomplete, returns -1 and does not advance
 * "s".
 */
#[c2rust::src_loc = "652:1"]
unsafe extern "C" fn utf_safe_read_char_adv(mut s: *mut *const char_u,
                                            mut n: *mut size_t)
 -> libc::c_int {
    let mut c: libc::c_int = 0;
    if *n == 0 as libc::c_int as libc::c_ulong {
        /* end of buffer */
        return 0 as libc::c_int
    }
    let mut k = utf8len_tab_zero[**s as usize];
    if k as libc::c_int == 1 as libc::c_int {
        /* ASCII character or NUL */
        *n = (*n).wrapping_sub(1);
        let fresh3 = *s;
        *s = (*s).offset(1);
        return *fresh3 as libc::c_int
    }
    if k as libc::c_ulong <= *n {
        /* We have a multibyte sequence and it isn't truncated by buffer
     * limits so utf_ptr2char() is safe to use. Or the first byte is
     * illegal (k=0), and it's also safe to use utf_ptr2char(). */
        c = utf_ptr2char(*s);
        /* On failure, utf_ptr2char() returns the first byte, so here we
     * check equality with the first byte. The only non-ASCII character
     * which equals the first byte of its own UTF-8 representation is
     * U+00C3 (UTF-8: 0xC3 0x83), so need to check that special case too.
     * It's safe even if n=1, else we would have k=2 > n. */
        if c != **s as libc::c_int ||
               c == 0xc3 as libc::c_int &&
                   *(*s).offset(1 as libc::c_int as isize) as libc::c_int ==
                       0x83 as libc::c_int {
            /* byte sequence was successfully decoded */
            *s = (*s).offset(k as libc::c_int as isize);
            *n =
                (*n as libc::c_ulong).wrapping_sub(k as libc::c_ulong) as
                    size_t as size_t;
            return c
        }
    }
    /* byte sequence is incomplete or illegal */
    return -(1 as libc::c_int);
}
/*
 * Get character at **pp and advance *pp to the next character.
 * Note: composing characters are skipped!
 */
#[no_mangle]
#[c2rust::src_loc = "694:1"]
pub unsafe extern "C" fn mb_ptr2char_adv(pp: *mut *const char_u)
 -> libc::c_int {
    let mut c: libc::c_int = 0;
    c = utf_ptr2char(*pp);
    *pp =
        (*pp).offset(Some(Some(mb_ptr2len).expect("non-null function pointer")).expect("non-null function pointer")(*pp)
                         as isize);
    return c;
}
/*
 * Get character at **pp and advance *pp to the next character.
 * Note: composing characters are returned as separate characters.
 */
#[no_mangle]
#[c2rust::src_loc = "707:1"]
pub unsafe extern "C" fn mb_cptr2char_adv(mut pp: *mut *const char_u)
 -> libc::c_int {
    let mut c: libc::c_int = 0;
    c = utf_ptr2char(*pp);
    *pp = (*pp).offset(utf_ptr2len(*pp) as isize);
    return c;
}
/*
 * Check if the character pointed to by "p2" is a composing character when it
 * comes after "p1".  For Arabic sometimes "ab" is replaced with "c", which
 * behaves like a composing character.
 */
#[no_mangle]
#[c2rust::src_loc = "721:1"]
pub unsafe extern "C" fn utf_composinglike(mut p1: *const char_u,
                                           mut p2: *const char_u) -> bool {
    let mut c2: libc::c_int = 0;
    c2 = utf_ptr2char(p2);
    if utf_iscomposing(c2) { return true_0 != 0 }
    if !arabic_maycombine(c2) { return false_0 != 0 }
    return arabic_combine(utf_ptr2char(p1), c2);
}
// / Convert a UTF-8 string to a wide character
// /
// / Also gets up to #MAX_MCO composing characters.
// /
// / @param[out]  pcc  Location where to store composing characters. Must have
// /                   space at least for #MAX_MCO + 1 elements.
// /
// / @return leading character.
#[no_mangle]
#[c2rust::src_loc = "741:1"]
pub unsafe extern "C" fn utfc_ptr2char(mut p: *const char_u,
                                       mut pcc: *mut libc::c_int)
 -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut cc: libc::c_int = 0;
    let mut i = 0 as libc::c_int;
    c = utf_ptr2char(p);
    len = utf_ptr2len(p);
    /* Only accept a composing char when the first char isn't illegal. */
    if (len > 1 as libc::c_int || (*p as libc::c_int) < 0x80 as libc::c_int)
           && *p.offset(len as isize) as libc::c_int >= 0x80 as libc::c_int &&
           utf_composinglike(p, p.offset(len as isize)) as libc::c_int != 0 {
        cc = utf_ptr2char(p.offset(len as isize));
        loop  {
            let fresh4 = i;
            i = i + 1;
            *pcc.offset(fresh4 as isize) = cc;
            if i == MAX_MCO { break ; }
            len += utf_ptr2len(p.offset(len as isize));
            if (*p.offset(len as isize) as libc::c_int) < 0x80 as libc::c_int
                   ||
                   {
                       cc = utf_ptr2char(p.offset(len as isize));
                       !utf_iscomposing(cc)
                   } {
                break ;
            }
        }
    }
    if i < MAX_MCO {
        /* last composing char must be 0 */
        *pcc.offset(i as isize) = 0 as libc::c_int
    }
    return c;
}
/*
 * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO
 * composing characters.  Use no more than p[maxlen].
 *
 * @param [out] pcc: composing chars, last one is 0
 */
#[no_mangle]
#[c2rust::src_loc = "778:1"]
pub unsafe extern "C" fn utfc_ptr2char_len(mut p: *const char_u,
                                           mut pcc: *mut libc::c_int,
                                           mut maxlen: libc::c_int)
 -> libc::c_int {
    if maxlen > 0 as libc::c_int {
    } else {
        __assert_fail(b"maxlen > 0\x00" as *const u8 as *const libc::c_char,
                      b"/home/vole/neovim/src/nvim/mbyte.c\x00" as *const u8
                          as *const libc::c_char,
                      783 as libc::c_int as libc::c_uint,
                      __ASSERT_FUNCTION.as_ptr());
    }
    let mut i = 0 as libc::c_int;
    let mut len = utf_ptr2len_len(p, maxlen);
    // Is it safe to use utf_ptr2char()?
    let mut safe = len > 1 as libc::c_int && len <= maxlen;
    let mut c =
        if safe as libc::c_int != 0 {
            utf_ptr2char(p)
        } else { *p as libc::c_int };
    // Only accept a composing char when the first char isn't illegal.
    if (safe as libc::c_int != 0 || c < 0x80 as libc::c_int) && len < maxlen
           && *p.offset(len as isize) as libc::c_int >= 0x80 as libc::c_int {
        while i < MAX_MCO {
            let mut len_cc =
                utf_ptr2len_len(p.offset(len as isize), maxlen - len);
            safe = len_cc > 1 as libc::c_int && len_cc <= maxlen - len;
            if !safe ||
                   {
                       let ref mut fresh5 = *pcc.offset(i as isize);
                       *fresh5 = utf_ptr2char(p.offset(len as isize));
                       (*fresh5) < 0x80 as libc::c_int
                   } ||
                   (if i == 0 as libc::c_int {
                        utf_composinglike(p, p.offset(len as isize)) as
                            libc::c_int
                    } else {
                        utf_iscomposing(*pcc.offset(i as isize)) as
                            libc::c_int
                    }) == 0 {
                break ;
            }
            len += len_cc;
            i += 1
        }
    }
    if i < MAX_MCO {
        // last composing char must be 0
        *pcc.offset(i as isize) = 0 as libc::c_int
    }
    return c;
}
// / Get the length of a UTF-8 byte sequence representing a single codepoint
// /
// / @param[in]  p  UTF-8 string.
// /
// / @return Sequence length, 0 for empty string and 1 for non-UTF-8 byte
// /         sequence.
#[no_mangle]
#[c2rust::src_loc = "820:1"]
pub unsafe extern "C" fn utf_ptr2len(p: *const char_u) -> libc::c_int {
    if *p as libc::c_int == NUL { return 0 as libc::c_int }
    let len = utf8len_tab[*p as usize] as libc::c_int;
    let mut i = 1 as libc::c_int;
    while i < len {
        if *p.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int !=
               0x80 as libc::c_int {
            return 1 as libc::c_int
        }
        i += 1
    }
    return len;
}
/*
 * Return length of UTF-8 character, obtained from the first byte.
 * "b" must be between 0 and 255!
 * Returns 1 for an invalid first byte value.
 */
#[no_mangle]
#[c2rust::src_loc = "840:1"]
pub unsafe extern "C" fn utf_byte2len(mut b: libc::c_int) -> libc::c_int {
    return utf8len_tab[b as usize] as libc::c_int;
}
/*
 * Get the length of UTF-8 byte sequence "p[size]".  Does not include any
 * following composing characters.
 * Returns 1 for "".
 * Returns 1 for an illegal byte sequence (also in incomplete byte seq.).
 * Returns number > "size" for an incomplete byte sequence.
 * Never returns zero.
 */
#[no_mangle]
#[c2rust::src_loc = "853:1"]
pub unsafe extern "C" fn utf_ptr2len_len(mut p: *const char_u,
                                         mut size: libc::c_int)
 -> libc::c_int {
    let mut len: libc::c_int = 0; /* NUL, ascii or illegal lead byte */
    let mut i: libc::c_int = 0; /* incomplete byte sequence. */
    let mut m: libc::c_int = 0;
    len = utf8len_tab[*p as usize] as libc::c_int;
    if len == 1 as libc::c_int { return 1 as libc::c_int }
    if len > size { m = size } else { m = len }
    i = 1 as libc::c_int;
    while i < m {
        if *p.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int !=
               0x80 as libc::c_int {
            return 1 as libc::c_int
        }
        i += 1
    }
    return len;
}
// / Return the number of bytes occupied by a UTF-8 character in a string
// /
// / This includes following composing characters.
#[no_mangle]
#[c2rust::src_loc = "875:1"]
pub unsafe extern "C" fn utfc_ptr2len(p: *const char_u) -> libc::c_int {
    let mut b0 = *p;
    if b0 as libc::c_int == NUL { return 0 as libc::c_int }
    if (b0 as libc::c_int) < 0x80 as libc::c_int &&
           (*p.offset(1 as libc::c_int as isize) as libc::c_int) <
               0x80 as libc::c_int {
        // be quick for ASCII
        return 1 as libc::c_int
    }
    // Skip over first UTF-8 char, stopping at a NUL byte.
    let mut len = utf_ptr2len(p);
    // Check for illegal byte.
    if len == 1 as libc::c_int && b0 as libc::c_int >= 0x80 as libc::c_int {
        return 1 as libc::c_int
    }
    // Check for composing characters.  We can handle only the first six, but
  // skip all of them (otherwise the cursor would get stuck).
    let mut prevlen = 0 as libc::c_int;
    loop  {
        if (*p.offset(len as isize) as libc::c_int) < 0x80 as libc::c_int ||
               !utf_composinglike(p.offset(prevlen as isize),
                                  p.offset(len as isize)) {
            return len
        }
        // Skip over composing char.
        prevlen = len;
        len += utf_ptr2len(p.offset(len as isize))
    };
}
/*
 * Return the number of bytes the UTF-8 encoding of the character at "p[size]"
 * takes.  This includes following composing characters.
 * Returns 0 for an empty string.
 * Returns 1 for an illegal char or an incomplete byte sequence.
 */
#[no_mangle]
#[c2rust::src_loc = "915:1"]
pub unsafe extern "C" fn utfc_ptr2len_len(mut p: *const char_u,
                                          mut size: libc::c_int)
 -> libc::c_int {
    let mut len: libc::c_int = 0;
    let mut prevlen: libc::c_int = 0;
    if size < 1 as libc::c_int || *p as libc::c_int == NUL {
        return 0 as libc::c_int
    }
    if (*p.offset(0 as libc::c_int as isize) as libc::c_int) <
           0x80 as libc::c_int &&
           (size == 1 as libc::c_int ||
                (*p.offset(1 as libc::c_int as isize) as libc::c_int) <
                    0x80 as libc::c_int) {
        /* be quick for ASCII */
        return 1 as libc::c_int
    }
    /* Skip over first UTF-8 char, stopping at a NUL byte. */
    len = utf_ptr2len_len(p, size);
    /* Check for illegal byte and incomplete byte sequence. */
    if len == 1 as libc::c_int &&
           *p.offset(0 as libc::c_int as isize) as libc::c_int >=
               0x80 as libc::c_int || len > size {
        return 1 as libc::c_int
    }
    /*
   * Check for composing characters.  We can handle only the first six, but
   * skip all of them (otherwise the cursor would get stuck).
   */
    prevlen = 0 as libc::c_int;
    while len < size {
        let mut len_next_char: libc::c_int = 0;
        if (*p.offset(len as isize) as libc::c_int) < 0x80 as libc::c_int {
            break ;
        }
        /*
     * Next character length should not go beyond size to ensure that
     * UTF_COMPOSINGLIKE(...) does not read beyond size.
     */
        len_next_char = utf_ptr2len_len(p.offset(len as isize), size - len);
        if len_next_char > size - len { break ; }
        if !utf_composinglike(p.offset(prevlen as isize),
                              p.offset(len as isize)) {
            break ;
        }
        /* Skip over composing char */
        prevlen = len;
        len += len_next_char
    }
    return len;
}
// / Determine how many bytes certain unicode codepoint will occupy
#[no_mangle]
#[c2rust::src_loc = "962:1"]
pub unsafe extern "C" fn utf_char2len(c: libc::c_int) -> libc::c_int {
    if c < 0x80 as libc::c_int {
        return 1 as libc::c_int
    } else if c < 0x800 as libc::c_int {
        return 2 as libc::c_int
    } else if c < 0x10000 as libc::c_int {
        return 3 as libc::c_int
    } else if c < 0x200000 as libc::c_int {
        return 4 as libc::c_int
    } else if c < 0x4000000 as libc::c_int {
        return 5 as libc::c_int
    } else { return 6 as libc::c_int };
}
// / Convert Unicode character to UTF-8 string
// /
// / @param c character to convert to \p buf
// / @param[out] buf UTF-8 string generated from \p c, does not add \0
// / @return Number of bytes (1-6).
#[no_mangle]
#[c2rust::src_loc = "984:1"]
pub unsafe extern "C" fn utf_char2bytes(c: libc::c_int, buf: *mut char_u)
 -> libc::c_int {
    if c < 0x80 as libc::c_int {
        // 7 bits
        *buf.offset(0 as libc::c_int as isize) = c as char_u;
        return 1 as libc::c_int
    } else if c < 0x800 as libc::c_int {
        // 11 bits
        *buf.offset(0 as libc::c_int as isize) =
            (0xc0 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                6 as libc::c_int) as char_u;
        *buf.offset(1 as libc::c_int as isize) =
            (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as char_u;
        return 2 as libc::c_int
    } else if c < 0x10000 as libc::c_int {
        // 16 bits
        *buf.offset(0 as libc::c_int as isize) =
            (0xe0 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                12 as libc::c_int) as char_u;
        *buf.offset(1 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                6 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(2 as libc::c_int as isize) =
            (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as char_u;
        return 3 as libc::c_int
    } else if c < 0x200000 as libc::c_int {
        // 21 bits
        *buf.offset(0 as libc::c_int as isize) =
            (0xf0 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                18 as libc::c_int) as
                char_u; // 31 bits
        *buf.offset(1 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                12 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(2 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                6 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(3 as libc::c_int as isize) =
            (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as char_u;
        return 4 as libc::c_int
    } else if c < 0x4000000 as libc::c_int {
        // 26 bits
        *buf.offset(0 as libc::c_int as isize) =
            (0xf8 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                24 as libc::c_int) as char_u;
        *buf.offset(1 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                18 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(2 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                12 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(3 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                6 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(4 as libc::c_int as isize) =
            (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as char_u;
        return 5 as libc::c_int
    } else {
        *buf.offset(0 as libc::c_int as isize) =
            (0xfc as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                30 as libc::c_int) as char_u;
        *buf.offset(1 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                24 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(2 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                18 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(3 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                12 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(4 as libc::c_int as isize) =
            (0x80 as libc::c_int as
                 libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                6 as libc::c_int &
                                                0x3f as libc::c_int as
                                                    libc::c_uint) as char_u;
        *buf.offset(5 as libc::c_int as isize) =
            (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as char_u;
        return 6 as libc::c_int
    };
}
/*
 * Return true if "c" is a composing UTF-8 character.  This means it will be
 * drawn on top of the preceding character.
 * Based on code from Markus Kuhn.
 */
#[no_mangle]
#[c2rust::src_loc = "1027:1"]
pub unsafe extern "C" fn utf_iscomposing(mut c: libc::c_int) -> bool {
    return intable(combining.as_ptr(),
                   (::std::mem::size_of::<[interval; 280]>() as
                        libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                        as
                                                        libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 280]>()
                                                                                          as
                                                                                          libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                          as
                                                                                                                          libc::c_ulong)
                                                                                         ==
                                                                                         0)
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        size_t),
                   c);
}
/*
 * Return true for characters that can be displayed in a normal way.
 * Only for characters of 0x100 and above!
 */
#[no_mangle]
#[c2rust::src_loc = "1036:1"]
pub unsafe extern "C" fn utf_printable(mut c: libc::c_int) -> bool {
    /* Sorted list of non-overlapping intervals.
   * 0xd800-0xdfff is reserved for UTF-16, actually illegal. */
    static mut nonprint: [interval; 9] =
        [{
             let mut init =
                 interval{first: 0x70f as libc::c_int as libc::c_long,
                          last: 0x70f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x180b as libc::c_int as libc::c_long,
                          last: 0x180e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x200b as libc::c_int as libc::c_long,
                          last: 0x200f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x202a as libc::c_int as libc::c_long,
                          last: 0x202e as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0x206a as libc::c_int as libc::c_long,
                          last: 0x206f as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xd800 as libc::c_int as libc::c_long,
                          last: 0xdfff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfeff as libc::c_int as libc::c_long,
                          last: 0xfeff as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfff9 as libc::c_int as libc::c_long,
                          last: 0xfffb as libc::c_int as libc::c_long,};
             init
         },
         {
             let mut init =
                 interval{first: 0xfffe as libc::c_int as libc::c_long,
                          last: 0xffff as libc::c_int as libc::c_long,};
             init
         }];
    return !intable(nonprint.as_mut_ptr(),
                    (::std::mem::size_of::<[interval; 9]>() as
                         libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                         as
                                                         libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 9]>()
                                                                                           as
                                                                                           libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                           as
                                                                                                                           libc::c_ulong)
                                                                                          ==
                                                                                          0)
                                                                                         as
                                                                                         libc::c_int
                                                                                         as
                                                                                         size_t),
                    c);
}
/*
 * Get class of a Unicode character.
 * 0: white space
 * 1: punctuation
 * 2 or bigger: some class of word character.
 */
#[no_mangle]
#[c2rust::src_loc = "1063:1"]
pub unsafe extern "C" fn utf_class(c: libc::c_int) -> libc::c_int {
    return utf_class_tab(c, (*curbuf).b_chartab.as_mut_ptr());
}
#[no_mangle]
#[c2rust::src_loc = "1068:1"]
pub unsafe extern "C" fn utf_class_tab(c: libc::c_int,
                                       chartab: *const uint64_t)
 -> libc::c_int {
    /* sorted list of non-overlapping intervals */
    static mut classes: [clinterval; 71] =
        [{
             let mut init =
                 clinterval{first: 0x37e as libc::c_int as libc::c_uint,
                            last: 0x37e as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x387 as libc::c_int as libc::c_uint,
                            last: 0x387 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x55a as libc::c_int as libc::c_uint,
                            last: 0x55f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x589 as libc::c_int as libc::c_uint,
                            last: 0x589 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x5be as libc::c_int as libc::c_uint,
                            last: 0x5be as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x5c0 as libc::c_int as libc::c_uint,
                            last: 0x5c0 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x5c3 as libc::c_int as libc::c_uint,
                            last: 0x5c3 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x5f3 as libc::c_int as libc::c_uint,
                            last: 0x5f4 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x60c as libc::c_int as libc::c_uint,
                            last: 0x60c as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x61b as libc::c_int as libc::c_uint,
                            last: 0x61b as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x61f as libc::c_int as libc::c_uint,
                            last: 0x61f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x66a as libc::c_int as libc::c_uint,
                            last: 0x66d as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x6d4 as libc::c_int as libc::c_uint,
                            last: 0x6d4 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x700 as libc::c_int as libc::c_uint,
                            last: 0x70d as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x964 as libc::c_int as libc::c_uint,
                            last: 0x965 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x970 as libc::c_int as libc::c_uint,
                            last: 0x970 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xdf4 as libc::c_int as libc::c_uint,
                            last: 0xdf4 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xe4f as libc::c_int as libc::c_uint,
                            last: 0xe4f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xe5a as libc::c_int as libc::c_uint,
                            last: 0xe5b as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xf04 as libc::c_int as libc::c_uint,
                            last: 0xf12 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xf3a as libc::c_int as libc::c_uint,
                            last: 0xf3d as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xf85 as libc::c_int as libc::c_uint,
                            last: 0xf85 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x104a as libc::c_int as libc::c_uint,
                            last: 0x104f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x10fb as libc::c_int as libc::c_uint,
                            last: 0x10fb as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1361 as libc::c_int as libc::c_uint,
                            last: 0x1368 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x166d as libc::c_int as libc::c_uint,
                            last: 0x166e as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1680 as libc::c_int as libc::c_uint,
                            last: 0x1680 as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x169b as libc::c_int as libc::c_uint,
                            last: 0x169c as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x16eb as libc::c_int as libc::c_uint,
                            last: 0x16ed as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1735 as libc::c_int as libc::c_uint,
                            last: 0x1736 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x17d4 as libc::c_int as libc::c_uint,
                            last: 0x17dc as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1800 as libc::c_int as libc::c_uint,
                            last: 0x180a as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2000 as libc::c_int as libc::c_uint,
                            last: 0x200b as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x200c as libc::c_int as libc::c_uint,
                            last: 0x2027 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2028 as libc::c_int as libc::c_uint,
                            last: 0x2029 as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x202a as libc::c_int as libc::c_uint,
                            last: 0x202e as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x202f as libc::c_int as libc::c_uint,
                            last: 0x202f as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2030 as libc::c_int as libc::c_uint,
                            last: 0x205e as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x205f as libc::c_int as libc::c_uint,
                            last: 0x205f as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2060 as libc::c_int as libc::c_uint,
                            last: 0x27ff as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2070 as libc::c_int as libc::c_uint,
                            last: 0x207f as libc::c_int as libc::c_uint,
                            class: 0x2070 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2080 as libc::c_int as libc::c_uint,
                            last: 0x2094 as libc::c_int as libc::c_uint,
                            class: 0x2080 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x20a0 as libc::c_int as libc::c_uint,
                            last: 0x27ff as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2800 as libc::c_int as libc::c_uint,
                            last: 0x28ff as libc::c_int as libc::c_uint,
                            class: 0x2800 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2900 as libc::c_int as libc::c_uint,
                            last: 0x2998 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x29d8 as libc::c_int as libc::c_uint,
                            last: 0x29db as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x29fc as libc::c_int as libc::c_uint,
                            last: 0x29fd as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2e00 as libc::c_int as libc::c_uint,
                            last: 0x2e7f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x3000 as libc::c_int as libc::c_uint,
                            last: 0x3000 as libc::c_int as libc::c_uint,
                            class: 0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x3001 as libc::c_int as libc::c_uint,
                            last: 0x3020 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x3030 as libc::c_int as libc::c_uint,
                            last: 0x3030 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x303d as libc::c_int as libc::c_uint,
                            last: 0x303d as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x3040 as libc::c_int as libc::c_uint,
                            last: 0x309f as libc::c_int as libc::c_uint,
                            class: 0x3040 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x30a0 as libc::c_int as libc::c_uint,
                            last: 0x30ff as libc::c_int as libc::c_uint,
                            class: 0x30a0 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x3300 as libc::c_int as libc::c_uint,
                            last: 0x9fff as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xac00 as libc::c_int as libc::c_uint,
                            last: 0xd7a3 as libc::c_int as libc::c_uint,
                            class: 0xac00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xf900 as libc::c_int as libc::c_uint,
                            last: 0xfaff as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xfd3e as libc::c_int as libc::c_uint,
                            last: 0xfd3f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xfe30 as libc::c_int as libc::c_uint,
                            last: 0xfe6b as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xff00 as libc::c_int as libc::c_uint,
                            last: 0xff0f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xff1a as libc::c_int as libc::c_uint,
                            last: 0xff20 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xff3b as libc::c_int as libc::c_uint,
                            last: 0xff40 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0xff5b as libc::c_int as libc::c_uint,
                            last: 0xff65 as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1d000 as libc::c_int as libc::c_uint,
                            last: 0x1d24f as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1d400 as libc::c_int as libc::c_uint,
                            last: 0x1d7ff as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1f000 as libc::c_int as libc::c_uint,
                            last: 0x1f2ff as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x1f300 as libc::c_int as libc::c_uint,
                            last: 0x1f9ff as libc::c_int as libc::c_uint,
                            class: 1 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x20000 as libc::c_int as libc::c_uint,
                            last: 0x2a6df as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2a700 as libc::c_int as libc::c_uint,
                            last: 0x2b73f as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2b740 as libc::c_int as libc::c_uint,
                            last: 0x2b81f as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         },
         {
             let mut init =
                 clinterval{first: 0x2f800 as libc::c_int as libc::c_uint,
                            last: 0x2fa1f as libc::c_int as libc::c_uint,
                            class: 0x4e00 as libc::c_int as libc::c_uint,};
             init
         }];
    let mut bot = 0 as libc::c_int;
    let mut top =
        (::std::mem::size_of::<[clinterval; 71]>() as
             libc::c_ulong).wrapping_div(::std::mem::size_of::<clinterval>()
                                             as
                                             libc::c_ulong).wrapping_div(((::std::mem::size_of::<[clinterval; 71]>()
                                                                               as
                                                                               libc::c_ulong).wrapping_rem(::std::mem::size_of::<clinterval>()
                                                                                                               as
                                                                                                               libc::c_ulong)
                                                                              ==
                                                                              0)
                                                                             as
                                                                             libc::c_int
                                                                             as
                                                                             size_t).wrapping_sub(1
                                                                                                      as
                                                                                                      libc::c_int
                                                                                                      as
                                                                                                      libc::c_ulong)
            as libc::c_int;
    let mut mid: libc::c_int = 0;
    /* First quick check for Latin1 characters, use 'iskeyword'. */
    if c < 0x100 as libc::c_int {
        if c == ' ' as i32 || c == '\t' as i32 || c == NUL ||
               c == 0xa0 as libc::c_int {
            return 0 as libc::c_int
            // blank
        }
        if vim_iswordc_tab(c, chartab) {
            return 2 as libc::c_int
            // punctuation
            // word character
        }
        return 1 as libc::c_int
    }
    /* binary search in table */
    while top >= bot {
        mid = (bot + top) / 2 as libc::c_int;
        if classes[mid as usize].last < c as libc::c_uint {
            bot = mid + 1 as libc::c_int
        } else if classes[mid as usize].first > c as libc::c_uint {
            top = mid - 1 as libc::c_int
        } else { return classes[mid as usize].class as libc::c_int }
    }
    // emoji
    if intable(emoji_all.as_ptr(),
               (::std::mem::size_of::<[interval; 151]>() as
                    libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                    as
                                                    libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 151]>()
                                                                                      as
                                                                                      libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                      as
                                                                                                                      libc::c_ulong)
                                                                                     ==
                                                                                     0)
                                                                                    as
                                                                                    libc::c_int
                                                                                    as
                                                                                    size_t),
               c) {
        return 3 as libc::c_int
    }
    /* most other characters are "word" characters */
    return 2 as libc::c_int;
}
#[no_mangle]
#[c2rust::src_loc = "1183:1"]
pub unsafe extern "C" fn utf_ambiguous_width(mut c: libc::c_int) -> bool {
    return c >= 0x80 as libc::c_int &&
               (intable(ambiguous.as_ptr(),
                        (::std::mem::size_of::<[interval; 179]>() as
                             libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                             as
                                                             libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 179]>()
                                                                                               as
                                                                                               libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                               as
                                                                                                                               libc::c_ulong)
                                                                                              ==
                                                                                              0)
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             size_t),
                        c) as libc::c_int != 0 ||
                    intable(emoji_all.as_ptr(),
                            (::std::mem::size_of::<[interval; 151]>() as
                                 libc::c_ulong).wrapping_div(::std::mem::size_of::<interval>()
                                                                 as
                                                                 libc::c_ulong).wrapping_div(((::std::mem::size_of::<[interval; 151]>()
                                                                                                   as
                                                                                                   libc::c_ulong).wrapping_rem(::std::mem::size_of::<interval>()
                                                                                                                                   as
                                                                                                                                   libc::c_ulong)
                                                                                                  ==
                                                                                                  0)
                                                                                                 as
                                                                                                 libc::c_int
                                                                                                 as
                                                                                                 size_t),
                            c) as libc::c_int != 0);
}
/*
 * Generic conversion function for case operations.
 * Return the converted equivalent of "a", which is a UCS-4 character.  Use
 * the given conversion "table".  Uses binary search on "table".
 */
#[c2rust::src_loc = "1194:1"]
unsafe extern "C" fn utf_convert(mut a: libc::c_int,
                                 table: *const convertStruct,
                                 mut n_items: size_t) -> libc::c_int {
    let mut start: size_t = 0; /* indices into table */
    let mut mid: size_t = 0;
    let mut end: size_t = 0;
    start = 0 as libc::c_int as size_t;
    end = n_items;
    while start < end {
        /* need to search further */
        mid =
            end.wrapping_add(start).wrapping_div(2 as libc::c_int as
                                                     libc::c_ulong);
        if (*table.offset(mid as isize)).rangeEnd < a {
            start = mid.wrapping_add(1 as libc::c_int as libc::c_ulong)
        } else { end = mid }
    }
    if start < n_items && (*table.offset(start as isize)).rangeStart <= a &&
           a <= (*table.offset(start as isize)).rangeEnd &&
           (a - (*table.offset(start as isize)).rangeStart) %
               (*table.offset(start as isize)).step == 0 as libc::c_int {
        return a + (*table.offset(start as isize)).offset
    } else { return a };
}
/*
 * Return the folded-case equivalent of "a", which is a UCS-4 character.  Uses
 * simple case folding.
 */
#[no_mangle]
#[c2rust::src_loc = "1221:1"]
pub unsafe extern "C" fn utf_fold(mut a: libc::c_int) -> libc::c_int {
    if a < 0x80 as libc::c_int {
        // be fast for ASCII
        return if a >= 0x41 as libc::c_int && a <= 0x5a as libc::c_int {
                   (a) + 32 as libc::c_int
               } else { a }
    }
    return utf_convert(a, foldCase.as_ptr(),
                       (::std::mem::size_of::<[convertStruct; 192]>() as
                            libc::c_ulong).wrapping_div(::std::mem::size_of::<convertStruct>()
                                                            as
                                                            libc::c_ulong).wrapping_div(((::std::mem::size_of::<[convertStruct; 192]>()
                                                                                              as
                                                                                              libc::c_ulong).wrapping_rem(::std::mem::size_of::<convertStruct>()
                                                                                                                              as
                                                                                                                              libc::c_ulong)
                                                                                             ==
                                                                                             0)
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            size_t));
}
// Vim's own character class functions.  These exist because many library
// islower()/toupper() etc. do not work properly: they crash when used with
// invalid values or can't handle latin1 when the locale is C.
// Speed is most important here.
// / Return the upper-case equivalent of "a", which is a UCS-4 character.  Use
// / simple case folding.
#[no_mangle]
#[c2rust::src_loc = "1237:1"]
pub unsafe extern "C" fn mb_toupper(mut a: libc::c_int) -> libc::c_int {
    /* If 'casemap' contains "keepascii" use ASCII style toupper(). */
    if a < 128 as libc::c_int &&
           cmp_flags & CMP_KEEPASCII as libc::c_uint != 0 {
        return if a < 'a' as i32 || a > 'z' as i32 {
                   a
               } else { (a) - ('a' as i32 - 'A' as i32) }
    }
    /* If towupper() is available and handles Unicode, use it. */
    if cmp_flags & CMP_INTERNAL as libc::c_uint == 0 {
        return towupper(a as wint_t) as libc::c_int
    }
    /* For characters below 128 use locale sensitive toupper(). */
    if a < 128 as libc::c_int { return toupper(a) }
    /* For any other characters use the above mapping table. */
    return utf_convert(a, toUpper.as_ptr(),
                       (::std::mem::size_of::<[convertStruct; 187]>() as
                            libc::c_ulong).wrapping_div(::std::mem::size_of::<convertStruct>()
                                                            as
                                                            libc::c_ulong).wrapping_div(((::std::mem::size_of::<[convertStruct; 187]>()
                                                                                              as
                                                                                              libc::c_ulong).wrapping_rem(::std::mem::size_of::<convertStruct>()
                                                                                                                              as
                                                                                                                              libc::c_ulong)
                                                                                             ==
                                                                                             0)
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            size_t));
}
#[no_mangle]
#[c2rust::src_loc = "1257:1"]
pub unsafe extern "C" fn mb_islower(mut a: libc::c_int) -> bool {
    // German sharp s is lower case but has no upper case equivalent.
    return mb_toupper(a) != a || a == 0xdf as libc::c_int;
}
// / Return the lower-case equivalent of "a", which is a UCS-4 character.  Use
// / simple case folding.
#[no_mangle]
#[c2rust::src_loc = "1265:1"]
pub unsafe extern "C" fn mb_tolower(mut a: libc::c_int) -> libc::c_int {
    /* If 'casemap' contains "keepascii" use ASCII style tolower(). */
    if a < 128 as libc::c_int &&
           cmp_flags & CMP_KEEPASCII as libc::c_uint != 0 {
        return if a < 'A' as i32 || a > 'Z' as i32 {
                   a
               } else { (a) + ('a' as i32 - 'A' as i32) }
    }
    /* If towlower() is available and handles Unicode, use it. */
    if cmp_flags & CMP_INTERNAL as libc::c_uint == 0 {
        return towlower(a as wint_t) as libc::c_int
    }
    /* For characters below 128 use locale sensitive tolower(). */
    if a < 128 as libc::c_int { return tolower(a) }
    /* For any other characters use the above mapping table. */
    return utf_convert(a, toLower.as_ptr(),
                       (::std::mem::size_of::<[convertStruct; 172]>() as
                            libc::c_ulong).wrapping_div(::std::mem::size_of::<convertStruct>()
                                                            as
                                                            libc::c_ulong).wrapping_div(((::std::mem::size_of::<[convertStruct; 172]>()
                                                                                              as
                                                                                              libc::c_ulong).wrapping_rem(::std::mem::size_of::<convertStruct>()
                                                                                                                              as
                                                                                                                              libc::c_ulong)
                                                                                             ==
                                                                                             0)
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            size_t));
}
#[no_mangle]
#[c2rust::src_loc = "1285:1"]
pub unsafe extern "C" fn mb_isupper(mut a: libc::c_int) -> bool {
    return mb_tolower(a) != a;
}
#[c2rust::src_loc = "1290:1"]
unsafe extern "C" fn utf_strnicmp(mut s1: *const char_u,
                                  mut s2: *const char_u, mut n1: size_t,
                                  mut n2: size_t) -> libc::c_int {
    let mut c1: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut cdiff: libc::c_int = 0;
    let mut buffer: [char_u; 6] = [0; 6];
    loop  {
        c1 = utf_safe_read_char_adv(&mut s1, &mut n1);
        c2 = utf_safe_read_char_adv(&mut s2, &mut n2);
        if c1 <= 0 as libc::c_int || c2 <= 0 as libc::c_int { break ; }
        if c1 == c2 { continue ; }
        cdiff = utf_fold(c1) - utf_fold(c2);
        if cdiff != 0 as libc::c_int { return cdiff }
    }
    /* some string ended or has an incomplete/illegal character sequence */
    if c1 == 0 as libc::c_int || c2 == 0 as libc::c_int {
        /* some string ended. shorter string is smaller */
        if c1 == 0 as libc::c_int && c2 == 0 as libc::c_int {
            return 0 as libc::c_int
        }
        return if c1 == 0 as libc::c_int {
                   -(1 as libc::c_int)
               } else { 1 as libc::c_int }
    }
    /* Continue with bytewise comparison to produce some result that
   * would make comparison operations involving this function transitive.
   *
   * If only one string had an error, comparison should be made with
   * folded version of the other string. In this case it is enough
   * to fold just one character to determine the result of comparison. */
    if c1 != -(1 as libc::c_int) && c2 == -(1 as libc::c_int) {
        n1 = utf_char2bytes(utf_fold(c1), buffer.as_mut_ptr()) as size_t;
        s1 = buffer.as_mut_ptr()
    } else if c2 != -(1 as libc::c_int) && c1 == -(1 as libc::c_int) {
        n2 = utf_char2bytes(utf_fold(c2), buffer.as_mut_ptr()) as size_t;
        s2 = buffer.as_mut_ptr()
    }
    while n1 > 0 as libc::c_int as libc::c_ulong &&
              n2 > 0 as libc::c_int as libc::c_ulong &&
              *s1 as libc::c_int != NUL && *s2 as libc::c_int != NUL {
        cdiff = *s1 as libc::c_int - *s2 as libc::c_int;
        if cdiff != 0 as libc::c_int { return cdiff }
        s1 = s1.offset(1);
        s2 = s2.offset(1);
        n1 = n1.wrapping_sub(1);
        n2 = n2.wrapping_sub(1)
    }
    if n1 > 0 as libc::c_int as libc::c_ulong && *s1 as libc::c_int == NUL {
        n1 = 0 as libc::c_int as size_t
    }
    if n2 > 0 as libc::c_int as libc::c_ulong && *s2 as libc::c_int == NUL {
        n2 = 0 as libc::c_int as size_t
    }
    if n1 == 0 as libc::c_int as libc::c_ulong &&
           n2 == 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int
    }
    return if n1 == 0 as libc::c_int as libc::c_ulong {
               -(1 as libc::c_int)
           } else { 1 as libc::c_int };
}
// / Measure the length of a string in corresponding UTF-32 and UTF-16 units.
// /
// / Invalid UTF-8 bytes, or embedded surrogates, count as one code point/unit
// / each.
// /
// / The out parameters are incremented. This is used to measure the size of
// / a buffer region consisting of multiple line segments.
// /
// / @param s the string
// / @param len maximum length (an earlier NUL terminates)
// / @param[out] codepoints incremented with UTF-32 code point size
// / @param[out] codeunits incremented with UTF-16 code unit size
#[no_mangle]
#[c2rust::src_loc = "1458:1"]
pub unsafe extern "C" fn mb_utflen(mut s: *const char_u, mut len: size_t,
                                   mut codepoints: *mut size_t,
                                   mut codeunits: *mut size_t) {
    let mut count = 0 as libc::c_int as size_t;
    let mut extra = 0 as libc::c_int as size_t;
    let mut clen: size_t = 0;
    let mut i = 0 as libc::c_int as size_t;
    while i < len && *s.offset(i as isize) as libc::c_int != NUL {
        clen =
            utf_ptr2len_len(s.offset(i as isize),
                            len.wrapping_sub(i) as libc::c_int) as size_t;
        // NB: gets the byte value of invalid sequence bytes.
    // we only care whether the char fits in the BMP or not
        let mut c =
            if clen > 1 as libc::c_int as libc::c_ulong {
                utf_ptr2char(s.offset(i as isize))
            } else { *s.offset(i as isize) as libc::c_int };
        count = count.wrapping_add(1);
        if c > 0xffff as libc::c_int { extra = extra.wrapping_add(1) }
        i = (i as libc::c_ulong).wrapping_add(clen) as size_t as size_t
    }
    *codepoints =
        (*codepoints as libc::c_ulong).wrapping_add(count) as size_t as
            size_t;
    *codeunits =
        (*codeunits as libc::c_ulong).wrapping_add(count.wrapping_add(extra))
            as size_t as size_t;
}
#[no_mangle]
#[c2rust::src_loc = "1478:1"]
pub unsafe extern "C" fn mb_utf_index_to_bytes(mut s: *const char_u,
                                               mut len: size_t,
                                               mut index: size_t,
                                               mut use_utf16_units: bool)
 -> ssize_t {
    let mut count = 0 as libc::c_int as size_t;
    let mut clen: size_t = 0;
    let mut i: size_t = 0;
    if index == 0 as libc::c_int as libc::c_ulong {
        return 0 as libc::c_int as ssize_t
    }
    i = 0 as libc::c_int as size_t;
    while i < len && *s.offset(i as isize) as libc::c_int != NUL {
        clen =
            utf_ptr2len_len(s.offset(i as isize),
                            len.wrapping_sub(i) as libc::c_int) as size_t;
        // NB: gets the byte value of invalid sequence bytes.
    // we only care whether the char fits in the BMP or not
        let mut c =
            if clen > 1 as libc::c_int as libc::c_ulong {
                utf_ptr2char(s.offset(i as isize))
            } else { *s.offset(i as isize) as libc::c_int };
        count = count.wrapping_add(1);
        if use_utf16_units as libc::c_int != 0 && c > 0xffff as libc::c_int {
            count = count.wrapping_add(1)
        }
        if count >= index { return i.wrapping_add(clen) as ssize_t }
        i = (i as libc::c_ulong).wrapping_add(clen) as size_t as size_t
    }
    return -(1 as libc::c_int) as ssize_t;
}
/*
 * Version of strnicmp() that handles multi-byte characters.
 * Needed for Big5, Shift-JIS and UTF-8 encoding.  Other DBCS encodings can
 * probably use strnicmp(), because there are no ASCII characters in the
 * second byte.
 * Returns zero if s1 and s2 are equal (ignoring case), the difference between
 * two characters otherwise.
 */
#[no_mangle]
#[c2rust::src_loc = "1512:1"]
pub unsafe extern "C" fn mb_strnicmp(mut s1: *const char_u,
                                     mut s2: *const char_u, nn: size_t)
 -> libc::c_int {
    return utf_strnicmp(s1, s2, nn, nn);
}
// / Compare strings case-insensitively
// /
// / @note We need to call mb_stricmp() even when we aren't dealing with
// /       a multi-byte encoding because mb_stricmp() takes care of all ASCII and
// /       non-ascii encodings, including characters with umlauts in latin1,
// /       etc., while STRICMP() only handles the system locale version, which
// /       often does not handle non-ascii properly.
// /
// / @param[in]  s1  First string to compare, not more then #MAXCOL characters.
// / @param[in]  s2  Second string to compare, not more then #MAXCOL characters.
// /
// / @return 0 if strings are equal, <0 if s1 < s2, >0 if s1 > s2.
#[no_mangle]
#[c2rust::src_loc = "1529:1"]
pub unsafe extern "C" fn mb_stricmp(mut s1: *const libc::c_char,
                                    mut s2: *const libc::c_char)
 -> libc::c_int {
    return mb_strnicmp(s1 as *const char_u, s2 as *const char_u,
                       MAXCOL as libc::c_int as size_t);
}
/*
 * "g8": show bytes of the UTF-8 char under the cursor.  Doesn't matter what
 * 'encoding' has been set to.
 */
#[no_mangle]
#[c2rust::src_loc = "1538:1"]
pub unsafe extern "C" fn show_utf8() {
    let mut len: libc::c_int = 0;
    let mut rlen = 0 as libc::c_int;
    let mut line = 0 as *mut char_u;
    let mut clen: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    /* Get the byte length of the char under the cursor, including composing
   * characters. */
    line = get_cursor_pos_ptr();
    len = utfc_ptr2len(line);
    if len == 0 as libc::c_int {
        msg(b"NUL\x00" as *const u8 as *const libc::c_char as *mut char_u);
        return
    }
    clen = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < len {
        if clen == 0 as libc::c_int {
            /* start of (composing) character, get its length */
            if i > 0 as libc::c_int {
                strcpy(IObuff.as_mut_ptr().offset(rlen as isize) as
                           *mut libc::c_char,
                       b"+ \x00" as *const u8 as *const libc::c_char as
                           *mut libc::c_char); /* NUL is stored as NL */
                rlen += 2 as libc::c_int
            }
            clen = utf_ptr2len(line.offset(i as isize))
        }
        sprintf((IObuff.as_mut_ptr() as
                     *mut libc::c_char).offset(rlen as isize),
                b"%02x \x00" as *const u8 as *const libc::c_char,
                if *line.offset(i as isize) as libc::c_int == NL {
                    NUL
                } else { *line.offset(i as isize) as libc::c_int });
        clen -= 1;
        rlen +=
            strlen(IObuff.as_mut_ptr().offset(rlen as isize) as
                       *mut libc::c_char) as libc::c_int;
        if rlen > IOSIZE - 20 as libc::c_int { break ; }
        i += 1
    }
    msg(IObuff.as_mut_ptr());
}
// / Return offset from "p" to the first byte of the character it points into.
// / If "p" points to the NUL at the end of the string return 0.
// / Returns 0 when already at the first byte of a character.
#[no_mangle]
#[c2rust::src_loc = "1579:1"]
pub unsafe extern "C" fn utf_head_off(mut base: *const char_u,
                                      mut p: *const char_u) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    if (*p as libc::c_int) < 0x80 as libc::c_int {
        /* be quick for ASCII */
        return 0 as libc::c_int
    }
    /* Skip backwards over trailing bytes: 10xx.xxxx
   * Skip backwards again if on a composing char. */
    let mut q = 0 as *const char_u;
    q = p;
    loop 
         /* Move s to the last byte of this char. */
         {
        let mut s = 0 as *const char_u;
        s = q;
        while *s.offset(1 as libc::c_int as isize) as libc::c_int &
                  0xc0 as libc::c_int == 0x80 as libc::c_int {
            s = s.offset(1)
        }
        /* Move q to the first byte of this char. */
        while q > base &&
                  *q as libc::c_int & 0xc0 as libc::c_int ==
                      0x80 as libc::c_int {
            q = q.offset(-1)
        }
        /* Check for illegal sequence. Do allow an illegal byte after where we
     * started. */
        len = utf8len_tab[*q as usize] as libc::c_int;
        if len !=
               (s.wrapping_offset_from(q) as libc::c_long +
                    1 as libc::c_int as libc::c_long) as libc::c_int &&
               len !=
                   (p.wrapping_offset_from(q) as libc::c_long +
                        1 as libc::c_int as libc::c_long) as libc::c_int {
            return 0 as libc::c_int
        }
        if q <= base { break ; }
        c = utf_ptr2char(q);
        if !utf_iscomposing(c) {
            if !arabic_maycombine(c) { break ; }
            /* Advance to get a sneak-peak at the next char */
            let mut j = q;
            j = j.offset(-1);
            /* Move j to the first byte of this char. */
            while j > base &&
                      *j as libc::c_int & 0xc0 as libc::c_int ==
                          0x80 as libc::c_int {
                j = j.offset(-1)
            }
            if !arabic_combine(utf_ptr2char(j), c) { break ; }
        }
        q = q.offset(-1)
    }
    return p.wrapping_offset_from(q) as libc::c_long as libc::c_int;
}
// / Copy a character, advancing the pointers
// /
// / @param[in,out]  fp  Source of the character to copy.
// / @param[in,out]  tp  Destination to copy to.
#[no_mangle]
#[c2rust::src_loc = "1631:1"]
pub unsafe extern "C" fn mb_copy_char(fp: *mut *const char_u,
                                      tp: *mut *mut char_u) {
    let l = utfc_ptr2len(*fp) as size_t;
    memmove(*tp as *mut libc::c_void, *fp as *const libc::c_void, l);
    *tp = (*tp).offset(l as isize);
    *fp = (*fp).offset(l as isize);
}
/*
 * Return the offset from "p" to the first byte of a character.  When "p" is
 * at the start of a character 0 is returned, otherwise the offset to the next
 * character.  Can start anywhere in a stream of bytes.
 */
#[no_mangle]
#[c2rust::src_loc = "1645:1"]
pub unsafe extern "C" fn mb_off_next(mut base: *mut char_u,
                                     mut p: *mut char_u) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    if (*p as libc::c_int) < 0x80 as libc::c_int {
        // be quick for ASCII
        return 0 as libc::c_int
    }
    // Find the next character that isn't 10xx.xxxx
    i = 0 as libc::c_int;
    while *p.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int ==
              0x80 as libc::c_int {
        i += 1
    }
    if i > 0 as libc::c_int {
        // Check for illegal sequence.
        j = 0 as libc::c_int;
        while p.offset(-(j as isize)) > base {
            if *p.offset(-j as isize) as libc::c_int & 0xc0 as libc::c_int !=
                   0x80 as libc::c_int {
                break ;
            }
            j += 1
        }
        if utf8len_tab[*p.offset(-j as isize) as usize] as libc::c_int !=
               i + j {
            return 0 as libc::c_int
        }
    }
    return i;
}
/*
 * Return the offset from "p" to the last byte of the character it points
 * into.  Can start anywhere in a stream of bytes.
 */
#[no_mangle]
#[c2rust::src_loc = "1674:1"]
pub unsafe extern "C" fn mb_tail_off(mut base: *mut char_u,
                                     mut p: *mut char_u) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    if *p as libc::c_int == NUL { return 0 as libc::c_int }
    // Find the last character that is 10xx.xxxx
    i = 0 as libc::c_int;
    while *p.offset((i + 1 as libc::c_int) as isize) as libc::c_int &
              0xc0 as libc::c_int == 0x80 as libc::c_int {
        i += 1
    }
    // Check for illegal sequence.
    j = 0 as libc::c_int;
    while p.offset(-(j as isize)) > base {
        if *p.offset(-j as isize) as libc::c_int & 0xc0 as libc::c_int !=
               0x80 as libc::c_int {
            break ;
        }
        j += 1
    }
    if utf8len_tab[*p.offset(-j as isize) as usize] as libc::c_int !=
           i + j + 1 as libc::c_int {
        return 0 as libc::c_int
    }
    return i;
}
/*
 * Find the next illegal byte sequence.
 */
#[no_mangle]
#[c2rust::src_loc = "1701:1"]
pub unsafe extern "C" fn utf_find_illegal() {
    let mut current_block: u64;
    let mut pos = (*curwin).w_cursor;
    let mut p = 0 as *mut char_u;
    let mut len: libc::c_int = 0;
    let mut vimconv =
        vimconv_T{vc_type: 0,
                  vc_factor: 0,
                  vc_fd: 0 as *mut libc::c_void,
                  vc_fail: false,};
    let mut tofree = NULL_0 as *mut char_u;
    vimconv.vc_type = CONV_NONE as libc::c_int;
    if enc_canon_props((*curbuf).b_p_fenc) & ENC_8BIT != 0 {
        // 'encoding' is "utf-8" but we are editing a 8-bit encoded file,
    // possibly a utf-8 file with illegal bytes.  Setup for conversion
    // from utf-8 to 'fileencoding'.
        convert_setup(&mut vimconv, p_enc, (*curbuf).b_p_fenc);
    }
    (*curwin).w_cursor.coladd = 0 as libc::c_int;
    's_44:
        loop  {
            p = get_cursor_pos_ptr();
            if vimconv.vc_type != CONV_NONE as libc::c_int {
                xfree(tofree as *mut libc::c_void);
                tofree =
                    string_convert(&mut vimconv, p, NULL_0 as *mut size_t);
                if tofree.is_null() {
                    current_block = 3275366147856559585;
                    break ;
                }
                p = tofree
            }
            while *p as libc::c_int != NUL {
                /* Illegal means that there are not enough trail bytes (checked by
       * utf_ptr2len()) or too many of them (overlong sequence). */
                len = utf_ptr2len(p);
                if *p as libc::c_int >= 0x80 as libc::c_int &&
                       (len == 1 as libc::c_int ||
                            utf_char2len(utf_ptr2char(p)) != len) {
                    if vimconv.vc_type == CONV_NONE as libc::c_int {
                        (*curwin).w_cursor.col +=
                            p.wrapping_offset_from(get_cursor_pos_ptr()) as
                                libc::c_long as colnr_T
                    } else {
                        let mut l: libc::c_int = 0;
                        len =
                            p.wrapping_offset_from(tofree) as libc::c_long as
                                libc::c_int;
                        p = get_cursor_pos_ptr();
                        while *p as libc::c_int != NUL &&
                                  {
                                      let fresh6 = len;
                                      len = len - 1;
                                      (fresh6) > 0 as libc::c_int
                                  } {
                            l = utf_ptr2len(p);
                            (*curwin).w_cursor.col += l;
                            p = p.offset(l as isize)
                        }
                    }
                    current_block = 11834598965984575227;
                    break 's_44 ;
                } else { p = p.offset(len as isize) }
            }
            if (*curwin).w_cursor.lnum == (*curbuf).b_ml.ml_line_count {
                current_block = 3275366147856559585;
                break ;
            }
            (*curwin).w_cursor.lnum += 1;
            (*curwin).w_cursor.col = 0 as libc::c_int
        }
    match current_block {
        3275366147856559585 => {
            /* didn't find it: don't move and beep */
            (*curwin).w_cursor = pos;
            beep_flush();
        }
        _ => { }
    }
    xfree(tofree as *mut libc::c_void);
    convert_setup(&mut vimconv, NULL_0 as *mut char_u, NULL_0 as *mut char_u);
}
/*
 * If the cursor moves on an trail byte, set the cursor on the lead byte.
 * Thus it moves left if necessary.
 */
#[no_mangle]
#[c2rust::src_loc = "1768:1"]
pub unsafe extern "C" fn mb_adjust_cursor() {
    mark_mb_adjustpos(curbuf, &mut (*curwin).w_cursor);
}
// / Checks and adjusts cursor column. Not mode-dependent.
// / @see check_cursor_col_win
// /
// / @param  win_  Places cursor on a valid column for this window.
#[no_mangle]
#[c2rust::src_loc = "1777:1"]
pub unsafe extern "C" fn mb_check_adjust_col(mut win_: *mut libc::c_void) {
    let mut win = win_ as *mut win_T;
    let mut oldcol = (*win).w_cursor.col;
    // Column 0 is always valid.
    if oldcol != 0 as libc::c_int {
        let mut p =
            ml_get_buf((*win).w_buffer, (*win).w_cursor.lnum, false_0 != 0);
        let mut len = strlen(p as *mut libc::c_char) as colnr_T;
        // Empty line or invalid column?
        if len == 0 as libc::c_int || oldcol < 0 as libc::c_int {
            (*win).w_cursor.col = 0 as libc::c_int
        } else {
            // Cursor column too big for line?
            if oldcol > len { (*win).w_cursor.col = len - 1 as libc::c_int }
            // Move the cursor to the head byte.
            (*win).w_cursor.col -=
                utf_head_off(p, p.offset((*win).w_cursor.col as isize))
        }
        // Reset `coladd` when the cursor would be on the right half of a
    // double-wide character.
        if (*win).w_cursor.coladd == 1 as libc::c_int &&
               *p.offset((*win).w_cursor.col as isize) as libc::c_int != TAB
               &&
               vim_isprintc(utf_ptr2char(p.offset((*win).w_cursor.col as
                                                      isize))) as libc::c_int
                   != 0 &&
               ptr2cells(p.offset((*win).w_cursor.col as isize)) >
                   1 as libc::c_int {
            (*win).w_cursor.coladd = 0 as libc::c_int
        }
    };
}
/*
 * Return a pointer to the character before "*p", if there is one.
 */
#[no_mangle]
#[c2rust::src_loc = "1812:1"]
pub unsafe extern "C" fn mb_prevptr(mut line: *mut char_u, mut p: *mut char_u)
 -> *mut char_u {
    if p > line {
        p =
            p.offset(-((utf_head_off(line,
                                     p.offset(-(1 as libc::c_int as isize))) +
                            1 as libc::c_int) as isize))
    }
    return p;
}
/*
 * Return the character length of "str".  Each multi-byte character (with
 * following composing characters) counts as one.
 */
#[no_mangle]
#[c2rust::src_loc = "1827:1"]
pub unsafe extern "C" fn mb_charlen(mut str: *mut char_u) -> libc::c_int {
    let mut p = str;
    let mut count: libc::c_int = 0;
    if p.is_null() { return 0 as libc::c_int }
    count = 0 as libc::c_int;
    while *p as libc::c_int != NUL {
        p =
            p.offset(Some(Some(mb_ptr2len).expect("non-null function pointer")).expect("non-null function pointer")(p)
                         as isize);
        count += 1
    }
    return count;
}
/*
 * Like mb_charlen() but for a string with specified length.
 */
#[no_mangle]
#[c2rust::src_loc = "1844:1"]
pub unsafe extern "C" fn mb_charlen_len(mut str: *mut char_u,
                                        mut len: libc::c_int) -> libc::c_int {
    let mut p = str;
    let mut count: libc::c_int = 0;
    count = 0 as libc::c_int;
    while *p as libc::c_int != NUL && p < str.offset(len as isize) {
        p =
            p.offset(Some(Some(mb_ptr2len).expect("non-null function pointer")).expect("non-null function pointer")(p)
                         as isize);
        count += 1
    }
    return count;
}
// / Try to unescape a multibyte character
// /
// / Used for the rhs and lhs of the mappings.
// /
// / @param[in,out]  pp  String to unescape. Is advanced to just after the bytes
// /                     that form a multibyte character.
// /
// / @return Unescaped string if it is a multibyte character, NULL if no
// /         multibyte character was found. Returns a static buffer, always one
// /         and the same.
#[no_mangle]
#[c2rust::src_loc = "1865:1"]
pub unsafe extern "C" fn mb_unescape(pp: *mut *const libc::c_char)
 -> *const libc::c_char {
    static mut buf: [libc::c_char; 6] = [0; 6];
    let mut buf_idx = 0 as libc::c_int as size_t;
    let mut str = *pp as *mut uint8_t;
    // Must translate K_SPECIAL KS_SPECIAL KE_FILLER to K_SPECIAL and CSI
  // KS_EXTRA KE_CSI to CSI.
  // Maximum length of a utf-8 character is 4 bytes.
    let mut str_idx = 0 as libc::c_int as size_t;
    while *str.offset(str_idx as isize) as libc::c_int != NUL &&
              buf_idx < 4 as libc::c_int as libc::c_ulong {
        if *str.offset(str_idx as isize) as libc::c_int == K_SPECIAL &&
               *str.offset(str_idx.wrapping_add(1 as libc::c_int as
                                                    libc::c_ulong) as isize)
                   as libc::c_int == KS_SPECIAL &&
               *str.offset(str_idx.wrapping_add(2 as libc::c_int as
                                                    libc::c_ulong) as isize)
                   as libc::c_int == KE_FILLER {
            let fresh7 = buf_idx;
            buf_idx = buf_idx.wrapping_add(1);
            buf[fresh7 as usize] = K_SPECIAL as libc::c_char;
            str_idx =
                (str_idx as
                     libc::c_ulong).wrapping_add(2 as libc::c_int as
                                                     libc::c_ulong) as size_t
                    as size_t
        } else if *str.offset(str_idx as isize) as libc::c_int == K_SPECIAL &&
                      *str.offset(str_idx.wrapping_add(1 as libc::c_int as
                                                           libc::c_ulong) as
                                      isize) as libc::c_int == KS_EXTRA &&
                      *str.offset(str_idx.wrapping_add(2 as libc::c_int as
                                                           libc::c_ulong) as
                                      isize) as libc::c_int ==
                          KE_CSI as libc::c_int {
            let fresh8 = buf_idx;
            buf_idx = buf_idx.wrapping_add(1);
            buf[fresh8 as usize] = CSI as libc::c_char;
            str_idx =
                (str_idx as
                     libc::c_ulong).wrapping_add(2 as libc::c_int as
                                                     libc::c_ulong) as size_t
                    as size_t
        } else {
            if *str.offset(str_idx as isize) as libc::c_int == K_SPECIAL {
                break ;
            }
            let fresh9 = buf_idx;
            buf_idx = buf_idx.wrapping_add(1);
            buf[fresh9 as usize] =
                *str.offset(str_idx as isize) as libc::c_char
        }
        buf[buf_idx as usize] = NUL as libc::c_char;
        // Return a multi-byte character if it's found.  An illegal sequence
    // will result in a 1 here.
        if utf_ptr2len(buf.as_mut_ptr() as *const char_u) > 1 as libc::c_int {
            *pp =
                (str as
                     *const libc::c_char).offset(str_idx as
                                                     isize).offset(1 as
                                                                       libc::c_int
                                                                       as
                                                                       isize);
            return buf.as_mut_ptr()
        }
        // Bail out quickly for ASCII.
        if (buf[0 as libc::c_int as usize] as uint8_t as libc::c_int) <
               128 as libc::c_int {
            break ;
        }
        str_idx = str_idx.wrapping_add(1)
    }
    return NULL_0 as *const libc::c_char;
}
/*
 * Skip the Vim specific head of a 'encoding' name.
 */
#[no_mangle]
#[c2rust::src_loc = "1912:1"]
pub unsafe extern "C" fn enc_skip(mut p: *mut char_u) -> *mut char_u {
    if strncmp(p as *mut libc::c_char,
               b"2byte-\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 6 as libc::c_int as size_t) ==
           0 as libc::c_int {
        return p.offset(6 as libc::c_int as isize)
    }
    if strncmp(p as *mut libc::c_char,
               b"8bit-\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 5 as libc::c_int as size_t) ==
           0 as libc::c_int {
        return p.offset(5 as libc::c_int as isize)
    }
    return p;
}
/*
 * Find the canonical name for encoding "enc".
 * When the name isn't recognized, returns "enc" itself, but with all lower
 * case characters and '_' replaced with '-'.
 * Returns an allocated string.
 */
#[no_mangle]
#[c2rust::src_loc = "1927:1"]
pub unsafe extern "C" fn enc_canonize(mut enc: *mut char_u) -> *mut char_u {
    let mut p = 0 as *mut char_u;
    let mut s = 0 as *mut char_u;
    let mut i: libc::c_int = 0;
    if strcmp(enc as *mut libc::c_char,
              b"default\x00" as *const u8 as *const libc::c_char as
                  *mut libc::c_char) == 0 as libc::c_int {
        // Use the default encoding as found by set_init_1().
        return vim_strsave(fenc_default)
    }
    /* copy "enc" to allocated memory, with room for two '-' */
    let mut r =
        xmalloc(strlen(enc as
                           *mut libc::c_char).wrapping_add(3 as libc::c_int as
                                                               libc::c_ulong))
            as *mut char_u;
    /* Make it all lower case and replace '_' with '-'. */
    p = r;
    s = enc;
    while *s as libc::c_int != NUL {
        if *s as libc::c_int == '_' as i32 {
            let fresh10 = p;
            p = p.offset(1);
            *fresh10 = '-' as i32 as char_u
        } else {
            let fresh11 = p;
            p = p.offset(1);
            *fresh11 =
                if (*s as libc::c_int) < 'A' as i32 ||
                       *s as libc::c_int > 'Z' as i32 {
                    *s as libc::c_int
                } else { (*s as libc::c_int) + ('a' as i32 - 'A' as i32) } as
                    char_u
        }
        s = s.offset(1)
    }
    *p = NUL as char_u;
    /* Skip "2byte-" and "8bit-". */
    p = enc_skip(r);
    /* Change "microsoft-cp" to "cp".  Used in some spell files. */
    if strncmp(p as *mut libc::c_char,
               b"microsoft-cp\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 12 as libc::c_int as size_t) ==
           0 as libc::c_int {
        memmove(p as *mut libc::c_void,
                p.offset(10 as libc::c_int as isize) as *const libc::c_void,
                strlen(p.offset(10 as libc::c_int as isize) as
                           *mut libc::c_char).wrapping_add(1 as libc::c_int as
                                                               libc::c_ulong));
    }
    /* "iso8859" -> "iso-8859" */
    if strncmp(p as *mut libc::c_char,
               b"iso8859\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 7 as libc::c_int as size_t) ==
           0 as libc::c_int {
        memmove(p.offset(4 as libc::c_int as isize) as *mut libc::c_void,
                p.offset(3 as libc::c_int as isize) as *const libc::c_void,
                strlen(p.offset(3 as libc::c_int as isize) as
                           *mut libc::c_char).wrapping_add(1 as libc::c_int as
                                                               libc::c_ulong));
        *p.offset(3 as libc::c_int as isize) = '-' as i32 as char_u
    }
    /* "iso-8859n" -> "iso-8859-n" */
    if strncmp(p as *mut libc::c_char,
               b"iso-8859\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 8 as libc::c_int as size_t) ==
           0 as libc::c_int &&
           *p.offset(8 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        memmove(p.offset(9 as libc::c_int as isize) as *mut libc::c_void,
                p.offset(8 as libc::c_int as isize) as *const libc::c_void,
                strlen(p.offset(8 as libc::c_int as isize) as
                           *mut libc::c_char).wrapping_add(1 as libc::c_int as
                                                               libc::c_ulong));
        *p.offset(8 as libc::c_int as isize) = '-' as i32 as char_u
    }
    /* "latin-N" -> "latinN" */
    if strncmp(p as *mut libc::c_char,
               b"latin-\x00" as *const u8 as *const libc::c_char as
                   *mut libc::c_char, 6 as libc::c_int as size_t) ==
           0 as libc::c_int {
        memmove(p.offset(5 as libc::c_int as isize) as *mut libc::c_void,
                p.offset(6 as libc::c_int as isize) as *const libc::c_void,
                strlen(p.offset(6 as libc::c_int as isize) as
                           *mut libc::c_char).wrapping_add(1 as libc::c_int as
                                                               libc::c_ulong));
    }
    if enc_canon_search(p) >= 0 as libc::c_int {
        /* canonical name can be used unmodified */
        if p != r {
            memmove(r as *mut libc::c_void, p as *const libc::c_void,
                    strlen(p as
                               *mut libc::c_char).wrapping_add(1 as
                                                                   libc::c_int
                                                                   as
                                                                   libc::c_ulong));
        }
    } else {
        i = enc_alias_search(p);
        if i >= 0 as libc::c_int {
            /* alias recognized, get canonical name */
            xfree(r as *mut libc::c_void);
            r = vim_strsave(enc_canon_table[i as usize].name as *mut char_u)
        }
    }
    return r;
}
/*
 * Search for an encoding alias of "name".
 * Returns -1 when not found.
 */
#[c2rust::src_loc = "1988:1"]
unsafe extern "C" fn enc_alias_search(mut name: *mut char_u) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !enc_alias_table[i as usize].name.is_null() {
        if strcmp(name as *mut libc::c_char,
                  enc_alias_table[i as usize].name as *mut libc::c_char) ==
               0 as libc::c_int {
            return enc_alias_table[i as usize].canon
        }
        i += 1
    }
    return -(1 as libc::c_int);
}
/*
 * Get the canonicalized encoding of the current locale.
 * Returns an allocated string when successful, NULL when not.
 */
#[no_mangle]
#[c2rust::src_loc = "2007:1"]
pub unsafe extern "C" fn enc_locale() -> *mut char_u {
    let mut i: libc::c_int = 0;
    let mut buf: [libc::c_char; 50] = [0; 50];
    let mut s = 0 as *const libc::c_char;
    s = nl_langinfo(CODESET_0);
    if s.is_null() || *s as libc::c_int == NUL {
        s = setlocale(LC_CTYPE, NULL_0 as *const libc::c_char);
        if s.is_null() || *s as libc::c_int == NUL {
            s = os_getenv(b"LC_ALL\x00" as *const u8 as *const libc::c_char);
            if !s.is_null() {
                s =
                    os_getenv(b"LC_CTYPE\x00" as *const u8 as
                                  *const libc::c_char);
                if !s.is_null() {
                    s =
                        os_getenv(b"LANG\x00" as *const u8 as
                                      *const libc::c_char)
                }
            }
        }
    }
    if s.is_null() { return NULL_0 as *mut char_u }
    // The most generic locale format is:
  // language[_territory][.codeset][@modifier][+special][,[sponsor][_revision]]
  // If there is a '.' remove the part before it.
  // if there is something after the codeset, remove it.
  // Make the name lowercase and replace '_' with '-'.
  // Exception: "ja_JP.EUC" == "euc-jp", "zh_CN.EUC" = "euc-cn",
  // "ko_KR.EUC" == "euc-kr"
    let mut p: *const libc::c_char =
        vim_strchr(s as *mut char_u, '.' as i32) as *mut libc::c_char;
    let mut current_block_24: u64;
    if !p.is_null() {
        if p > s.offset(2 as libc::c_int as isize) &&
               strncasecmp(p.offset(1 as libc::c_int as isize) as
                               *mut libc::c_char,
                           b"EUC\x00" as *const u8 as *const libc::c_char as
                               *mut libc::c_char, 3 as libc::c_int as size_t)
                   == 0 &&
               *(*__ctype_b_loc()).offset(*p.offset(4 as libc::c_int as isize)
                                              as libc::c_int as isize) as
                   libc::c_int &
                   _ISalnum as libc::c_int as libc::c_ushort as libc::c_int ==
                   0 &&
               *p.offset(4 as libc::c_int as isize) as libc::c_int !=
                   '-' as i32 &&
               *p.offset(-(3 as libc::c_int) as isize) as libc::c_int ==
                   '_' as i32 {
            // Copy "XY.EUC" to "euc-XY" to buf[10].
            memmove(buf.as_mut_ptr() as *mut libc::c_void,
                    b"euc-\x00" as *const u8 as *const libc::c_char as
                        *const libc::c_void,
                    4 as libc::c_int as libc::c_ulong);
            buf[4 as libc::c_int as usize] =
                if *p.offset(-(2 as libc::c_int) as isize) as libc::c_uint >=
                       'A' as i32 as libc::c_uint &&
                       *p.offset(-(2 as libc::c_int) as isize) as libc::c_uint
                           <= 'Z' as i32 as libc::c_uint ||
                       *p.offset(-(2 as libc::c_int) as isize) as libc::c_uint
                           >= 'a' as i32 as libc::c_uint &&
                           *p.offset(-(2 as libc::c_int) as isize) as
                               libc::c_uint <= 'z' as i32 as libc::c_uint ||
                       ascii_isdigit(*p.offset(-(2 as libc::c_int) as isize)
                                         as libc::c_int) as libc::c_int != 0 {
                    if (*p.offset(-(2 as libc::c_int) as isize) as
                            libc::c_int) < 'A' as i32 ||
                           *p.offset(-(2 as libc::c_int) as isize) as
                               libc::c_int > 'Z' as i32 {
                        *p.offset(-(2 as libc::c_int) as isize) as libc::c_int
                    } else {
                        (*p.offset(-(2 as libc::c_int) as isize) as
                             libc::c_int) + ('a' as i32 - 'A' as i32)
                    }
                } else { 0 as libc::c_int } as libc::c_char;
            buf[5 as libc::c_int as usize] =
                if *p.offset(-(1 as libc::c_int) as isize) as libc::c_uint >=
                       'A' as i32 as libc::c_uint &&
                       *p.offset(-(1 as libc::c_int) as isize) as libc::c_uint
                           <= 'Z' as i32 as libc::c_uint ||
                       *p.offset(-(1 as libc::c_int) as isize) as libc::c_uint
                           >= 'a' as i32 as libc::c_uint &&
                           *p.offset(-(1 as libc::c_int) as isize) as
                               libc::c_uint <= 'z' as i32 as libc::c_uint ||
                       ascii_isdigit(*p.offset(-(1 as libc::c_int) as isize)
                                         as libc::c_int) as libc::c_int != 0 {
                    if (*p.offset(-(1 as libc::c_int) as isize) as
                            libc::c_int) < 'A' as i32 ||
                           *p.offset(-(1 as libc::c_int) as isize) as
                               libc::c_int > 'Z' as i32 {
                        *p.offset(-(1 as libc::c_int) as isize) as libc::c_int
                    } else {
                        (*p.offset(-(1 as libc::c_int) as isize) as
                             libc::c_int) + ('a' as i32 - 'A' as i32)
                    }
                } else { 0 as libc::c_int } as libc::c_char;
            buf[6 as libc::c_int as usize] = NUL as libc::c_char;
            current_block_24 = 1538046216550696469;
        } else {
            s = p.offset(1 as libc::c_int as isize);
            current_block_24 = 16296608149235199289;
        }
    } else { current_block_24 = 16296608149235199289; }
    match current_block_24 {
        16296608149235199289 => {
            i = 0 as libc::c_int;
            while i <
                      ::std::mem::size_of::<[libc::c_char; 50]>() as
                          libc::c_ulong as libc::c_int - 1 as libc::c_int &&
                      *s.offset(i as isize) as libc::c_int != NUL {
                if *s.offset(i as isize) as libc::c_int == '_' as i32 ||
                       *s.offset(i as isize) as libc::c_int == '-' as i32 {
                    buf[i as usize] = '-' as i32 as libc::c_char
                } else {
                    if !(*s.offset(i as isize) as uint8_t as libc::c_uint >=
                             'A' as i32 as libc::c_uint &&
                             *s.offset(i as isize) as uint8_t as libc::c_uint
                                 <= 'Z' as i32 as libc::c_uint ||
                             *s.offset(i as isize) as uint8_t as libc::c_uint
                                 >= 'a' as i32 as libc::c_uint &&
                                 *s.offset(i as isize) as uint8_t as
                                     libc::c_uint <=
                                     'z' as i32 as libc::c_uint ||
                             ascii_isdigit(*s.offset(i as isize) as uint8_t as
                                               libc::c_int) as libc::c_int !=
                                 0) {
                        break ;
                    }
                    buf[i as usize] =
                        if (*s.offset(i as isize) as libc::c_int) < 'A' as i32
                               ||
                               *s.offset(i as isize) as libc::c_int >
                                   'Z' as i32 {
                            *s.offset(i as isize) as libc::c_int
                        } else {
                            (*s.offset(i as isize) as libc::c_int) +
                                ('a' as i32 - 'A' as i32)
                        } as libc::c_char
                }
                i += 1
            }
            buf[i as usize] = NUL as libc::c_char
        }
        _ => { }
    }
    return enc_canonize(buf.as_mut_ptr() as *mut char_u);
}
/*
 * Call iconv_open() with a check if iconv() works properly (there are broken
 * versions).
 * Returns (void *)-1 if failed.
 * (should return iconv_t, but that causes problems with prototypes).
 */
#[no_mangle]
#[c2rust::src_loc = "2079:1"]
pub unsafe extern "C" fn my_iconv_open(mut to: *mut char_u,
                                       mut from: *mut char_u)
 -> *mut libc::c_void {
    let mut fd =
        0 as *mut libc::c_void; /* detected a broken iconv() previously */
    let mut tobuf: [char_u; 400] = [0; 400];
    let mut p = 0 as *mut libc::c_char;
    let mut tolen: size_t = 0;
    static mut iconv_working: WorkingStatus = kUnknown;
    if iconv_working as libc::c_uint == kBroken as libc::c_int as libc::c_uint
       {
        return -(1 as libc::c_int) as *mut libc::c_void
    }
    fd =
        iconv_open(enc_skip(to) as *mut libc::c_char,
                   enc_skip(from) as *mut libc::c_char);
    if fd != -(1 as libc::c_int) as iconv_t &&
           iconv_working as libc::c_uint ==
               kUnknown as libc::c_int as libc::c_uint {
        /*
     * Do a dummy iconv() call to check if it actually works.  There is a
     * version of iconv() on Linux that is broken.  We can't ignore it,
     * because it's wide-spread.  The symptoms are that after outputting
     * the initial shift state the "to" pointer is NULL and conversion
     * stops for no apparent reason after about 8160 characters.
     */
        p = tobuf.as_mut_ptr() as *mut libc::c_char;
        tolen = ICONV_TESTLEN as size_t;
        iconv(fd, NULL_0 as *mut *mut libc::c_char, NULL_0 as *mut size_t,
              &mut p, &mut tolen);
        if p.is_null() {
            iconv_working = kBroken;
            iconv_close(fd);
            fd = -(1 as libc::c_int) as iconv_t
        } else { iconv_working = kWorking }
    }
    return fd;
}
#[c2rust::src_loc = "2082:9"]
pub const ICONV_TESTLEN: libc::c_int = 400 as libc::c_int;
/*
 * Convert the string "str[slen]" with iconv().
 * If "unconvlenp" is not NULL handle the string ending in an incomplete
 * sequence and set "*unconvlenp" to the length of it.
 * Returns the converted string in allocated memory.  NULL for an error.
 * If resultlenp is not NULL, sets it to the result length in bytes.
 */
#[c2rust::src_loc = "2122:1"]
unsafe extern "C" fn iconv_string(vcp: *const vimconv_T, mut str: *mut char_u,
                                  mut slen: size_t,
                                  mut unconvlenp: *mut size_t,
                                  mut resultlenp: *mut size_t)
 -> *mut char_u {
    let mut from = 0 as *const libc::c_char;
    let mut fromlen: size_t = 0;
    let mut to = 0 as *mut libc::c_char;
    let mut tolen: size_t = 0;
    let mut len = 0 as libc::c_int as size_t;
    let mut done = 0 as libc::c_int as size_t;
    let mut result = NULL_0 as *mut char_u;
    let mut p = 0 as *mut char_u;
    let mut l: libc::c_int = 0;
    from = str as *mut libc::c_char;
    fromlen = slen;
    loop  {
        if len == 0 as libc::c_int as libc::c_ulong ||
               ICONV_ERRNO == ICONV_E2BIG {
            /* Allocate enough room for most conversions.  When re-allocating
       * increase the buffer size. */
            len =
                len.wrapping_add(fromlen.wrapping_mul(2 as libc::c_int as
                                                          libc::c_ulong)).wrapping_add(40
                                                                                           as
                                                                                           libc::c_int
                                                                                           as
                                                                                           libc::c_ulong);
            p = xmalloc(len) as *mut char_u;
            if done > 0 as libc::c_int as libc::c_ulong {
                memmove(p as *mut libc::c_void, result as *const libc::c_void,
                        done);
            }
            xfree(result as *mut libc::c_void);
            result = p
        }
        to = (result as *mut libc::c_char).offset(done as isize);
        tolen =
            len.wrapping_sub(done).wrapping_sub(2 as libc::c_int as
                                                    libc::c_ulong);
        // Avoid a warning for systems with a wrong iconv() prototype by
    // casting the second argument to void *.
        if iconv((*vcp).vc_fd,
                 &mut from as *mut *const libc::c_char as *mut libc::c_void as
                     *mut *mut libc::c_char, &mut fromlen, &mut to,
                 &mut tolen) != SIZE_MAX {
            // Finished, append a NUL.
            *to = NUL as libc::c_char;
            break ;
        } else if !(*vcp).vc_fail && !unconvlenp.is_null() &&
                      (ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL) {
            // Check both ICONV_EINVAL and EINVAL, because the dynamically loaded
    // iconv library may use one of them.
            // Handle an incomplete sequence at the end.
            *to = NUL as libc::c_char;
            *unconvlenp = fromlen;
            break ;
        } else {
            if !(*vcp).vc_fail &&
                   (ICONV_ERRNO == ICONV_EILSEQ || ICONV_ERRNO == EILSEQ ||
                        ICONV_ERRNO == ICONV_EINVAL || ICONV_ERRNO == EINVAL)
               {
                // Check both ICONV_EILSEQ and EILSEQ, because the dynamically loaded
      // iconv library may use one of them.
                // Can't convert: insert a '?' and skip a character.  This assumes
      // conversion from 'encoding' to something else.  In other
      // situations we don't know what to skip anyway.
                let fresh12 = to;
                to = to.offset(1);
                *fresh12 = '?' as i32 as libc::c_char;
                if utf_ptr2cells(from as *mut char_u) > 1 as libc::c_int {
                    let fresh13 = to;
                    to = to.offset(1);
                    *fresh13 = '?' as i32 as libc::c_char
                }
                l =
                    utfc_ptr2len_len(from as *const char_u,
                                     fromlen as libc::c_int);
                from = from.offset(l as isize);
                fromlen =
                    (fromlen as
                         libc::c_ulong).wrapping_sub(l as libc::c_ulong) as
                        size_t as size_t
            } else if ICONV_ERRNO != ICONV_E2BIG {
                // conversion failed
                let mut ptr_ =
                    &mut result as *mut *mut char_u as *mut *mut libc::c_void;
                xfree(*ptr_);
                *ptr_ = NULL_0 as *mut libc::c_void;
                break ;
            }
            // Not enough room or skipping illegal sequence.
            done =
                to.wrapping_offset_from(result as *mut libc::c_char) as
                    libc::c_long as size_t
        }
    }
    if !resultlenp.is_null() && !result.is_null() {
        *resultlenp =
            to.wrapping_offset_from(result as *mut libc::c_char) as
                libc::c_long as size_t
    }
    return result;
}
// HAVE_ICONV
/*
 * Setup "vcp" for conversion from "from" to "to".
 * The names must have been made canonical with enc_canonize().
 * vcp->vc_type must have been initialized to CONV_NONE.
 * Note: cannot be used for conversion from/to ucs-2 and ucs-4 (will use utf-8
 * instead).
 * Afterwards invoke with "from" and "to" equal to NULL to cleanup.
 * Return FAIL when conversion is not supported, OK otherwise.
 */
#[no_mangle]
#[c2rust::src_loc = "2211:1"]
pub unsafe extern "C" fn convert_setup(mut vcp: *mut vimconv_T,
                                       mut from: *mut char_u,
                                       mut to: *mut char_u) -> libc::c_int {
    return convert_setup_ext(vcp, from, true_0 != 0, to, true_0 != 0);
}
/*
 * As convert_setup(), but only when from_unicode_is_utf8 is TRUE will all
 * "from" unicode charsets be considered utf-8.  Same for "to".
 */
#[no_mangle]
#[c2rust::src_loc = "2220:1"]
pub unsafe extern "C" fn convert_setup_ext(mut vcp: *mut vimconv_T,
                                           mut from: *mut char_u,
                                           mut from_unicode_is_utf8: bool,
                                           mut to: *mut char_u,
                                           mut to_unicode_is_utf8: bool)
 -> libc::c_int {
    let mut from_prop: libc::c_int = 0;
    let mut to_prop: libc::c_int = 0;
    let mut from_is_utf8: libc::c_int = 0;
    let mut to_is_utf8: libc::c_int = 0;
    // Reset to no conversion.
    if (*vcp).vc_type == CONV_ICONV as libc::c_int &&
           (*vcp).vc_fd != -(1 as libc::c_int) as iconv_t {
        iconv_close((*vcp).vc_fd);
    }
    *vcp =
        {
            let mut init =
                vimconv_T{vc_type: CONV_NONE as libc::c_int,
                          vc_factor: 1 as libc::c_int,
                          vc_fd: 0 as *mut libc::c_void,
                          vc_fail: false_0 != 0,};
            init
        };
    /* No conversion when one of the names is empty or they are equal. */
    if from.is_null() || *from as libc::c_int == NUL || to.is_null() ||
           *to as libc::c_int == NUL ||
           strcmp(from as *mut libc::c_char, to as *mut libc::c_char) ==
               0 as libc::c_int {
        return OK
    }
    from_prop = enc_canon_props(from);
    to_prop = enc_canon_props(to);
    if from_unicode_is_utf8 {
        from_is_utf8 = from_prop & ENC_UNICODE
    } else { from_is_utf8 = (from_prop == ENC_UNICODE) as libc::c_int }
    if to_unicode_is_utf8 {
        to_is_utf8 = to_prop & ENC_UNICODE
    } else { to_is_utf8 = (to_prop == ENC_UNICODE) as libc::c_int }
    if from_prop & ENC_LATIN1 != 0 && to_is_utf8 != 0 {
        /* Internal latin1 -> utf-8 conversion. */
        (*vcp).vc_type = CONV_TO_UTF8 as libc::c_int;
        (*vcp).vc_factor = 2 as libc::c_int
        /* up to twice as long */
    } else if from_prop & ENC_LATIN9 != 0 && to_is_utf8 != 0 {
        /* Internal latin9 -> utf-8 conversion. */
        (*vcp).vc_type = CONV_9_TO_UTF8 as libc::c_int;
        (*vcp).vc_factor = 3 as libc::c_int
        /* up to three as long (euro sign) */
    } else if from_is_utf8 != 0 && to_prop & ENC_LATIN1 != 0 {
        /* Internal utf-8 -> latin1 conversion. */
        (*vcp).vc_type = CONV_TO_LATIN1 as libc::c_int
    } else if from_is_utf8 != 0 && to_prop & ENC_LATIN9 != 0 {
        /* Internal utf-8 -> latin9 conversion. */
        (*vcp).vc_type = CONV_TO_LATIN9 as libc::c_int
    } else {
        // NOLINT(readability/braces)
        // Use iconv() for conversion.
        (*vcp).vc_fd =
            my_iconv_open(if to_is_utf8 != 0 {
                              b"utf-8\x00" as *const u8 as *const libc::c_char
                                  as *mut char_u
                          } else { to },
                          if from_is_utf8 != 0 {
                              b"utf-8\x00" as *const u8 as *const libc::c_char
                                  as *mut char_u
                          } else { from });
        if (*vcp).vc_fd != -(1 as libc::c_int) as iconv_t {
            (*vcp).vc_type = CONV_ICONV as libc::c_int;
            (*vcp).vc_factor = 4 as libc::c_int
            /* could be longer too... */
        }
    }
    if (*vcp).vc_type == CONV_NONE as libc::c_int { return FAIL }
    return OK;
}
/*
 * Convert text "ptr[*lenp]" according to "vcp".
 * Returns the result in allocated memory and sets "*lenp".
 * When "lenp" is NULL, use NUL terminated strings.
 * Illegal chars are often changed to "?", unless vcp->vc_fail is set.
 * When something goes wrong, NULL is returned and "*lenp" is unchanged.
 */
#[no_mangle]
#[c2rust::src_loc = "2292:1"]
pub unsafe extern "C" fn string_convert(vcp: *const vimconv_T,
                                        mut ptr: *mut char_u,
                                        mut lenp: *mut size_t)
 -> *mut char_u {
    return string_convert_ext(vcp, ptr, lenp, NULL_0 as *mut size_t);
}
/*
 * Like string_convert(), but when "unconvlenp" is not NULL and there are is
 * an incomplete sequence at the end it is not converted and "*unconvlenp" is
 * set to the number of remaining bytes.
 */
#[no_mangle]
#[c2rust::src_loc = "2302:1"]
pub unsafe extern "C" fn string_convert_ext(vcp: *const vimconv_T,
                                            mut ptr: *mut char_u,
                                            mut lenp: *mut size_t,
                                            mut unconvlenp: *mut size_t)
 -> *mut char_u {
    let mut retval = NULL_0 as *mut char_u;
    let mut d = 0 as *mut char_u;
    let mut l: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut len: size_t = 0;
    if lenp.is_null() {
        len = strlen(ptr as *mut libc::c_char)
    } else { len = *lenp }
    if len == 0 as libc::c_int as libc::c_ulong {
        return vim_strsave(b"\x00" as *const u8 as *const libc::c_char as
                               *mut char_u)
    }
    match (*vcp).vc_type {
        1 => {
            /* latin1 to utf-8 conversion */
            retval =
                xmalloc(len.wrapping_mul(2 as libc::c_int as
                                             libc::c_ulong).wrapping_add(1 as
                                                                             libc::c_int
                                                                             as
                                                                             libc::c_ulong))
                    as *mut char_u;
            d = retval;
            let mut i = 0 as libc::c_int as size_t;
            while i < len {
                c = *ptr.offset(i as isize) as libc::c_int;
                if c < 0x80 as libc::c_int {
                    let fresh14 = d;
                    d = d.offset(1);
                    *fresh14 = c as char_u
                } else {
                    let fresh15 = d;
                    d = d.offset(1);
                    *fresh15 =
                        (0xc0 as libc::c_int as
                             libc::c_uint).wrapping_add(c as libc::c_uint >>
                                                            6 as libc::c_int)
                            as char_u;
                    let fresh16 = d;
                    d = d.offset(1);
                    *fresh16 =
                        (0x80 as libc::c_int + (c & 0x3f as libc::c_int)) as
                            char_u
                }
                i = i.wrapping_add(1)
            }
            *d = NUL as char_u;
            if !lenp.is_null() {
                *lenp =
                    d.wrapping_offset_from(retval) as libc::c_long as size_t
            }
        }
        2 => {
            /* latin9 to utf-8 conversion */
            retval =
                xmalloc(len.wrapping_mul(3 as libc::c_int as
                                             libc::c_ulong).wrapping_add(1 as
                                                                             libc::c_int
                                                                             as
                                                                             libc::c_ulong))
                    as *mut char_u;
            d = retval;
            let mut i_0 = 0 as libc::c_int as size_t;
            while i_0 < len {
                c = *ptr.offset(i_0 as isize) as libc::c_int;
                match c {
                    164 => {
                        c = 0x20ac as libc::c_int
                        /* Y */
                    }
                    166 => { c = 0x160 as libc::c_int }
                    168 => { c = 0x161 as libc::c_int }
                    180 => { c = 0x17d as libc::c_int }
                    184 => { c = 0x17e as libc::c_int }
                    188 => { c = 0x152 as libc::c_int }
                    189 => { c = 0x153 as libc::c_int }
                    190 => { c = 0x178 as libc::c_int }
                    _ => { }
                }
                d = d.offset(utf_char2bytes(c, d) as isize);
                i_0 = i_0.wrapping_add(1)
            }
            *d = NUL as char_u;
            if !lenp.is_null() {
                *lenp =
                    d.wrapping_offset_from(retval) as libc::c_long as size_t
            }
        }
        3 | 4 => {
            /* utf-8 to latin1 conversion */
            /* utf-8 to latin9 conversion */
            retval =
                xmalloc(len.wrapping_add(1 as libc::c_int as libc::c_ulong))
                    as *mut char_u;
            d = retval;
            let mut i_1 = 0 as libc::c_int as size_t;
            while i_1 < len {
                l =
                    utf_ptr2len_len(ptr.offset(i_1 as isize),
                                    len.wrapping_sub(i_1) as libc::c_int);
                if l == 0 as libc::c_int {
                    let fresh17 = d;
                    d = d.offset(1);
                    *fresh17 = NUL as char_u
                } else if l == 1 as libc::c_int {
                    let mut l_w =
                        utf8len_tab_zero[*ptr.offset(i_1 as isize) as usize];
                    if l_w as libc::c_int == 0 as libc::c_int {
                        /* Illegal utf-8 byte cannot be converted */
                        xfree(retval as *mut libc::c_void);
                        return NULL_0 as *mut char_u
                    }
                    if !unconvlenp.is_null() &&
                           l_w as libc::c_ulong > len.wrapping_sub(i_1) {
                        /* Incomplete sequence at the end. */
                        *unconvlenp = len.wrapping_sub(i_1);
                        break ;
                    } else {
                        let fresh18 = d;
                        d = d.offset(1);
                        *fresh18 = *ptr.offset(i_1 as isize)
                    }
                } else {
                    c = utf_ptr2char(ptr.offset(i_1 as isize));
                    if (*vcp).vc_type == CONV_TO_LATIN9 as libc::c_int {
                        match c {
                            8364 => {
                                c = 0xa4 as libc::c_int
                                /* not in latin9 */
                            }
                            352 => { c = 0xa6 as libc::c_int }
                            353 => { c = 0xa8 as libc::c_int }
                            381 => { c = 0xb4 as libc::c_int }
                            382 => { c = 0xb8 as libc::c_int }
                            338 => { c = 0xbc as libc::c_int }
                            339 => { c = 0xbd as libc::c_int }
                            376 => { c = 0xbe as libc::c_int }
                            164 | 166 | 168 | 180 | 184 | 188 | 189 | 190 => {
                                c = 0x100 as libc::c_int
                            }
                            _ => { }
                        }
                    }
                    if !utf_iscomposing(c) {
                        /* skip composing chars */
                        if c < 0x100 as libc::c_int {
                            let fresh19 = d;
                            d = d.offset(1);
                            *fresh19 = c as char_u
                        } else if (*vcp).vc_fail {
                            xfree(retval as *mut libc::c_void);
                            return NULL_0 as *mut char_u
                        } else {
                            let fresh20 = d;
                            d = d.offset(1);
                            *fresh20 = 0xbf as libc::c_int as char_u;
                            if utf_char2cells(c) > 1 as libc::c_int {
                                let fresh21 = d;
                                d = d.offset(1);
                                *fresh21 = '?' as i32 as char_u
                            }
                        }
                    }
                    i_1 =
                        (i_1 as
                             libc::c_ulong).wrapping_add((l -
                                                              1 as
                                                                  libc::c_int)
                                                             as libc::c_ulong)
                            as size_t as size_t
                }
                i_1 = i_1.wrapping_add(1)
            }
            *d = NUL as char_u;
            if !lenp.is_null() {
                *lenp =
                    d.wrapping_offset_from(retval) as libc::c_long as size_t
            }
        }
        5 => {
            // conversion with vcp->vc_fd
            retval = iconv_string(vcp, ptr, len, unconvlenp, lenp)
        }
        _ => { }
    }
    return retval;
}
