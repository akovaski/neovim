use crate::*;

pub const UB_SAME_DIR: upd_block0_T = 1;
pub const UB_FNAME: upd_block0_T = 0;
pub const DATA_ID: i32 = (('d' as i32) << 8) + 'a' as i32;
pub const PTR_ID: i32 = (('p' as i32) << 8) + 't' as i32;
pub const BLOCK0_ID0: i32 = 'b' as i32;
pub const BLOCK0_ID1: i32 = '0' as i32;
pub const INDEX_SIZE: u64 = ::std::mem::size_of::<u32>() as u64;
pub const B0_FNAME_SIZE_ORG: i32 = 900;
pub const B0_FNAME_SIZE_NOCRYPT: i32 = 898;
pub const B0_FNAME_SIZE_CRYPT: i32 = 890;
pub const B0_UNAME_SIZE: i32 = 40;
pub const B0_HNAME_SIZE: i32 = 40;
pub const B0_MAGIC_LONG: i64 = 0x30313233 as i64;
pub const B0_MAGIC_INT: i64 = 0x20212223 as i64;
pub const B0_MAGIC_SHORT: i64 = 0x10111213 as i64;
pub const B0_MAGIC_CHAR: i32 = 0x55 as i32;
pub const B0_DIRTY: i32 = 0x55 as i32;
pub const B0_FF_MASK: i32 = 3;
pub const B0_SAME_DIR: i32 = 4;
pub const B0_HAS_FENC: i32 = 8;
pub const STACK_INCR: i32 = 5;
pub const ML_DELETE: i32 = 0x11 as i32;
pub const ML_INSERT: i32 = 0x12 as i32;
pub const ML_FIND: i32 = 0x13 as i32;
pub const ML_FLUSH: i32 = 0x2 as i32;
pub const MLCS_MAXL: i32 = 800;
pub const MLCS_MINL: i32 = 400;
pub type DATA_BL = data_block;
pub struct data_block;
pub type PTR_EN = pointer_entry;
pub struct pointer_entry;
pub type PTR_BL = pointer_block;
pub struct pointer_block;
pub type ZERO_BL = block0;
pub struct block0;
pub type upd_block0_T = u32;
extern "C" {
    static mut lowest_marked: linenr_T;
    pub fn ml_open(mut buf: *mut buf_T) -> i32;
    pub fn ml_setname(mut buf: *mut buf_T);
    pub fn ml_open_files();
    pub fn ml_open_file(mut buf: *mut buf_T);
    pub fn check_need_swap(mut newfile: bool);
    pub fn ml_close(mut buf: *mut buf_T, mut del_file: i32);
    pub fn ml_close_all(mut del_file: i32);
    pub fn ml_close_notmod();
    pub fn ml_timestamp(mut buf: *mut buf_T);
    pub fn ml_recover(mut checkext: bool);
    pub fn recover_names(mut fname: *mut u8, mut list: i32, mut nr: i32, mut fname_out: *mut *mut u8) -> i32;
    pub fn make_percent_swname(mut dir: *const i8, mut name: *mut i8) -> *mut i8;
    static mut process_still_running: bool;
    pub fn get_b0_dict(mut fname: *const i8, mut d: *mut dict_T);
    pub fn ml_sync_all(mut check_file: i32, mut check_char: i32, mut do_fsync: bool);
    pub fn ml_preserve(mut buf: *mut buf_T, mut message: i32, mut do_fsync: bool);
    pub fn ml_get(mut lnum: linenr_T) -> *mut u8;
    pub fn ml_get_pos(mut pos: *const pos_T) -> *mut u8;
    pub fn ml_get_buf(mut buf: *mut buf_T, mut lnum: linenr_T, mut will_change: bool) -> *mut u8;
    pub fn ml_line_alloced() -> i32;
    pub fn ml_append(mut lnum: linenr_T, mut line: *mut u8, mut len: colnr_T, mut newfile: bool) -> i32;
    pub fn ml_append_buf(mut buf: *mut buf_T, mut lnum: linenr_T, mut line: *mut u8, mut len: colnr_T, mut newfile: bool) -> i32;
    pub fn ml_add_deleted_len(mut ptr: *mut u8, mut len: ssize_t);
    pub fn ml_replace(mut lnum: linenr_T, mut line: *mut u8, mut copy: bool) -> i32;
    pub fn ml_delete(mut lnum: linenr_T, mut message: bool) -> i32;
    pub fn ml_setmarked(mut lnum: linenr_T);
    pub fn ml_firstmarked() -> linenr_T;
    pub fn ml_clearmarked();
    pub fn ml_flush_deleted_bytes(mut buf: *mut buf_T, mut codepoints: *mut size_t, mut codeunits: *mut size_t) -> size_t;
    pub fn resolve_symlink(mut fname: *const u8, mut buf: *mut u8) -> i32;
    pub fn makeswapname(mut fname: *mut u8, mut ffname: *mut u8, mut buf: *mut buf_T, mut dir_name: *mut u8) -> *mut u8;
    pub fn get_file_in_dir(mut fname: *mut u8, mut dname: *mut u8) -> *mut u8;
    pub fn ml_setflags(mut buf: *mut buf_T);
    pub fn ml_find_line_or_offset(mut buf: *mut buf_T, mut lnum: linenr_T, mut offp: *mut i64, mut no_ff: bool) -> i64;
    pub fn goto_byte(mut cnt: i64);
    pub fn inc(mut lp: *mut pos_T) -> i32;
    pub fn incl(mut lp: *mut pos_T) -> i32;
    pub fn dec(mut lp: *mut pos_T) -> i32;
    pub fn decl(mut lp: *mut pos_T) -> i32;
}
