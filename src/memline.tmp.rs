use ::libc;
#[c2rust::header_src = "internal:0"]
pub mod internal {
    #[c2rust::src_loc = "0:0"]
    pub type __builtin_va_list = [__va_list_tag; 1];
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "0:0"]
    pub struct __va_list_tag {
        pub gp_offset: libc::c_uint,
        pub fp_offset: libc::c_uint,
        pub overflow_arg_area: *mut libc::c_void,
        pub reg_save_area: *mut libc::c_void,
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/types.h:41"]
pub mod types_h {
    #[c2rust::src_loc = "36:1"]
    pub type __int8_t = libc::c_schar;
    #[c2rust::src_loc = "37:1"]
    pub type __uint8_t = libc::c_uchar;
    #[c2rust::src_loc = "38:1"]
    pub type __int16_t = libc::c_short;
    #[c2rust::src_loc = "39:1"]
    pub type __uint16_t = libc::c_ushort;
    #[c2rust::src_loc = "40:1"]
    pub type __int32_t = libc::c_int;
    #[c2rust::src_loc = "41:1"]
    pub type __uint32_t = libc::c_uint;
    #[c2rust::src_loc = "43:1"]
    pub type __int64_t = libc::c_long;
    #[c2rust::src_loc = "44:1"]
    pub type __uint64_t = libc::c_ulong;
    #[c2rust::src_loc = "144:1"]
    pub type __uid_t = libc::c_uint;
    #[c2rust::src_loc = "145:1"]
    pub type __gid_t = libc::c_uint;
    #[c2rust::src_loc = "150:1"]
    pub type __off_t = libc::c_long;
    #[c2rust::src_loc = "158:1"]
    pub type __time_t = libc::c_long;
    #[c2rust::src_loc = "191:1"]
    pub type __ssize_t = libc::c_long;
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h:41"]
pub mod stdint_intn_h {
    #[c2rust::src_loc = "24:1"]
    pub type int8_t = __int8_t;
    #[c2rust::src_loc = "25:1"]
    pub type int16_t = __int16_t;
    #[c2rust::src_loc = "26:1"]
    pub type int32_t = __int32_t;
    #[c2rust::src_loc = "27:1"]
    pub type int64_t = __int64_t;
    use super::types_h::{__int8_t, __int16_t, __int32_t, __int64_t};
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h:41"]
pub mod stdint_uintn_h {
    #[c2rust::src_loc = "24:1"]
    pub type uint8_t = __uint8_t;
    #[c2rust::src_loc = "25:1"]
    pub type uint16_t = __uint16_t;
    #[c2rust::src_loc = "26:1"]
    pub type uint32_t = __uint32_t;
    #[c2rust::src_loc = "27:1"]
    pub type uint64_t = __uint64_t;
    use super::types_h::{__uint8_t, __uint16_t, __uint32_t, __uint64_t};
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stddef.h:42"]
pub mod stddef_h {
    #[c2rust::src_loc = "62:1"]
    pub type size_t = libc::c_ulong;
    #[c2rust::src_loc = "51:1"]
    pub type ptrdiff_t = libc::c_long;
    #[c2rust::src_loc = "105:11"]
    pub const NULL_0: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "105:11"]
    pub const NULL: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "105:11"]
    pub const NULL_1: libc::c_int = 0 as libc::c_int;
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/types/struct_iovec.h:44"]
pub mod struct_iovec_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:8"]
    pub struct iovec {
        pub iov_base: *mut libc::c_void,
        pub iov_len: size_t,
    }
    use super::stddef_h::size_t;
}
#[c2rust::header_src = "/usr/include/fcntl.h:44"]
pub mod fcntl_h {
    #[c2rust::src_loc = "56:1"]
    pub type off_t = __off_t;
    use super::types_h::__off_t;
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stdarg.h:46"]
pub mod stdarg_h {
    #[c2rust::src_loc = "30:1"]
    pub type va_list = __builtin_va_list;
    use super::internal::__builtin_va_list;
}
#[c2rust::header_src = "/usr/include/stdio.h:46"]
pub mod stdio_h {
    #[c2rust::src_loc = "77:1"]
    pub type ssize_t = __ssize_t;
    #[c2rust::src_loc = "111:9"]
    pub const SEEK_END: libc::c_int = 2 as libc::c_int;
    use super::types_h::__ssize_t;
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/sys/types.h:46"]
pub mod sys_types_h {
    #[c2rust::src_loc = "64:1"]
    pub type gid_t = __gid_t;
    #[c2rust::src_loc = "79:1"]
    pub type uid_t = __uid_t;
    use super::types_h::{__gid_t, __uid_t};
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/types/time_t.h:46"]
pub mod time_t_h {
    #[c2rust::src_loc = "7:1"]
    pub type time_t = __time_t;
    use super::types_h::__time_t;
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h:46"]
pub mod pthreadtypes_arch_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "65:8"]
    pub struct __pthread_rwlock_arch_t {
        pub __readers: libc::c_uint,
        pub __writers: libc::c_uint,
        pub __wrphase_futex: libc::c_uint,
        pub __writers_futex: libc::c_uint,
        pub __pad3: libc::c_uint,
        pub __pad4: libc::c_uint,
        pub __cur_writer: libc::c_int,
        pub __shared: libc::c_int,
        pub __rwelision: libc::c_schar,
        pub __pad1: [libc::c_uchar; 7],
        pub __pad2: libc::c_ulong,
        pub __flags: libc::c_uint,
    }
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h:46"]
pub mod thread_shared_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "82:16"]
    pub struct __pthread_internal_list {
        pub __prev: *mut __pthread_internal_list,
        pub __next: *mut __pthread_internal_list,
    }
    #[c2rust::src_loc = "82:1"]
    pub type __pthread_list_t = __pthread_internal_list;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "118:8"]
    pub struct __pthread_mutex_s {
        pub __lock: libc::c_int,
        pub __count: libc::c_uint,
        pub __owner: libc::c_int,
        pub __nusers: libc::c_uint,
        pub __kind: libc::c_int,
        pub __spins: libc::c_short,
        pub __elision: libc::c_short,
        pub __list: __pthread_list_t,
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h:46"]
pub mod pthreadtypes_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "67:9"]
    pub union pthread_mutex_t {
        pub __data: __pthread_mutex_s,
        pub __size: [libc::c_char; 40],
        pub __align: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "86:9"]
    pub union pthread_rwlock_t {
        pub __data: __pthread_rwlock_arch_t,
        pub __size: [libc::c_char; 56],
        pub __align: libc::c_long,
    }
    use super::thread_shared_types_h::__pthread_mutex_s;
    use super::pthreadtypes_arch_h::__pthread_rwlock_arch_t;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/types.h:47"]
pub mod nvim_types_h {
    // dummy to pass an ACL to a function
    // Shorthand for unsigned variables. Many systems, but not all, have u_char
// already defined, so we use char_u to avoid trouble.
    #[c2rust::src_loc = "11:1"]
    pub type char_u = libc::c_uchar;
    #[c2rust::src_loc = "17:1"]
    pub type handle_T = libc::c_int;
    #[c2rust::src_loc = "22:1"]
    pub type LuaRef = libc::c_int;
    // NVIM_TYPES_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/eval/typval.h:47"]
pub mod typval_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "255:9"]
    pub struct sctx_T {
        pub sc_sid: scid_T,
        pub sc_seq: libc::c_int,
        pub sc_lnum: linenr_T,
    }
    #[c2rust::src_loc = "245:1"]
    pub type scid_T = libc::c_int;
    // for linenr_T
    // / Type used for VimL VAR_NUMBER values
    #[c2rust::src_loc = "26:1"]
    pub type varnumber_T = int64_t;
    // / Type used for VimL VAR_FLOAT values
    #[c2rust::src_loc = "30:1"]
    pub type float_T = libc::c_double;
    // / Maximal possible value of varnumber_T variable
    // / Mimimal possible value of varnumber_T variable
    // / %d printf format specifier for varnumber_T
    // / Structure holding dictionary watcher
    // prevent recursion if the dict is changed in the callback
    // / Special variable values
    // /< v:false
    // /< v:true
    // /< v:null
    // / Variable lock status for typval_T.v_lock
    // /< Not locked.
    // /< User lock, can be unlocked.
    // /< Locked forever.
    // / VimL variable types, for use in typval_T.v_type
    // /< Unknown (unspecified) value.
    // /< Number, .v_number is used.
    // /< String, .v_string is used.
    // /< Function reference, .v_string is used as function name.
    // /< List, .v_list is used.
    // /< Dictionary, .v_dict is used.
    // /< Floating-point value, .v_float is used.
    // /< Special value (true, false, null), .v_special
                    // /< is used.
    // /< Partial, .v_partial is used.
    // / Structure that holds an internal variable value
    // /< Variable type.
    // /< Variable lock status.
    // /< Number, for VAR_NUMBER.
    // /< Special value, for VAR_SPECIAL.
    // /< Floating-point number, for VAR_FLOAT.
    // /< String, for VAR_STRING and VAR_FUNC, can be NULL.
    // /< List for VAR_LIST, can be NULL.
    // /< Dictionary for VAR_DICT, can be NULL.
    // /< Closure: function with args.
    // /< Actual value.
    // / Values for (struct dictvar_S).dv_scope
    // /< Not a scope dictionary.
    // /< Scope dictionary which requires prefix (a:, v:, …).
    // /< Scope dictionary which may be accessed without prefix
                      // /< (l:, g:).
    // / Structure to hold an item of a list
    // /< Next item in list.
    // /< Previous item in list.
    // /< Item value.
    // / Structure used by those that are using an item in a list
    // /< Item being watched.
    // /< Next watcher.
    // / Structure to hold info about a list
// / Order of members is optimized to reduce padding.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "164:8"]
    pub struct listvar_S {
        pub lv_first: *mut listitem_T,
        pub lv_last: *mut listitem_T,
        pub lv_watch: *mut listwatch_T,
        pub lv_idx_item: *mut listitem_T,
        pub lv_copylist: *mut list_T,
        pub lv_used_next: *mut list_T,
        pub lv_used_prev: *mut list_T,
        pub lv_refcount: libc::c_int,
        pub lv_len: libc::c_int,
        pub lv_idx: libc::c_int,
        pub lv_copyID: libc::c_int,
        pub lv_lock: VarLockStatus,
    }
    #[c2rust::src_loc = "102:9"]
    pub type VarLockStatus = libc::c_uint;
    #[c2rust::src_loc = "105:3"]
    pub const VAR_FIXED: VarLockStatus = 2;
    #[c2rust::src_loc = "104:3"]
    pub const VAR_LOCKED: VarLockStatus = 1;
    #[c2rust::src_loc = "103:3"]
    pub const VAR_UNLOCKED: VarLockStatus = 0;
    #[c2rust::src_loc = "64:1"]
    pub type list_T = listvar_S;
    #[c2rust::src_loc = "146:1"]
    pub type listitem_T = listitem_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "148:8"]
    pub struct listitem_S {
        pub li_next: *mut listitem_T,
        pub li_prev: *mut listitem_T,
        pub li_tv: typval_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "123:9"]
    pub struct typval_T {
        pub v_type: VarType,
        pub v_lock: VarLockStatus,
        pub vval: typval_vval_union,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "126:9"]
    pub union typval_vval_union {
        pub v_number: varnumber_T,
        pub v_special: SpecialVarValue,
        pub v_float: float_T,
        pub v_string: *mut char_u,
        pub v_list: *mut list_T,
        pub v_dict: *mut dict_T,
        pub v_partial: *mut partial_T,
    }
    #[c2rust::src_loc = "66:1"]
    pub type partial_T = partial_S;
    // /< Zero, VAR_LOCKED, VAR_FIXED.
    // Static list with 10 items. Use tv_list_init_static10() to initialize.
    // must be first
    /* Structure that holds scope dictionary itself. */
    /* Flags. */
    /* Key value. */
    // / Structure to hold a scope dictionary
// /
// / @warning Must be compatible with dictitem_T.
// /
// / For use in find_var_in_ht to pretend that it found dictionary item when it
// / finds scope dictionary.
    // / Structure to hold an item of a Dictionary
// /
// / @warning Must be compatible with ScopeDictDictItem.
// /
// / Also used for a variable.
    // / Flags for dictitem_T.di_flags
    // /< Read-only value
    // /< Value, read-only in the sandbox
    // /< Fixed value: cannot be :unlet or remove()d.
    // /< Locked value.
    // /< Separately allocated.
    // / Structure representing a Dictionary
    // /< Whole dictionary lock status.
    // /< Non-zero (#VAR_SCOPE, #VAR_DEF_SCOPE) if
                          // /< dictionary represents a scope (i.e. g:, l: …).
    // /< Reference count.
    // /< ID used when recursivery traversing a value.
    // /< Hashtab containing all items.
    // /< Copied dict used by deepcopy().
    // /< Next dictionary in used dictionaries list.
    // /< Previous dictionary in used dictionaries list.
    // /< Dictionary key watchers set by user code.
    // / Type used for script ID
    // / Format argument for scid_T
    // SCript ConteXt (SCTX): identifies a script line.
// When sourcing a script "sc_lnum" is zero, "sourcing_lnum" is the current
// line number. When executing a user function "sc_lnum" is the line where the
// function was defined, "sourcing_lnum" is the line number inside the
// function.  When stored with a function, mapping, option, etc. "sc_lnum" is
// the line number in the script "sc_sid".
    // script ID
    // sourcing sequence number
    // line number
    // Structure to hold info for a function that is currently being executed.
    // / Structure to hold info for a user function.
    // /< variable nr of arguments
    // /< nr of active calls
    // /< func_clear() was already called
    // /< arguments
    // /< function lines
    // /< true when func is being profiled
    // Profiling the function as a whole.
    // /< nr of calls
    // /< time spent in function + children
    // /< time spent in function itself
    // /< time spent in children this call
    // Profiling the function per line.
    // /< nr of times line was executed
    // /< time spent in a line + children
    // /< time spent in a line itself
    // /< start time for current line
    // /< time spent in children for this line
    // /< start wait time for current line
    // /< index of line being timed; -1 if none
    // /< line being timed was executed
    // /< SCTX where function was defined,
                                 // /< used for s: variables
    // /< reference count, see func_name_refcount()
    // /< l: local variables for closure
    // /< Name of function; can start with <SNR>123_
                                 // /< (<SNR> is K_SPECIAL KS_EXTRA KE_SNR)
    // / Maximum number of function arguments
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "299:8"]
    pub struct partial_S {
        pub pt_refcount: libc::c_int,
        pub pt_name: *mut char_u,
        pub pt_func: *mut ufunc_T,
        pub pt_auto: bool,
        pub pt_argc: libc::c_int,
        pub pt_argv: *mut typval_T,
        pub pt_dict: *mut dict_T,
    }
    #[c2rust::src_loc = "65:1"]
    pub type dict_T = dictvar_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "231:8"]
    pub struct dictvar_S {
        pub dv_lock: VarLockStatus,
        pub dv_scope: ScopeType,
        pub dv_refcount: libc::c_int,
        pub dv_copyID: libc::c_int,
        pub dv_hashtab: hashtab_T,
        pub dv_copydict: *mut dict_T,
        pub dv_used_next: *mut dict_T,
        pub dv_used_prev: *mut dict_T,
        pub watchers: QUEUE,
    }
    #[c2rust::src_loc = "138:9"]
    pub type ScopeType = libc::c_uint;
    #[c2rust::src_loc = "141:3"]
    pub const VAR_DEF_SCOPE: ScopeType = 2;
    #[c2rust::src_loc = "140:3"]
    pub const VAR_SCOPE: ScopeType = 1;
    #[c2rust::src_loc = "139:3"]
    pub const VAR_NO_SCOPE: ScopeType = 0;
    #[c2rust::src_loc = "68:1"]
    pub type ufunc_T = ufunc;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "265:8"]
    pub struct ufunc {
        pub uf_varargs: libc::c_int,
        pub uf_flags: libc::c_int,
        pub uf_calls: libc::c_int,
        pub uf_cleared: bool,
        pub uf_args: garray_T,
        pub uf_lines: garray_T,
        pub uf_profiling: libc::c_int,
        pub uf_prof_initialized: libc::c_int,
        pub uf_tm_count: libc::c_int,
        pub uf_tm_total: proftime_T,
        pub uf_tm_self: proftime_T,
        pub uf_tm_children: proftime_T,
        pub uf_tml_count: *mut libc::c_int,
        pub uf_tml_total: *mut proftime_T,
        pub uf_tml_self: *mut proftime_T,
        pub uf_tml_start: proftime_T,
        pub uf_tml_children: proftime_T,
        pub uf_tml_wait: proftime_T,
        pub uf_tml_idx: libc::c_int,
        pub uf_tml_execed: libc::c_int,
        pub uf_script_ctx: sctx_T,
        pub uf_refcount: libc::c_int,
        pub uf_scoped: *mut funccall_T,
        pub uf_name: [char_u; 0],
    }
    #[c2rust::src_loc = "262:1"]
    pub type funccall_T = funccall_S;
    #[c2rust::src_loc = "95:9"]
    pub type SpecialVarValue = libc::c_uint;
    #[c2rust::src_loc = "98:3"]
    pub const kSpecialVarNull: SpecialVarValue = 2;
    #[c2rust::src_loc = "97:3"]
    pub const kSpecialVarTrue: SpecialVarValue = 1;
    #[c2rust::src_loc = "96:3"]
    pub const kSpecialVarFalse: SpecialVarValue = 0;
    #[c2rust::src_loc = "109:9"]
    pub type VarType = libc::c_uint;
    #[c2rust::src_loc = "119:3"]
    pub const VAR_PARTIAL: VarType = 8;
    #[c2rust::src_loc = "117:3"]
    pub const VAR_SPECIAL: VarType = 7;
    #[c2rust::src_loc = "116:3"]
    pub const VAR_FLOAT: VarType = 6;
    #[c2rust::src_loc = "115:3"]
    pub const VAR_DICT: VarType = 5;
    #[c2rust::src_loc = "114:3"]
    pub const VAR_LIST: VarType = 4;
    #[c2rust::src_loc = "113:3"]
    pub const VAR_FUNC: VarType = 3;
    #[c2rust::src_loc = "112:3"]
    pub const VAR_STRING: VarType = 2;
    #[c2rust::src_loc = "111:3"]
    pub const VAR_NUMBER: VarType = 1;
    #[c2rust::src_loc = "110:3"]
    pub const VAR_UNKNOWN: VarType = 0;
    #[c2rust::src_loc = "155:1"]
    pub type listwatch_T = listwatch_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "157:8"]
    pub struct listwatch_S {
        pub lw_item: *mut listitem_T,
        pub lw_next: *mut listwatch_T,
    }
    #[c2rust::src_loc = "70:9"]
    pub type CallbackType = libc::c_uint;
    #[c2rust::src_loc = "73:3"]
    pub const kCallbackPartial: CallbackType = 2;
    #[c2rust::src_loc = "72:3"]
    pub const kCallbackFuncref: CallbackType = 1;
    #[c2rust::src_loc = "71:3"]
    pub const kCallbackNone: CallbackType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:9"]
    pub struct Callback {
        pub data: C2RustUnnamed_1,
        pub type_0: CallbackType,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "77:3"]
    pub union C2RustUnnamed_1 {
        pub funcref: *mut char_u,
        pub partial: *mut partial_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "86:16"]
    pub struct dict_watcher {
        pub callback: Callback,
        pub key_pattern: *mut libc::c_char,
        pub key_pattern_len: size_t,
        pub node: QUEUE,
        pub busy: bool,
    }
    #[c2rust::src_loc = "86:1"]
    pub type DictWatcher = dict_watcher;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "212:9"]
    pub struct ScopeDictDictItem {
        pub di_tv: typval_T,
        pub di_flags: uint8_t,
        pub di_key: [char_u; 1],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "219:9"]
    pub struct dictitem_T {
        pub di_tv: typval_T,
        pub di_flags: uint8_t,
        pub di_key: [char_u; 0],
    }
    #[c2rust::src_loc = "222:9"]
    pub type C2RustUnnamed_2 = libc::c_uint;
    #[c2rust::src_loc = "227:3"]
    pub const DI_FLAGS_ALLOC: C2RustUnnamed_2 = 16;
    #[c2rust::src_loc = "226:3"]
    pub const DI_FLAGS_LOCK: C2RustUnnamed_2 = 8;
    #[c2rust::src_loc = "225:3"]
    pub const DI_FLAGS_FIX: C2RustUnnamed_2 = 4;
    #[c2rust::src_loc = "224:3"]
    pub const DI_FLAGS_RO_SBX: C2RustUnnamed_2 = 2;
    #[c2rust::src_loc = "223:3"]
    pub const DI_FLAGS_RO: C2RustUnnamed_2 = 1;
    // In a hashtab item "hi_key" points to "di_key" in a dictitem.
// This avoids adding a pointer to the hashtab item.
    // / Convert a hashitem pointer to a dictitem pointer
    // / Increase reference count for a given list
// /
// / Does nothing for NULL lists.
// /
// / @param[in,out]  l  List to modify.
    #[inline(always)]
    #[c2rust::src_loc = "436:1"]
    pub unsafe extern "C" fn tv_list_ref(l: *mut list_T) {
        if l.is_null() { return }
        (*l).lv_refcount += 1;
    }
    // / Set a list as the return value
// /
// / @param[out]  tv  Object to receive the list
// / @param[in,out]  l  List to pass to the object
    #[inline(always)]
    #[c2rust::src_loc = "451:1"]
    pub unsafe extern "C" fn tv_list_set_ret(tv: *mut typval_T,
                                             l: *mut list_T) {
        (*tv).v_type = VAR_LIST;
        (*tv).vval.v_list = l;
        tv_list_ref(l);
    }
    // / Get list lock status
// /
// / Returns VAR_FIXED for NULL lists.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "466:1"]
    pub unsafe extern "C" fn tv_list_locked(l: *const list_T)
     -> VarLockStatus {
        if l.is_null() { return VAR_FIXED }
        return (*l).lv_lock;
    }
    // / Set list lock status
// /
// / May only “set” VAR_FIXED for NULL lists.
// /
// / @param[out]  l  List to modify.
// / @param[in]  lock  New lock status.
    #[inline]
    #[c2rust::src_loc = "480:1"]
    pub unsafe extern "C" fn tv_list_set_lock(l: *mut list_T,
                                              lock: VarLockStatus) {
        if l.is_null() {
            if lock as libc::c_uint ==
                   VAR_FIXED as libc::c_int as libc::c_uint {
            } else {
                __assert_fail(b"lock == VAR_FIXED\x00" as *const u8 as
                                  *const libc::c_char,
                              b"/home/vole/neovim/src/nvim/eval/typval.h\x00"
                                  as *const u8 as *const libc::c_char,
                              484 as libc::c_int as libc::c_uint,
                              __ASSERT_FUNCTION.as_ptr());
            }
            return
        }
        (*l).lv_lock = lock;
    }
    // / Set list copyID
// /
// / Does not expect NULL list, be careful.
// /
// / @param[out]  l  List to modify.
// / @param[in]  copyid  New copyID.
    #[inline]
    #[c2rust::src_loc = "496:1"]
    pub unsafe extern "C" fn tv_list_set_copyid(l: *mut list_T,
                                                copyid: libc::c_int) {
        (*l).lv_copyID = copyid;
    }
    // / Get the number of items in a list
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "509:1"]
    pub unsafe extern "C" fn tv_list_len(l: *const list_T) -> libc::c_int {
        if l.is_null() { return 0 as libc::c_int }
        return (*l).lv_len;
    }
    // / Get list copyID
// /
// / Does not expect NULL list, be careful.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "526:1"]
    pub unsafe extern "C" fn tv_list_copyid(l: *const list_T) -> libc::c_int {
        return (*l).lv_copyID;
    }
    // / Get latest list copy
// /
// / Gets lv_copylist field assigned by tv_list_copy() earlier.
// /
// / Does not expect NULL list, be careful.
// /
// / @param[in]  l  List to check.
    #[inline]
    #[c2rust::src_loc = "541:1"]
    pub unsafe extern "C" fn tv_list_latest_copy(l: *const list_T)
     -> *mut list_T {
        return (*l).lv_copylist;
    }
    // / Normalize index: that is, return either -1 or non-negative index
// /
// / @param[in]  l  List to index. Used to get length.
// / @param[in]  n  List index, possibly negative.
// /
// / @return -1 or list index in range [0, tv_list_len(l)).
    #[inline]
    #[c2rust::src_loc = "555:1"]
    pub unsafe extern "C" fn tv_list_uidx(l: *const list_T,
                                          mut n: libc::c_int) -> libc::c_int {
        // Negative index is relative to the end.
        if n < 0 as libc::c_int { n += tv_list_len(l) }
        // Check for index out of range.
        if n < 0 as libc::c_int || n >= tv_list_len(l) {
            return -(1 as libc::c_int)
        }
        return n;
    }
    // / Check whether list has watchers
// /
// / E.g. is referenced by a :for loop.
// /
// / @param[in]  l  List to check.
// /
// / @return true if there are watchers, false otherwise.
    #[inline]
    #[c2rust::src_loc = "579:1"]
    pub unsafe extern "C" fn tv_list_has_watchers(l: *const list_T) -> bool {
        return !l.is_null() && !(*l).lv_watch.is_null();
    }
    // / Get first list item
// /
// / @param[in]  l  List to get item from.
// /
// / @return List item or NULL in case of an empty list.
    #[inline]
    #[c2rust::src_loc = "592:1"]
    pub unsafe extern "C" fn tv_list_first(l: *const list_T)
     -> *mut listitem_T {
        if l.is_null() { return NULL_0 as *mut listitem_T }
        return (*l).lv_first;
    }
    // / Get last list item
// /
// / @param[in]  l  List to get item from.
// /
// / @return List item or NULL in case of an empty list.
    #[inline]
    #[c2rust::src_loc = "610:1"]
    pub unsafe extern "C" fn tv_list_last(l: *const list_T)
     -> *mut listitem_T {
        if l.is_null() { return NULL_0 as *mut listitem_T }
        return (*l).lv_last;
    }
    // / Set a dictionary as the return value
// /
// / @param[out]  tv  Object to receive the dictionary
// / @param[in,out]  d  Dictionary to pass to the object
    #[inline(always)]
    #[c2rust::src_loc = "627:1"]
    pub unsafe extern "C" fn tv_dict_set_ret(tv: *mut typval_T,
                                             d: *mut dict_T) {
        (*tv).v_type = VAR_DICT;
        (*tv).vval.v_dict = d;
        if !d.is_null() { (*d).dv_refcount += 1 };
    }
    // / Get the number of items in a Dictionary
// /
// / @param[in]  d  Dictionary to check.
    #[inline]
    #[c2rust::src_loc = "642:1"]
    pub unsafe extern "C" fn tv_dict_len(d: *const dict_T) -> libc::c_long {
        if d.is_null() { return 0 as libc::c_long }
        return (*d).dv_hashtab.ht_used as libc::c_long;
    }
    // / Check if dictionary is watched
// /
// / @param[in]  d  Dictionary to check.
// /
// / @return true if there is at least one watcher.
    #[inline]
    #[c2rust::src_loc = "658:1"]
    pub unsafe extern "C" fn tv_dict_is_watched(d: *const dict_T) -> bool {
        return !d.is_null() && QUEUE_EMPTY(&(*d).watchers) == 0;
    }
    // / Initialize VimL object
// /
// / Initializes to unlocked VAR_UNKNOWN object.
// /
// / @param[out]  tv  Object to initialize.
    #[inline]
    #[c2rust::src_loc = "668:1"]
    pub unsafe extern "C" fn tv_init(tv: *mut typval_T) {
        if !tv.is_null() {
            memset(tv as *mut libc::c_void, 0 as libc::c_int,
                   ::std::mem::size_of::<typval_T>() as libc::c_ulong);
        };
    }
    // / Iterate over a list
// /
// / @param  modifier  Modifier: expected to be const or nothing, volatile should
// /                   also work if you have any uses for the volatile list.
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // / Iterate over a list
// /
// / To be used when you need to modify list or values you iterate over, use
// / #TV_LIST_ITER_CONST if you don’t.
// /
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // / Iterate over a list
// /
// / To be used when you don’t need to modify list or values you iterate over,
// / use #TV_LIST_ITER if you do.
// /
// / @param[in]  l  List to iterate over.
// / @param  li  Name of the variable with current listitem_T entry.
// / @param  code  Cycle body.
    // Below macros are macros to avoid duplicating code for functionally identical
// const and non-const function variants.
    // / Get typval_T out of list item
// /
// / @param[in]  li  List item to get typval_T from, must not be NULL.
// /
// / @return Pointer to typval_T.
    // / Get next list item given the current one
// /
// / @param[in]  l  List to get item from.
// / @param[in]  li  List item to get typval_T from.
// /
// / @return Pointer to the next item or NULL.
    // / Get previous list item given the current one
// /
// / @param[in]  l  List to get item from.
// / @param[in]  li  List item to get typval_T from.
// /
// / @return Pointer to the previous item or NULL.
    // List argument is not used currently, but it is a must for lists implemented
// as a pair (size(in list), array) without terminator - basically for lists on
// top of kvec.
    // / Iterate over a dictionary
// /
// / @param[in]  d  Dictionary to iterate over.
// / @param  di  Name of the variable with current dictitem_T entry.
// / @param  code  Cycle body.
    // FIXME circular dependency, cannot import message.h.
    // / Get the float value
// /
// / Raises an error if object is not number or floating-point.
// /
// / @param[in]  tv  VimL object to get value from.
// / @param[out]  ret_f  Location where resulting float is stored.
// /
// / @return true in case of success, false if tv is not a number or float.
    #[inline]
    #[c2rust::src_loc = "790:1"]
    pub unsafe extern "C" fn tv_get_float_chk(tv: *const typval_T,
                                              ret_f: *mut float_T) -> bool {
        if (*tv).v_type as libc::c_uint ==
               VAR_FLOAT as libc::c_int as libc::c_uint {
            *ret_f = (*tv).vval.v_float;
            return true_0 != 0
        }
        if (*tv).v_type as libc::c_uint ==
               VAR_NUMBER as libc::c_int as libc::c_uint {
            *ret_f = (*tv).vval.v_number as float_T;
            return true_0 != 0
        }
        emsgf(b"%s\x00" as *const u8 as *const libc::c_char,
              gettext(b"E808: Number or Float required\x00" as *const u8 as
                          *const libc::c_char as *mut libc::c_char));
        return false_0 != 0;
    }
    // / Compute the `DictWatcher` address from a QUEUE node.
// /
// / This only exists for .asan-blacklist (ASAN doesn't handle QUEUE_DATA pointer
// / arithmetic).
    #[inline(always)]
    #[c2rust::src_loc = "813:1"]
    pub unsafe extern "C" fn tv_dict_watcher_node_data(mut q: *mut QUEUE)
     -> *mut DictWatcher {
        return (q as
                    *mut libc::c_char).offset(-(32 as libc::c_ulong as isize))
                   as *mut DictWatcher;
    }
    // / Check whether given typval_T contains a function
// /
// / That is, whether it contains VAR_FUNC or VAR_PARTIAL.
// /
// / @param[in]  tv  Typval to check.
// /
// / @return True if it is a function or a partial, false otherwise.
    #[inline]
    #[c2rust::src_loc = "828:1"]
    pub unsafe extern "C" fn tv_is_func(tv: typval_T) -> bool {
        return tv.v_type as libc::c_uint ==
                   VAR_FUNC as libc::c_int as libc::c_uint ||
                   tv.v_type as libc::c_uint ==
                       VAR_PARTIAL as libc::c_int as libc::c_uint;
    }
    use super::pos_h::linenr_T;
    use super::stdint_intn_h::int64_t;
    use super::nvim_types_h::char_u;
    use super::hashtab_h::hashtab_T;
    use super::queue_h::{QUEUE, QUEUE_EMPTY};
    use super::garray_h::garray_T;
    use super::profile_h::proftime_T;
    use super::stddef_h::{size_t, NULL_0};
    use super::stdint_uintn_h::uint8_t;
    use super::assert_h::{__assert_fail, __ASSERT_FUNCTION};
    use super::string_h::memset;
    use super::stdbool_h::{true_0, false_0};
    use super::message_h_generated_h::emsgf;
    use super::libintl_h::gettext;
    extern "C" {
        #[c2rust::src_loc = "262:16"]
        pub type funccall_S;
    }
    // NVIM_EVAL_TYPVAL_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/pos.h:47"]
pub mod pos_h {
    #[c2rust::src_loc = "4:1"]
    pub type linenr_T = libc::c_long;
    #[c2rust::src_loc = "9:1"]
    pub type colnr_T = libc::c_int;
    #[c2rust::src_loc = "14:1"]
    pub type C2RustUnnamed = libc::c_uint;
    #[c2rust::src_loc = "14:8"]
    pub const MAXLNUM: C2RustUnnamed = 2147483647;
    // line number type
    // / Format used to print values which have linenr_T type
    // / Column number type
    // / Format used to print values which have colnr_T type
    // / Maximal (invalid) line number
    // / Maximal column number, 31 bits
    #[c2rust::src_loc = "16:1"]
    pub type C2RustUnnamed_0 = libc::c_uint;
    #[c2rust::src_loc = "16:8"]
    pub const MAXCOL: C2RustUnnamed_0 = 2147483647;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:9"]
    pub struct pos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
        pub coladd: colnr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:9"]
    pub struct lpos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
    }
    // NVIM_POS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/hashtab.h:47"]
pub mod hashtab_h {
    #[c2rust::src_loc = "14:1"]
    pub type hash_T = size_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:16"]
    pub struct hashitem_S {
        pub hi_hash: hash_T,
        pub hi_key: *mut char_u,
    }
    #[c2rust::src_loc = "38:1"]
    pub type hashitem_T = hashitem_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "62:16"]
    pub struct hashtable_S {
        pub ht_mask: hash_T,
        pub ht_used: size_t,
        pub ht_filled: size_t,
        pub ht_locked: libc::c_int,
        pub ht_array: *mut hashitem_T,
        pub ht_smallarray: [hashitem_T; 16],
    }
    // / Magic number used for hashitem "hi_key" value indicating a deleted item
// /
// / Only the address is used.
    // / Type for hash number (hash calculation result).
    // / The address of "hash_removed" is used as a magic number
// / for hi_key to indicate a removed item.
    // / Hashtable item.
// /
// / Each item has a NUL terminated string key.
// / A key can appear only once in the table.
// /
// / A hash number is computed from the key for quick lookup.  When the hashes
// / of two different keys point to the same entry an algorithm is used to
// / iterate over other entries in the table until the right one is found.
// / To make the iteration work removed keys are different from entries where a
// / key was never present.
// /
// / Note that this does not contain a pointer to the key and another pointer to
// / the value. Instead, it is assumed that the key is contained within the
// / value, so that you can get a pointer to the value subtracting an offset from
// / the pointer to the key.
// / This reduces the size of this item by 1/3.
    // / Cached hash number for hi_key.
    // / Item key.
  // /
  // / Possible values mean the following:
  // / NULL                      : Item was never used.
  // / HI_KEY_REMOVED            : Item was removed.
  // / (Any other pointer value) : Item is currently being used.
    // / Initial size for a hashtable.
// / Our items are relatively small and growing is expensive, thus start with 16.
// / Must be a power of 2.
    // / An array-based hashtable.
// /
// / Keys are NUL terminated strings. They cannot be repeated within a table.
// / Values are of any type.
// /
// / The hashtable grows to accommodate more entries when needed.
    #[c2rust::src_loc = "62:1"]
    pub type hashtab_T = hashtable_S;
    use super::stddef_h::size_t;
    use super::nvim_types_h::char_u;
    // / mask used for hash value
                                // / (nr of items in array is "ht_mask" + 1)
    // / number of items used
    // / number of items used or removed
    // / counter for hash_lock()
    // / points to the array, allocated when it's
                                // / not "ht_smallarray"
    // / initial array
    // NVIM_HASHTAB_H
    // / Iterate over a hashtab
// /
// / @param[in]  ht  Hashtab to iterate over.
// / @param  hi  Name of the variable with current hashtab entry.
// / @param  code  Cycle body.
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/garray.h:47"]
pub mod garray_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:16"]
    pub struct growarray {
        pub ga_len: libc::c_int,
        pub ga_maxlen: libc::c_int,
        pub ga_itemsize: libc::c_int,
        pub ga_growsize: libc::c_int,
        pub ga_data: *mut libc::c_void,
    }
    #[c2rust::src_loc = "12:1"]
    pub type garray_T = growarray;
    // for size_t
    // for char_u
    // / Structure used for growing arrays.
// / This is used to store information that only grows, is deleted all at
// / once, and needs to be accessed by index.  See ga_clear() and ga_grow().
    // current number of items used
    // maximum number of items possible
    // sizeof(item)
    // number of items to grow each time
    // pointer to the first item
    #[inline]
    #[c2rust::src_loc = "47:1"]
    pub unsafe extern "C" fn ga_append_via_ptr(mut gap: *mut garray_T,
                                               mut item_size: size_t)
     -> *mut libc::c_void {
        if item_size as libc::c_int != (*gap).ga_itemsize {
            logmsg(WARN_LOG_LEVEL, NULL as *const libc::c_char,
                   (*::std::mem::transmute::<&[u8; 18],
                                             &[libc::c_char; 18]>(b"ga_append_via_ptr\x00")).as_ptr(),
                   50 as libc::c_int, true_0 != 0,
                   b"wrong item size (%zu), should be %d\x00" as *const u8 as
                       *const libc::c_char, item_size, (*gap).ga_itemsize);
        }
        ga_grow(gap, 1 as libc::c_int);
        let fresh0 = (*gap).ga_len;
        (*gap).ga_len = (*gap).ga_len + 1;
        return ((*gap).ga_data as
                    *mut libc::c_char).offset(item_size.wrapping_mul(fresh0 as
                                                                         size_t)
                                                  as isize) as
                   *mut libc::c_void;
    }
    use super::stddef_h::{size_t, NULL};
    use super::log_h_generated_h::logmsg;
    use super::log_h::WARN_LOG_LEVEL;
    use super::stdbool_h::true_0;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "38:1"]
        pub fn ga_grow(gap: *mut garray_T, n: libc::c_int);
    }
    // NVIM_GARRAY_H
    // / Call `free` for every pointer stored in the garray and then frees the
// / garray.
// /
// / @param gap the garray to be freed
    // / Deep free a garray of specific type using a custom free function.
// / Items in the array as well as the array itself are freed.
// /
// / @param gap the garray to be freed
// / @param item_type type of the item in the garray
// / @param free_item_fn free function that takes (*item_type) as parameter
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/queue.h:47"]
pub mod queue_h {
    // Queue implemented by circularly-linked list.
//
// Adapted from libuv. Simpler and more efficient than klist.h for implementing
// queues that support arbitrary insertion/removal.
//
// Copyright (c) 2013, Ben Noordhuis <info@bnoordhuis.nl>
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:16"]
    pub struct _queue {
        pub next: *mut _queue,
        pub prev: *mut _queue,
    }
    #[c2rust::src_loc = "27:1"]
    pub type QUEUE = _queue;
    // Public macros.
    // Important note: mutating the list while QUEUE_FOREACH is
// iterating over its elements results in undefined behavior.
    /* NOLINT(readability/braces) */
    // ffi.cdef is unable to swallow `bool` in place of `int` here.
    #[inline]
    #[c2rust::src_loc = "43:1"]
    pub unsafe extern "C" fn QUEUE_EMPTY(q: *const QUEUE) -> libc::c_int {
        return (q == (*q).next) as libc::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "51:1"]
    pub unsafe extern "C" fn QUEUE_INIT(q: *mut QUEUE) {
        (*q).next = q;
        (*q).prev = q;
    }
    #[inline]
    #[c2rust::src_loc = "57:1"]
    pub unsafe extern "C" fn QUEUE_ADD(h: *mut QUEUE, n: *mut QUEUE) {
        (*(*h).prev).next = (*n).next;
        (*(*n).next).prev = (*h).prev;
        (*h).prev = (*n).prev;
        (*(*h).prev).next = h;
    }
    #[inline]
    #[c2rust::src_loc = "66:1"]
    pub unsafe extern "C" fn QUEUE_INSERT_HEAD(h: *mut QUEUE, q: *mut QUEUE) {
        (*q).next = (*h).next;
        (*q).prev = h;
        (*(*q).next).prev = q;
        (*h).next = q;
    }
    #[inline]
    #[c2rust::src_loc = "75:1"]
    pub unsafe extern "C" fn QUEUE_INSERT_TAIL(h: *mut QUEUE, q: *mut QUEUE) {
        (*q).next = h;
        (*q).prev = (*h).prev;
        (*(*q).prev).next = q;
        (*h).prev = q;
    }
    #[inline]
    #[c2rust::src_loc = "84:1"]
    pub unsafe extern "C" fn QUEUE_REMOVE(q: *mut QUEUE) {
        (*(*q).prev).next = (*q).next;
        (*(*q).next).prev = (*q).prev;
    }
    // NVIM_LIB_QUEUE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/profile.h:47"]
pub mod profile_h {
    #[c2rust::src_loc = "7:1"]
    pub type proftime_T = uint64_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_PROFILE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/grid_defs.h:47"]
pub mod grid_defs_h {
    // maximum value for 'maxcombine'
    // The characters and attributes drawn on grids.
    #[c2rust::src_loc = "13:1"]
    pub type schar_T = [char_u; 29];
    #[c2rust::src_loc = "14:1"]
    pub type sattr_T = int16_t;
    // / ScreenGrid represents a resizable rectuangular grid displayed by UI clients.
// /
// / chars[] contains the UTF-8 text that is currently displayed on the grid.
// / It is stored as a single block of cells. When redrawing a part of the grid,
// / the new state can be compared with the existing state of the grid. This way
// / we can avoid sending bigger updates than necessary to the Ul layer.
// /
// / Screen cells are stored as NUL-terminated UTF-8 strings, and a cell can
// / contain up to MAX_MCO composing characters after the base character.
// / The composing characters are to be drawn on top of the original character.
// / The content after the NUL is not defined (so comparison must be done a
// / single cell at a time). Double-width characters are stored in the left cell,
// / and the right cell should only contain the empty string. When a part of the
// / screen is cleared, the cells should be filled with a single whitespace char.
// /
// / attrs[] contains the highlighting attribute for each cell.
// / line_offset[n] is the offset from chars[] and attrs[] for the
// / start of line 'n'. These offsets are in general not linear, as full screen
// / scrolling is implemented by rotating the offsets in the line_offset array.
// / line_wraps[] is an array of boolean flags indicating if the screen line
// / wraps to the next line. It can only be true if a window occupies the entire
// / screen width.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:9"]
    pub struct ScreenGrid {
        pub handle: handle_T,
        pub chars: *mut schar_T,
        pub attrs: *mut sattr_T,
        pub line_offset: *mut libc::c_uint,
        pub line_wraps: *mut char_u,
        pub dirty_col: *mut libc::c_int,
        pub Rows: libc::c_int,
        pub Columns: libc::c_int,
        pub valid: bool,
        pub throttled: bool,
        pub row_offset: libc::c_int,
        pub col_offset: libc::c_int,
        pub blending: bool,
        pub focusable: bool,
        pub comp_row: libc::c_int,
        pub comp_col: libc::c_int,
        pub comp_index: size_t,
        pub comp_disabled: bool,
    }
    use super::nvim_types_h::{char_u, handle_T};
    use super::stdint_intn_h::int16_t;
    use super::stddef_h::size_t;
    // NVIM_GRID_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/buffer_defs.h:47"]
pub mod buffer_defs_h {
    // for FILE
    // Forward declaration
    // Reference to a buffer that stores the value of buf_free_count.
// bufref_valid() only needs to check "buf" when the count differs.
    // for garray_T
    // for ScreenGrid
    // for HLF_COUNT
    // for pos_T, lpos_T and linenr_T
    // for the number window-local and buffer-local options
    // for jump list and tag stack sizes in a buffer and mark types
    // for u_header_T; needs buf_T.
    // for hashtab_T
    // for dict_T
    // for proftime_T
    // for String
    // for Map(K, V)
    // for kvec
    // for marktree
    /*
 * Flags for w_valid.
 * These are set when something in a window structure becomes invalid, except
 * when the cursor is moved.  Call check_cursor_moved() before testing one of
 * the flags.
 * These are reset when that thing has been updated and is valid again.
 *
 * Every function that invalidates one of these must call one of the
 * invalidate_* functions.
 *
 * w_valid is supposed to be used only in screen.c.  From other files, use the
 * functions that set or reset the flags.
 *
 * VALID_BOTLINE    VALID_BOTLINE_AP
 *     on       on      w_botline valid
 *     off      on      w_botline approximated
 *     off      off     w_botline not valid
 *     on       off     not possible
 */
    /* w_wrow (window row) is valid */
    /* w_wcol (window col) is valid */
    /* w_virtcol (file col) is valid */
    /* w_cline_height and w_cline_folded valid */
    /* w_cline_row is valid */
    /* w_botine and w_empty_rows are valid */
    /* w_botine is approximated */
    /* w_topline is valid (for cursor position) */
    // flags for b_flags
    // buffer has been recovered
    // need to check readonly when loading file
                                // into buffer (set by ":e", may be reset by
                                // ":buf")
    // file has never been loaded into buffer,
                                // many variables still need to be set
    // Set when file name is changed after
                                // starting to edit, reset when file is
                                // written out.
    // file didn't exist when editing started
    // Warned for BF_NEW and file created
    // got errors while reading the file
    // dummy buffer, only used internally
    // ":preserve" was used
    /* Mask to check for flags that prevent normal writing */
    // display tick type
    // for struct memline (it needs memfile_T)
    // for struct memfile, bhdr_T, blocknr_T... (it needs buf_T)
    // for regprog_T. Needs win_T and buf_T.
    // for synstate_T (needs reg_extmatch_T, win_T, buf_T)
    // for signlist_T
    /*
 * The taggy struct is used to store the information about a :tag command.
 */
    // tag name
    // cursor position BEFORE ":tag"
    // match number
    // buffer number used for cur_match
    // used with tagfunc
    /*
 * structure used to store one block of the stuff/redo/recording buffers
 */
    // pointer to next buffblock
    // contents (actually longer)
    /*
 * header used for the stuff buffer and the redo buffer
 */
    // first (dummy) block of list
    // buffblock for appending
    // index for reading
    // space in bh_curr for appending
    /*
 * Structure that contains all options that are local to a window.
 * Used twice in a window: for the current buffer and for all buffers.
 * Also used in wininfo_T.
 */
    /* 'arabic' */
    // 'breakindent'
    /* 'breakindentopt' */
    // 'diff'
    // 'foldcolumn'
    // 'fdc' saved for diff mode
    /* 'foldenable' */
    /* 'foldenable' saved for diff mode */
    /* 'foldignore' */
    /* 'foldlevel' */
    /* 'foldlevel' state saved for diff mode */
    /* 'foldmethod' */
    /* 'fdm' saved for diff mode */
    /* 'foldminlines' */
    /* 'foldnestmax' */
    /* 'foldexpr' */
    /* 'foldtext' */
    /* 'foldmarker' */
    /* 'linebreak' */
    /* 'list' */
    /* 'number' */
    /* 'relativenumber' */
    /* 'numberwidth' */
    /* 'winfixheight' */
    /* 'winfixwidth' */
    /* 'previewwindow' */
    /* 'rightleft' */
    /* 'rightleftcmd' */
    /* 'scroll' */
    /* 'spell' */
    /* 'cursorcolumn' */
    /* 'cursorline' */
    /* 'colorcolumn' */
    /* 'statusline' */
    /* 'scrollbind' */
    /* options were saved for starting diff mode */
    /* 'scrollbind' saved for diff mode*/
    /* 'wrap' */
    /* 'wrap' state saved for diff mode*/
    /* 'concealcursor' */
    /* 'conceallevel' */
    /* 'cursorbind' */
    /* 'cursorbind' state saved for diff mode*/
    // 'signcolumn'
    // 'winhighlight'
    // 'fillchars'
    // 'listchars'
    // 'winblend'
    // SCTXs for window-local options
    /*
 * Window info stored with a buffer.
 *
 * Two types of info are kept for a buffer which are associated with a
 * specific window:
 * 1. Each window can have a different line number associated with a buffer.
 * 2. The window-local options for a buffer work in a similar way.
 * The window-info is kept in a list at b_wininfo.  It is kept in
 * most-recently-used order.
 */
    /* next entry or NULL for last entry */
    /* previous entry or NULL for first entry */
    /* pointer to window that did set wi_fpos */
    /* last cursor position in the file */
    /* true when wi_opt has useful values */
    /* local window options */
    /* copy of w_fold_manual */
    /* clone of w_folds */
    /*
 * Argument list: Array of file names.
 * Used for the global argument list and the argument lists local to a window.
 *
 * TODO: move struct arglist to another header
 */
    /* growarray with the array of file names */
    /* number of windows using this arglist */
    // /< id of this arglist
    /*
 * For each argument remember the file name as it was given, and the buffer
 * number that contains the expanded file name (required for when ":cd" is
 * used.
 *
 * TODO: move aentry_T to another header
 */
    /* file name as specified */
    /* buffer number with expanded file name */
    /*
 * Used for the typeahead buffer: typebuf.
 */
    /* buffer for typed characters */
    /* mapping flags for characters in tb_buf[] */
    /* size of tb_buf[] */
    /* current position in tb_buf[] */
    /* number of valid bytes in tb_buf[] */
    /* nr of mapped bytes in tb_buf[] */
    /* nr of silently mapped bytes in tb_buf[] */
    /* nr of bytes without abbrev. in tb_buf[] */
    /* nr of time tb_buf was changed; never zero */
    /* Struct to hold the saved typeahead for save_typeahead(). */
    /* TRUE when save_typebuf valid */
    /*
 * Structure used for mappings and abbreviations.
 */
    // next mapblock in list
    // mapped from, lhs
    // mapped to, rhs
    // rhs as entered by the user
    // strlen(m_keys)
    // valid mode
    // if non-zero no re-mapping for m_str
    // <silent> used, don't echo commands
    // <nowait> used
    // <expr> used, m_str is an expression
    // SCTX where map was defined
    /*
 * Used for highlighting in the status line.
 */
    /* 0: no HL, 1-9: User HL, < 0 for syn ID */
    /* values for b_syn_spell: what to do with toplevel text */
    /* spell check if @Spell not defined */
    /* spell check toplevel text */
    /* don't spell check toplevel text */
    /* avoid #ifdefs for when b_spell is not available */
    /*
 * Used for :syntime: timing of executing a syntax pattern.
 */
    /* total time used */
    /* time of slowest call */
    /* nr of times used */
    /* nr of times matched */
    /*
 * These are items normally related to a buffer.  But when using ":ownsyntax"
 * a window may have its own instance.
 */
    // syntax keywords hash table
    // idem, ignore case
    // TRUE when error occurred in HL
    // true when 'redrawtime' reached
    // ignore case for :syn cmds
    // SYNSPL_ values
    // table for syntax patterns
    // table for syntax clusters
    // @Spell cluster ID or 0
    // @NoSpell cluster ID or 0
    // TRUE when there is an item with a
                                        // "containedin" argument
    // flags about how to sync
    // group to sync on
    // minimal sync lines offset
    // maximal sync lines offset
    // offset for multi-line pattern
    // line continuation pattern
    // line continuation program
    /* ignore-case flag for above */
    /* for ":syntax include" */
    /* auto-conceal for :syn cmds */
    /* number of patterns with the HL_FOLD
                                           flag set */
    /*
   * b_sst_array[] contains the state stack for a number of lines, for the
   * start of that line (col == 0).  This avoids having to recompute the
   * syntax state too often.
   * b_sst_array[] is allocated to hold the state for all displayed lines,
   * and states for 1 out of about 20 other lines.
   * b_sst_array        pointer to an array of synstate_T
   * b_sst_len          number of entries in b_sst_array[]
   * b_sst_first        pointer to first used entry in b_sst_array[] or NULL
   * b_sst_firstfree    pointer to first free entry in b_sst_array[] or NULL
   * b_sst_freecount    number of free entries in b_sst_array[]
   * b_sst_check_lnum   entries after this lnum need to be checked for
   *                    validity (MAXLNUM means no check needed)
   */
    // last display tick
    // for spell checking
    // list of pointers to slang_T, see spell.c
    // flags: is midword char
    // multi-byte midword chars
    // 'spellcapcheck'
    // program for 'spellcapcheck'
    // 'spellfile'
    // 'spelllang'
    // all CJK letters as OK
    // syntax iskeyword option
    // iskeyword option
    // / Type used for changedtick_di member in buf_T
// /
// / Primary exists so that literals of relevant type can be made.
    // Maximum number of maphash blocks we will have
    /*
 * buffer: structure that holds information about one file
 *
 * Several windows can share a single Buffer
 * A buffer is unallocated if there is no memfile for it.
 * A buffer is new if the associated file has never been loaded yet.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "485:8"]
    pub struct file_buffer {
        pub handle: handle_T,
        pub b_ml: memline_T,
        pub b_next: *mut buf_T,
        pub b_prev: *mut buf_T,
        pub b_nwindows: libc::c_int,
        pub b_flags: libc::c_int,
        pub b_locked: libc::c_int,
        pub b_ffname: *mut char_u,
        pub b_sfname: *mut char_u,
        pub b_fname: *mut char_u,
        pub file_id_valid: bool,
        pub file_id: FileID,
        pub b_changed: libc::c_int,
        pub changedtick_di: ChangedtickDictItem,
        pub b_last_changedtick: varnumber_T,
        pub b_last_changedtick_pum: varnumber_T,
        pub b_saving: bool,
        pub b_mod_set: bool,
        pub b_mod_top: linenr_T,
        pub b_mod_bot: linenr_T,
        pub b_mod_xlines: libc::c_long,
        pub b_wininfo: *mut wininfo_T,
        pub b_mtime: libc::c_long,
        pub b_mtime_read: libc::c_long,
        pub b_orig_size: uint64_t,
        pub b_orig_mode: libc::c_int,
        pub b_namedm: [fmark_T; 26],
        pub b_visual: visualinfo_T,
        pub b_visual_mode_eval: libc::c_int,
        pub b_last_cursor: fmark_T,
        pub b_last_insert: fmark_T,
        pub b_last_change: fmark_T,
        pub b_changelist: [fmark_T; 100],
        pub b_changelistlen: libc::c_int,
        pub b_new_change: bool,
        pub b_chartab: [uint64_t; 4],
        pub b_maphash: [*mut mapblock_T; 256],
        pub b_first_abbr: *mut mapblock_T,
        pub b_ucmds: garray_T,
        pub b_op_start: pos_T,
        pub b_op_start_orig: pos_T,
        pub b_op_end: pos_T,
        pub b_marks_read: bool,
        pub b_u_oldhead: *mut u_header_T,
        pub b_u_newhead: *mut u_header_T,
        pub b_u_curhead: *mut u_header_T,
        pub b_u_numhead: libc::c_int,
        pub b_u_synced: bool,
        pub b_u_seq_last: libc::c_long,
        pub b_u_save_nr_last: libc::c_long,
        pub b_u_seq_cur: libc::c_long,
        pub b_u_time_cur: time_t,
        pub b_u_save_nr_cur: libc::c_long,
        pub b_u_line_ptr: *mut char_u,
        pub b_u_line_lnum: linenr_T,
        pub b_u_line_colnr: colnr_T,
        pub b_scanned: bool,
        pub b_p_iminsert: libc::c_long,
        pub b_p_imsearch: libc::c_long,
        pub b_kmap_state: libc::c_short,
        pub b_kmap_ga: garray_T,
        pub b_p_initialized: bool,
        pub b_p_script_ctx: [LastSet; 80],
        pub b_p_ai: libc::c_int,
        pub b_p_ai_nopaste: libc::c_int,
        pub b_p_bkc: *mut char_u,
        pub b_bkc_flags: libc::c_uint,
        pub b_p_ci: libc::c_int,
        pub b_p_bin: libc::c_int,
        pub b_p_bomb: libc::c_int,
        pub b_p_bh: *mut char_u,
        pub b_p_bt: *mut char_u,
        pub b_has_qf_entry: libc::c_int,
        pub b_p_bl: libc::c_int,
        pub b_p_channel: libc::c_long,
        pub b_p_cin: libc::c_int,
        pub b_p_cino: *mut char_u,
        pub b_p_cink: *mut char_u,
        pub b_p_cinw: *mut char_u,
        pub b_p_com: *mut char_u,
        pub b_p_cms: *mut char_u,
        pub b_p_cpt: *mut char_u,
        pub b_p_cfu: *mut char_u,
        pub b_p_ofu: *mut char_u,
        pub b_p_tfu: *mut char_u,
        pub b_p_eol: libc::c_int,
        pub b_p_fixeol: libc::c_int,
        pub b_p_et: libc::c_int,
        pub b_p_et_nobin: libc::c_int,
        pub b_p_et_nopaste: libc::c_int,
        pub b_p_fenc: *mut char_u,
        pub b_p_ff: *mut char_u,
        pub b_p_ft: *mut char_u,
        pub b_p_fo: *mut char_u,
        pub b_p_flp: *mut char_u,
        pub b_p_inf: libc::c_int,
        pub b_p_isk: *mut char_u,
        pub b_p_def: *mut char_u,
        pub b_p_inc: *mut char_u,
        pub b_p_inex: *mut char_u,
        pub b_p_inex_flags: uint32_t,
        pub b_p_inde: *mut char_u,
        pub b_p_inde_flags: uint32_t,
        pub b_p_indk: *mut char_u,
        pub b_p_fp: *mut char_u,
        pub b_p_fex: *mut char_u,
        pub b_p_fex_flags: uint32_t,
        pub b_p_kp: *mut char_u,
        pub b_p_lisp: libc::c_int,
        pub b_p_menc: *mut char_u,
        pub b_p_mps: *mut char_u,
        pub b_p_ml: libc::c_int,
        pub b_p_ml_nobin: libc::c_int,
        pub b_p_ma: libc::c_int,
        pub b_p_nf: *mut char_u,
        pub b_p_pi: libc::c_int,
        pub b_p_qe: *mut char_u,
        pub b_p_ro: libc::c_int,
        pub b_p_sw: libc::c_long,
        pub b_p_scbk: libc::c_long,
        pub b_p_si: libc::c_int,
        pub b_p_sts: libc::c_long,
        pub b_p_sts_nopaste: libc::c_long,
        pub b_p_sua: *mut char_u,
        pub b_p_swf: libc::c_int,
        pub b_p_smc: libc::c_long,
        pub b_p_syn: *mut char_u,
        pub b_p_ts: libc::c_long,
        pub b_p_tw: libc::c_long,
        pub b_p_tw_nobin: libc::c_long,
        pub b_p_tw_nopaste: libc::c_long,
        pub b_p_wm: libc::c_long,
        pub b_p_wm_nobin: libc::c_long,
        pub b_p_wm_nopaste: libc::c_long,
        pub b_p_keymap: *mut char_u,
        pub b_p_gp: *mut char_u,
        pub b_p_mp: *mut char_u,
        pub b_p_efm: *mut char_u,
        pub b_p_ep: *mut char_u,
        pub b_p_path: *mut char_u,
        pub b_p_ar: libc::c_int,
        pub b_p_tags: *mut char_u,
        pub b_p_tc: *mut char_u,
        pub b_tc_flags: libc::c_uint,
        pub b_p_dict: *mut char_u,
        pub b_p_tsr: *mut char_u,
        pub b_p_ul: libc::c_long,
        pub b_p_udf: libc::c_int,
        pub b_p_lw: *mut char_u,
        pub b_ind_level: libc::c_int,
        pub b_ind_open_imag: libc::c_int,
        pub b_ind_no_brace: libc::c_int,
        pub b_ind_first_open: libc::c_int,
        pub b_ind_open_extra: libc::c_int,
        pub b_ind_close_extra: libc::c_int,
        pub b_ind_open_left_imag: libc::c_int,
        pub b_ind_jump_label: libc::c_int,
        pub b_ind_case: libc::c_int,
        pub b_ind_case_code: libc::c_int,
        pub b_ind_case_break: libc::c_int,
        pub b_ind_param: libc::c_int,
        pub b_ind_func_type: libc::c_int,
        pub b_ind_comment: libc::c_int,
        pub b_ind_in_comment: libc::c_int,
        pub b_ind_in_comment2: libc::c_int,
        pub b_ind_cpp_baseclass: libc::c_int,
        pub b_ind_continuation: libc::c_int,
        pub b_ind_unclosed: libc::c_int,
        pub b_ind_unclosed2: libc::c_int,
        pub b_ind_unclosed_noignore: libc::c_int,
        pub b_ind_unclosed_wrapped: libc::c_int,
        pub b_ind_unclosed_whiteok: libc::c_int,
        pub b_ind_matching_paren: libc::c_int,
        pub b_ind_paren_prev: libc::c_int,
        pub b_ind_maxparen: libc::c_int,
        pub b_ind_maxcomment: libc::c_int,
        pub b_ind_scopedecl: libc::c_int,
        pub b_ind_scopedecl_code: libc::c_int,
        pub b_ind_java: libc::c_int,
        pub b_ind_js: libc::c_int,
        pub b_ind_keep_case_label: libc::c_int,
        pub b_ind_hash_comment: libc::c_int,
        pub b_ind_cpp_namespace: libc::c_int,
        pub b_ind_if_for_while: libc::c_int,
        pub b_ind_cpp_extern_c: libc::c_int,
        pub b_no_eol_lnum: linenr_T,
        pub b_start_eol: libc::c_int,
        pub b_start_ffc: libc::c_int,
        pub b_start_fenc: *mut char_u,
        pub b_bad_char: libc::c_int,
        pub b_start_bomb: libc::c_int,
        pub b_bufvar: ScopeDictDictItem,
        pub b_vars: *mut dict_T,
        pub b_may_swap: bool,
        pub b_did_warn: bool,
        pub b_help: bool,
        pub b_spell: bool,
        pub b_prompt_text: *mut char_u,
        pub b_prompt_callback: Callback,
        pub b_prompt_interrupt: Callback,
        pub b_prompt_insert: libc::c_int,
        pub b_s: synblock_T,
        pub b_signlist: *mut signlist_T,
        pub b_signcols_max: libc::c_int,
        pub b_signcols: libc::c_int,
        pub terminal: *mut Terminal,
        pub additional_data: *mut dict_T,
        pub b_mapped_ctrl_c: libc::c_int,
        pub b_marktree: [MarkTree; 1],
        pub b_extmark_index: *mut Map_uint64_t_ExtmarkItem,
        pub b_extmark_ns: *mut Map_uint64_t_ExtmarkNs,
        pub update_channels: C2RustUnnamed_4,
        pub update_callbacks: C2RustUnnamed_3,
        pub update_need_codepoints: bool,
        pub deleted_bytes: size_t,
        pub deleted_codepoints: size_t,
        pub deleted_codeunits: size_t,
        pub flush_count: libc::c_int,
        pub b_luahl: bool,
        pub b_luahl_start: LuaRef,
        pub b_luahl_window: LuaRef,
        pub b_luahl_line: LuaRef,
        pub b_luahl_end: LuaRef,
        pub b_diff_failed: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "822:3"]
    pub struct C2RustUnnamed_3 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut BufUpdateCallbacks,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "459:9"]
    pub struct BufUpdateCallbacks {
        pub on_lines: LuaRef,
        pub on_bytes: LuaRef,
        pub on_changedtick: LuaRef,
        pub on_detach: LuaRef,
        pub utf_sizes: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "820:3"]
    pub struct C2RustUnnamed_4 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "393:9"]
    pub struct synblock_T {
        pub b_keywtab: hashtab_T,
        pub b_keywtab_ic: hashtab_T,
        pub b_syn_error: libc::c_int,
        pub b_syn_slow: bool,
        pub b_syn_ic: libc::c_int,
        pub b_syn_spell: libc::c_int,
        pub b_syn_patterns: garray_T,
        pub b_syn_clusters: garray_T,
        pub b_spell_cluster_id: libc::c_int,
        pub b_nospell_cluster_id: libc::c_int,
        pub b_syn_containedin: libc::c_int,
        pub b_syn_sync_flags: libc::c_int,
        pub b_syn_sync_id: int16_t,
        pub b_syn_sync_minlines: libc::c_long,
        pub b_syn_sync_maxlines: libc::c_long,
        pub b_syn_sync_linebreaks: libc::c_long,
        pub b_syn_linecont_pat: *mut char_u,
        pub b_syn_linecont_prog: *mut regprog_T,
        pub b_syn_linecont_time: syn_time_T,
        pub b_syn_linecont_ic: libc::c_int,
        pub b_syn_topgrp: libc::c_int,
        pub b_syn_conceal: libc::c_int,
        pub b_syn_folditems: libc::c_int,
        pub b_sst_array: *mut synstate_T,
        pub b_sst_len: libc::c_int,
        pub b_sst_first: *mut synstate_T,
        pub b_sst_firstfree: *mut synstate_T,
        pub b_sst_freecount: libc::c_int,
        pub b_sst_check_lnum: linenr_T,
        pub b_sst_lasttick: disptick_T,
        pub b_langp: garray_T,
        pub b_spell_ismw: [bool; 256],
        pub b_spell_ismw_mb: *mut char_u,
        pub b_p_spc: *mut char_u,
        pub b_cap_prog: *mut regprog_T,
        pub b_p_spf: *mut char_u,
        pub b_p_spl: *mut char_u,
        pub b_cjk: libc::c_int,
        pub b_syn_chartab: [char_u; 32],
        pub b_syn_isk: *mut char_u,
    }
    #[c2rust::src_loc = "9:1"]
    pub type buf_T = file_buffer;
    #[c2rust::src_loc = "98:1"]
    pub type win_T = window_S;
    // internal diff failed for this buffer
    /*
 * Stuff for diff mode.
 */
    // up to four buffers can be diff'ed
    /*
 * Each diffblock defines where a block of lines starts in each of the buffers
 * and how many lines it occupies in that buffer.  When the lines are missing
 * in the buffer the df_count[] is zero.  This is all counted in
 * buffer lines.
 * There is always at least one unchanged line in between the diffs.
 * Otherwise it would have been included in the diff above or below it.
 * df_lnum[] + df_count[] is the lnum below the change.  When in one buffer
 * lines have been inserted, in the other buffer df_lnum[] is the line below
 * the insertion and df_count[] is zero.  When appending lines at the end of
 * the buffer, df_lnum[] is one beyond the end!
 * This is using a linked list, because the number of differences is expected
 * to be reasonable small.  The list is sorted on lnum.
 */
    /* line number in buffer */
    /* nr of inserted/changed lines */
    // / Tab pages point to the top frame of each tab page.
// / Note: Most values are NOT valid for the current tab page!  Use "curwin",
// / "firstwin", etc. for that.  "tp_topframe" is always valid and can be
// / compared against "topframe" to find the current tab page.
    // /< next tabpage or NULL
    // /< topframe for the windows
    // /< current window in this Tab page
    // /< previous window in this Tab page
    // /< first window in this Tab page
    // /< last window in this Tab page
    // /< Rows when Tab page was left
    // /< Columns when Tab page was left
    // /< value of 'cmdheight' when frame size
                                    // /< was set
    // /< list of diffs is outdated
    // /< update diffs before redrawing
    // /< window layout snapshots
    // /< Variable for "t:" Dictionary.
    // /< Internal variables, local to tab page.
    // /< Absolute path of local cwd or NULL.
    /*
 * Structure to cache info for displayed lines in w_lines[].
 * Each logical line has one entry.
 * The entry tells how the logical line is currently displayed in the window.
 * This is updated when displaying the window.
 * When the display is changed (e.g., when clearing the screen) w_lines_valid
 * is changed to exclude invalid entries.
 * When making changes to the buffer, wl_valid is reset to indicate wl_size
 * may not reflect what is actually in the buffer.  When wl_valid is FALSE,
 * the entries can only be used to count the number of displayed lines used.
 * wl_lnum and wl_lastlnum are invalid too.
 */
    /* buffer line number for logical line */
    /* height in screen lines */
    /* TRUE values are valid for text in buffer */
    /* TRUE when this is a range of folded lines */
    /* last buffer line number for logical line */
    /*
 * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)
 * or row (FR_ROW) layout or is a leaf, which has a window.
 */
    // FR_LEAF, FR_COL or FR_ROW
    // new width used in win_equal_rec()
    // new height used in win_equal_rec()
    // containing frame or NULL
    // frame right or below in same parent, NULL
                                // for last
    // frame left or above in same parent, NULL
                                // for first
    // fr_child and fr_win are mutually exclusive
    // first contained frame
    // window that fills this frame
    /* frame is a leaf */
    /* frame with a row of windows */
    /* frame with a column of windows */
    /*
 * Struct used for highlighting 'hlsearch' matches, matches defined by
 * ":match" and matches defined by match functions.
 * For 'hlsearch' there is one pattern for all windows.  For ":match" and the
 * match functions there is a different pattern for each window.
 */
    // points to the regexp program; contains last found
                        // match (may continue in next line)
    // the buffer to search for a match
    // the line to search for a match
    // attributes to be used for a match
    // attributes currently active in win_line()
    // first lnum to search for multi-line pat
    // in win_line() points to char where HL starts
    // in win_line() points to char where HL ends
    // position specified directly by matchaddpos()
    // for a time limit
    // / number of positions supported by matchaddpos()
    // / Same as lpos_T, but with additional field len.
    // /< line number
    // /< column number
    // /< length: 0 - to the end of line
    // / posmatch_T provides an array for storing match items for matchaddpos()
// / function.
    // /< array of positions
    // /< internal position counter
    // /< top buffer line
    // /< bottom buffer line
    /*
 * matchitem_T provides a linked list for storing match items for ":match" and
 * the match functions.
 */
    // /< match ID
    // /< match priority
    // /< pattern to highlight
    // /< highlight group ID
    // /< regexp program for pattern
    // /< position matches
    // /< struct for doing the actual highlighting
    // /< cchar for Conceal highlighting
    // NW -> 0
// NE -> kFloatAnchorEast
// SW -> kFloatAnchorSouth
// SE -> kFloatAnchorSouth | kFloatAnchorEast
    // / Minimal UI: no number column, eob markers, etc
    // Structure to store last cursor position and topline.  Used by check_lnums()
// and reset_lnums().
    // original topline value
    // corrected topline value
    // original cursor position
    // corrected cursor position
    // / Structure which contains all information that belongs to a window.
// /
// / All row numbers are relative to the start of the window, except w_winrow.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1067:8"]
    pub struct window_S {
        pub handle: handle_T,
        pub w_buffer: *mut buf_T,
        pub w_s: *mut synblock_T,
        pub w_hl_id_normal: libc::c_int,
        pub w_hl_attr_normal: libc::c_int,
        pub w_hl_ids: [libc::c_int; 50],
        pub w_hl_attrs: [libc::c_int; 50],
        pub w_hl_needs_update: libc::c_int,
        pub w_prev: *mut win_T,
        pub w_next: *mut win_T,
        pub w_closing: bool,
        pub w_frame: *mut frame_T,
        pub w_cursor: pos_T,
        pub w_curswant: colnr_T,
        pub w_set_curswant: libc::c_int,
        pub w_last_cursorline: linenr_T,
        pub w_last_cursormoved: pos_T,
        pub w_old_visual_mode: libc::c_char,
        pub w_old_cursor_lnum: linenr_T,
        pub w_old_cursor_fcol: colnr_T,
        pub w_old_cursor_lcol: colnr_T,
        pub w_old_visual_lnum: linenr_T,
        pub w_old_visual_col: colnr_T,
        pub w_old_curswant: colnr_T,
        pub w_p_lcs_chars: C2RustUnnamed_6,
        pub w_p_fcs_chars: C2RustUnnamed_5,
        pub w_topline: linenr_T,
        pub w_topline_was_set: libc::c_char,
        pub w_topfill: libc::c_int,
        pub w_old_topfill: libc::c_int,
        pub w_botfill: bool,
        pub w_old_botfill: bool,
        pub w_leftcol: colnr_T,
        pub w_skipcol: colnr_T,
        pub w_winrow: libc::c_int,
        pub w_height: libc::c_int,
        pub w_status_height: libc::c_int,
        pub w_wincol: libc::c_int,
        pub w_width: libc::c_int,
        pub w_vsep_width: libc::c_int,
        pub w_save_cursor: pos_save_T,
        pub w_height_inner: libc::c_int,
        pub w_width_inner: libc::c_int,
        pub w_height_request: libc::c_int,
        pub w_width_request: libc::c_int,
        pub w_valid: libc::c_int,
        pub w_valid_cursor: pos_T,
        pub w_valid_leftcol: colnr_T,
        pub w_cline_height: libc::c_int,
        pub w_cline_folded: bool,
        pub w_cline_row: libc::c_int,
        pub w_virtcol: colnr_T,
        pub w_wrow: libc::c_int,
        pub w_wcol: libc::c_int,
        pub w_botline: linenr_T,
        pub w_empty_rows: libc::c_int,
        pub w_filler_rows: libc::c_int,
        pub w_lines_valid: libc::c_int,
        pub w_lines: *mut wline_T,
        pub w_folds: garray_T,
        pub w_fold_manual: bool,
        pub w_foldinvalid: bool,
        pub w_nrwidth: libc::c_int,
        pub w_redr_type: libc::c_int,
        pub w_upd_rows: libc::c_int,
        pub w_redraw_top: linenr_T,
        pub w_redraw_bot: linenr_T,
        pub w_redr_status: libc::c_int,
        pub w_ru_cursor: pos_T,
        pub w_ru_virtcol: colnr_T,
        pub w_ru_topline: linenr_T,
        pub w_ru_line_count: linenr_T,
        pub w_ru_topfill: libc::c_int,
        pub w_ru_empty: libc::c_char,
        pub w_alt_fnum: libc::c_int,
        pub w_alist: *mut alist_T,
        pub w_arg_idx: libc::c_int,
        pub w_arg_idx_invalid: libc::c_int,
        pub w_localdir: *mut char_u,
        pub w_onebuf_opt: winopt_T,
        pub w_allbuf_opt: winopt_T,
        pub w_p_stl_flags: uint32_t,
        pub w_p_fde_flags: uint32_t,
        pub w_p_fdt_flags: uint32_t,
        pub w_p_cc_cols: *mut libc::c_int,
        pub w_p_brimin: libc::c_int,
        pub w_p_brishift: libc::c_int,
        pub w_p_brisbr: bool,
        pub w_p_siso: libc::c_long,
        pub w_p_so: libc::c_long,
        pub w_scbind_pos: libc::c_long,
        pub w_winvar: ScopeDictDictItem,
        pub w_vars: *mut dict_T,
        pub w_pcmark: pos_T,
        pub w_prev_pcmark: pos_T,
        pub w_jumplist: [xfmark_T; 100],
        pub w_jumplistlen: libc::c_int,
        pub w_jumplistidx: libc::c_int,
        pub w_changelistidx: libc::c_int,
        pub w_match_head: *mut matchitem_T,
        pub w_next_match_id: libc::c_int,
        pub w_tagstack: [taggy_T; 20],
        pub w_tagstackidx: libc::c_int,
        pub w_tagstacklen: libc::c_int,
        pub w_grid: ScreenGrid,
        pub w_pos_changed: bool,
        pub w_floating: bool,
        pub w_float_config: FloatConfig,
        pub w_fraction: libc::c_int,
        pub w_prev_fraction_row: libc::c_int,
        pub w_nrwidth_line_count: linenr_T,
        pub w_nrwidth_width: libc::c_int,
        pub w_llist: *mut qf_info_T,
        pub w_llist_ref: *mut qf_info_T,
    }
    #[c2rust::src_loc = "377:1"]
    pub type qf_info_T = qf_info_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1035:9"]
    pub struct FloatConfig {
        pub window: Window,
        pub bufpos: lpos_T,
        pub height: libc::c_int,
        pub width: libc::c_int,
        pub row: libc::c_double,
        pub col: libc::c_double,
        pub anchor: FloatAnchor,
        pub relative: FloatRelative,
        pub external: bool,
        pub focusable: bool,
        pub style: WinStyle,
    }
    #[c2rust::src_loc = "1030:9"]
    pub type WinStyle = libc::c_uint;
    #[c2rust::src_loc = "1032:3"]
    pub const kWinStyleMinimal: WinStyle = 1;
    #[c2rust::src_loc = "1031:3"]
    pub const kWinStyleUnused: WinStyle = 0;
    #[c2rust::src_loc = "1021:9"]
    pub type FloatRelative = libc::c_uint;
    #[c2rust::src_loc = "1024:3"]
    pub const kFloatRelativeCursor: FloatRelative = 2;
    #[c2rust::src_loc = "1023:3"]
    pub const kFloatRelativeWindow: FloatRelative = 1;
    #[c2rust::src_loc = "1022:3"]
    pub const kFloatRelativeEditor: FloatRelative = 0;
    #[c2rust::src_loc = "1008:1"]
    pub type FloatAnchor = libc::c_int;
    #[c2rust::src_loc = "121:1"]
    pub type taggy_T = taggy;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "121:16"]
    pub struct taggy {
        pub tagname: *mut char_u,
        pub fmark: fmark_T,
        pub cur_match: libc::c_int,
        pub cur_fnum: libc::c_int,
        pub user_data: *mut char_u,
    }
    #[c2rust::src_loc = "995:1"]
    pub type matchitem_T = matchitem;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "996:8"]
    pub struct matchitem {
        pub next: *mut matchitem_T,
        pub id: libc::c_int,
        pub priority: libc::c_int,
        pub pattern: *mut char_u,
        pub hlg_id: libc::c_int,
        pub match_0: regmmatch_T,
        pub pos: posmatch_T,
        pub hl: match_T,
        pub conceal_char: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "955:9"]
    pub struct match_T {
        pub rm: regmmatch_T,
        pub buf: *mut buf_T,
        pub lnum: linenr_T,
        pub attr: libc::c_int,
        pub attr_cur: libc::c_int,
        pub first_lnum: linenr_T,
        pub startcol: colnr_T,
        pub endcol: colnr_T,
        pub is_addpos: bool,
        pub tm: proftime_T,
    }
    #[c2rust::src_loc = "982:1"]
    pub type posmatch_T = posmatch;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "983:8"]
    pub struct posmatch {
        pub pos: [llpos_T; 8],
        pub cur: libc::c_int,
        pub toplnum: linenr_T,
        pub botlnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "973:9"]
    pub struct llpos_T {
        pub lnum: linenr_T,
        pub col: colnr_T,
        pub len: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "161:9"]
    pub struct winopt_T {
        pub wo_arab: libc::c_int,
        pub wo_bri: libc::c_int,
        pub wo_briopt: *mut char_u,
        pub wo_diff: libc::c_int,
        pub wo_fdc: *mut char_u,
        pub wo_fdc_save: *mut char_u,
        pub wo_fen: libc::c_int,
        pub wo_fen_save: libc::c_int,
        pub wo_fdi: *mut char_u,
        pub wo_fdl: libc::c_long,
        pub wo_fdl_save: libc::c_int,
        pub wo_fdm: *mut char_u,
        pub wo_fdm_save: *mut char_u,
        pub wo_fml: libc::c_long,
        pub wo_fdn: libc::c_long,
        pub wo_fde: *mut char_u,
        pub wo_fdt: *mut char_u,
        pub wo_fmr: *mut char_u,
        pub wo_lbr: libc::c_int,
        pub wo_list: libc::c_int,
        pub wo_nu: libc::c_int,
        pub wo_rnu: libc::c_int,
        pub wo_nuw: libc::c_long,
        pub wo_wfh: libc::c_int,
        pub wo_wfw: libc::c_int,
        pub wo_pvw: libc::c_int,
        pub wo_rl: libc::c_int,
        pub wo_rlc: *mut char_u,
        pub wo_scr: libc::c_long,
        pub wo_spell: libc::c_int,
        pub wo_cuc: libc::c_int,
        pub wo_cul: libc::c_int,
        pub wo_cc: *mut char_u,
        pub wo_stl: *mut char_u,
        pub wo_scb: libc::c_int,
        pub wo_diff_saved: libc::c_int,
        pub wo_scb_save: libc::c_int,
        pub wo_wrap: libc::c_int,
        pub wo_wrap_save: libc::c_int,
        pub wo_cocu: *mut char_u,
        pub wo_cole: libc::c_long,
        pub wo_crb: libc::c_int,
        pub wo_crb_save: libc::c_int,
        pub wo_scl: *mut char_u,
        pub wo_winhl: *mut char_u,
        pub wo_fcs: *mut char_u,
        pub wo_lcs: *mut char_u,
        pub wo_winbl: libc::c_long,
        pub wo_script_ctx: [LastSet; 42],
    }
    #[c2rust::src_loc = "290:1"]
    pub type alist_T = arglist;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "290:16"]
    pub struct arglist {
        pub al_ga: garray_T,
        pub al_refcount: libc::c_int,
        pub id: libc::c_int,
    }
    #[c2rust::src_loc = "917:1"]
    pub type wline_T = w_line;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "917:16"]
    pub struct w_line {
        pub wl_lnum: linenr_T,
        pub wl_size: uint16_t,
        pub wl_valid: libc::c_char,
        pub wl_folded: libc::c_char,
        pub wl_lastlnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1056:9"]
    pub struct pos_save_T {
        pub w_topline_save: libc::c_int,
        pub w_topline_corr: libc::c_int,
        pub w_cursor_save: pos_T,
        pub w_cursor_corr: pos_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1127:3"]
    pub struct C2RustUnnamed_5 {
        pub stl: libc::c_int,
        pub stlnc: libc::c_int,
        pub vert: libc::c_int,
        pub fold: libc::c_int,
        pub foldopen: libc::c_int,
        pub foldclosed: libc::c_int,
        pub foldsep: libc::c_int,
        pub diff: libc::c_int,
        pub msgsep: libc::c_int,
        pub eob: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1113:3"]
    pub struct C2RustUnnamed_6 {
        pub eol: libc::c_int,
        pub ext: libc::c_int,
        pub prec: libc::c_int,
        pub nbsp: libc::c_int,
        pub space: libc::c_int,
        pub tab1: libc::c_int,
        pub tab2: libc::c_int,
        pub tab3: libc::c_int,
        pub trail: libc::c_int,
        pub conceal: libc::c_int,
    }
    #[c2rust::src_loc = "100:1"]
    pub type frame_T = frame_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "929:8"]
    pub struct frame_S {
        pub fr_layout: libc::c_char,
        pub fr_width: libc::c_int,
        pub fr_newwidth: libc::c_int,
        pub fr_height: libc::c_int,
        pub fr_newheight: libc::c_int,
        pub fr_parent: *mut frame_T,
        pub fr_next: *mut frame_T,
        pub fr_prev: *mut frame_T,
        pub fr_child: *mut frame_T,
        pub fr_win: *mut win_T,
    }
    #[c2rust::src_loc = "101:1"]
    pub type disptick_T = uint16_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "382:9"]
    pub struct syn_time_T {
        pub total: proftime_T,
        pub slowest: proftime_T,
        pub count: libc::c_long,
        pub match_0: libc::c_long,
    }
    #[c2rust::src_loc = "346:1"]
    pub type mapblock_T = mapblock;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "347:8"]
    pub struct mapblock {
        pub m_next: *mut mapblock_T,
        pub m_keys: *mut char_u,
        pub m_str: *mut char_u,
        pub m_orig_str: *mut char_u,
        pub m_keylen: libc::c_int,
        pub m_mode: libc::c_int,
        pub m_noremap: libc::c_int,
        pub m_silent: libc::c_char,
        pub m_nowait: libc::c_char,
        pub m_expr: libc::c_char,
        pub m_script_ctx: sctx_T,
    }
    #[c2rust::src_loc = "99:1"]
    pub type wininfo_T = wininfo_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "273:8"]
    pub struct wininfo_S {
        pub wi_next: *mut wininfo_T,
        pub wi_prev: *mut wininfo_T,
        pub wi_win: *mut win_T,
        pub wi_fpos: pos_T,
        pub wi_optset: bool,
        pub wi_opt: winopt_T,
        pub wi_fold_manual: bool,
        pub wi_folds: garray_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "457:9"]
    pub struct ChangedtickDictItem {
        pub di_tv: typval_T,
        pub di_flags: uint8_t,
        pub di_key: [char_u; 12],
    }
    #[inline]
    #[c2rust::src_loc = "1356:1"]
    pub unsafe extern "C" fn win_hl_attr(mut wp: *mut win_T,
                                         mut hlf: libc::c_int)
     -> libc::c_int {
        return (*wp).w_hl_attrs[hlf as usize];
    }
    #[c2rust::src_loc = "93:9"]
    pub const BF_PRESERVED: libc::c_int = 0x100 as libc::c_int;
    #[c2rust::src_loc = "92:9"]
    pub const BF_DUMMY: libc::c_int = 0x80 as libc::c_int;
    #[c2rust::src_loc = "80:9"]
    pub const BF_RECOVERED: libc::c_int = 0x1 as libc::c_int;
    use super::nvim_types_h::{handle_T, char_u, LuaRef};
    use super::memline_defs_h::memline_T;
    use super::fs_defs_h::FileID;
    use super::typval_h::{varnumber_T, ScopeDictDictItem, dict_T, Callback,
                          sctx_T, typval_T};
    use super::pos_h::{linenr_T, pos_T, colnr_T, lpos_T};
    use super::stdint_uintn_h::{uint64_t, uint32_t, uint16_t, uint8_t};
    use super::mark_defs_h::{fmark_T, xfmark_T};
    use super::undo_defs_h::{visualinfo_T, u_header_T};
    use super::garray_h::garray_T;
    use super::time_t_h::time_t;
    use super::option_defs_h::LastSet;
    use super::sign_defs_h::signlist_T;
    use super::terminal_h::Terminal;
    use super::marktree_h::MarkTree;
    use super::map_h::{Map_uint64_t_ExtmarkItem, Map_uint64_t_ExtmarkNs};
    use super::stddef_h::size_t;
    use super::hashtab_h::hashtab_T;
    use super::stdint_intn_h::int16_t;
    use super::regexp_defs_h::{regprog_T, regmmatch_T};
    use super::syntax_defs_h::synstate_T;
    use super::grid_defs_h::ScreenGrid;
    use super::defs_h::Window;
    use super::profile_h::proftime_T;
    extern "C" {
        #[c2rust::src_loc = "377:16"]
        pub type qf_info_S;
    }
    // NVIM_BUFFER_DEFS_H
    // / Macros defined in Vim, but not in Neovim
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/map.h:47"]
pub mod map_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:1"]
    pub struct Map_uint64_t_ExtmarkNs {
        pub table: *mut kh_uint64_t_ExtmarkNs_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "51:1"]
    pub struct kh_uint64_t_ExtmarkNs_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ExtmarkNs,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:16"]
    pub struct ExtmarkNs {
        pub map: *mut Map_uint64_t_uint64_t,
        pub free_id: uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:1"]
    pub struct Map_uint64_t_uint64_t {
        pub table: *mut kh_uint64_t_uint64_t_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:1"]
    pub struct kh_uint64_t_uint64_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "52:1"]
    pub struct Map_uint64_t_ExtmarkItem {
        pub table: *mut kh_uint64_t_ExtmarkItem_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "52:1"]
    pub struct kh_uint64_t_ExtmarkItem_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ExtmarkItem,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:1"]
    pub struct Map_uint64_t_ptr_t {
        pub table: *mut kh_uint64_t_ptr_t_map_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:1"]
    pub struct kh_uint64_t_ptr_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut uint64_t,
        pub vals: *mut ptr_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:1"]
    pub struct kh_cstr_t_ptr_t_map_t {
        pub n_buckets: khint_t,
        pub size: khint_t,
        pub n_occupied: khint_t,
        pub upper_bound: khint_t,
        pub flags: *mut khint32_t,
        pub keys: *mut cstr_t,
        pub vals: *mut ptr_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:1"]
    pub struct Map_cstr_t_ptr_t {
        pub table: *mut kh_cstr_t_ptr_t_map_t,
    }
    use super::khash_h::{khint_t, khint32_t};
    use super::stdint_uintn_h::uint64_t;
    use super::extmark_defs_h::ExtmarkItem;
    use super::map_defs_h::{ptr_t, cstr_t};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "40:21"]
        pub fn map_uint64_t_ptr_t_get(map: *mut Map_uint64_t_ptr_t,
                                      key: uint64_t) -> ptr_t;
    }
    // NVIM_MAP_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/khash.h:47"]
pub mod khash_h {
    /* The MIT License

   Copyright (c) 2008, 2009, 2011 by Attractive Chaos <attractor@live.co.uk>

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   "Software"), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.
*/
    /*
  Example:

#include "nvim/khash.h"
KHASH_MAP_INIT_INT(32, char)
int main() {
    int ret, is_missing;
    khiter_t k;
    khash_t(32) *h = kh_init(32);
    k = kh_put(32, h, 5, &ret);
    kh_value(h, k) = 10;
    k = kh_get(32, h, 10);
    is_missing = (k == kh_end(h));
    k = kh_get(32, h, 5);
    kh_del(32, h, k);
    for (k = kh_begin(h); k != kh_end(h); ++k)
        if (kh_exist(h, k)) kh_value(h, k) = 1;
    kh_destroy(32, h);
    return 0;
}
*/
    /*
  2013-05-02 (0.2.8):

	* Use quadratic probing. When the capacity is power of 2, stepping function
	  i*(i+1)/2 guarantees to traverse each bucket. It is better than double
	  hashing on cache performance and is more robust than linear probing.

	  In theory, double hashing should be more robust than quadratic probing.
	  However, my implementation is probably not for large hash tables, because
	  the second hash function is closely tied to the first hash function,
	  which reduce the effectiveness of double hashing.

	Reference: http://research.cs.vt.edu/AVresearch/hashing/quadratic.php

  2011-12-29 (0.2.7):

    * Minor code clean up; no actual effect.

  2011-09-16 (0.2.6):

	* The capacity is a power of 2. This seems to dramatically improve the
	  speed for simple keys. Thank Zilong Tan for the suggestion. Reference:

	   - http://code.google.com/p/ulib/
	   - http://nothings.org/computer/judy/

	* Allow to optionally use linear probing which usually has better
	  performance for random input. Double hashing is still the default as it
	  is more robust to certain non-random input.

	* Added Wang's integer hash function (not used by default). This hash
	  function is more robust to certain non-random input.

  2011-02-14 (0.2.5):

    * Allow to declare global functions.

  2009-09-26 (0.2.4):

    * Improve portability

  2008-09-19 (0.2.3):

	* Corrected the example
	* Improved interfaces

  2008-09-11 (0.2.2):

	* Improved speed a little in kh_put()

  2008-09-10 (0.2.1):

	* Added kh_clear()
	* Fixed a compiling error

  2008-09-02 (0.2.0):

	* Changed to token concatenation which increases flexibility.

  2008-08-31 (0.1.2):

	* Fixed a bug in kh_get(), which has not been tested previously.

  2008-08-31 (0.1.1):

	* Added destructor
*/
    /* !
  @header

  Generic hash table library.
 */
    /* compiler specific configuration */
    #[c2rust::src_loc = "140:1"]
    pub type khint32_t = libc::c_uint;
    #[c2rust::src_loc = "157:1"]
    pub type khint_t = khint32_t;
    /* This function uses 0.25*n_buckets bytes of working space instead of */
    /* [sizeof(key_t+val_t)+.25]*n_buckets. */
    /* requested size is too small */
    /* hash table size to be changed (shrink or expand); rehash */
    /* expand */
    /* otherwise shrink */
    /* rehashing is needed */
    /* kick-out process; sort of like in Cuckoo hashing */
    /* kick out the existing element */
    /* mark it as deleted in the old hash table */
    /* write the element and jump out of the loop */
    /* shrink the hash table */
    /* free the working space */
    /* update the hash table */
    /* clear "deleted" elements */
    /* expand the hash table */
    /* TODO: implement automatically shrinking; */
    /* resize() already support shrinking */
    /* for speed up */
    /* not present at all */
    /* deleted */
    /* Don't touch h->keys[x] if present and not deleted */
    /* --- BEGIN OF HASH FUNCTIONS --- */
    /* ! @function
  @abstract     Integer hash function
  @param  key   The integer [khint32_t]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     Integer comparison function
 */
    /* ! @function
  @abstract     64-bit integer hash function
  @param  key   The integer [khint64_t]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     64-bit integer comparison function
 */
    /* ! @function
  @abstract     const char* hash function
  @param  s     Pointer to a null terminated string
  @return       The hash value
 */
    #[inline]
    #[c2rust::src_loc = "459:1"]
    pub unsafe extern "C" fn __ac_X31_hash_string(mut s: *const libc::c_char)
     -> khint_t {
        let mut h = *s as khint_t;
        if h != 0 {
            s = s.offset(1);
            while *s != 0 {
                h =
                    (h <<
                         5 as
                             libc::c_int).wrapping_sub(h).wrapping_add(*s as
                                                                           uint8_t
                                                                           as
                                                                           libc::c_uint);
                s = s.offset(1)
            }
        }
        return h;
    }
    /* ! @function
  @abstract     Another interface to const char* hash function
  @param  key   Pointer to a null terminated string [const char*]
  @return       The hash value [khint_t]
 */
    /* ! @function
  @abstract     Const char* comparison function
 */
    #[inline]
    #[c2rust::src_loc = "476:1"]
    pub unsafe extern "C" fn __ac_Wang_hash(mut key: khint_t) -> khint_t {
        key =
            (key as libc::c_uint).wrapping_add(!(key << 15 as libc::c_int)) as
                khint_t as khint_t;
        key ^= key >> 10 as libc::c_int;
        key =
            (key as libc::c_uint).wrapping_add(key << 3 as libc::c_int) as
                khint_t as khint_t;
        key ^= key >> 6 as libc::c_int;
        key =
            (key as libc::c_uint).wrapping_add(!(key << 11 as libc::c_int)) as
                khint_t as khint_t;
        key ^= key >> 16 as libc::c_int;
        return key;
    }
    use super::stdint_uintn_h::uint8_t;
    // NVIM_LIB_KHASH_H
    /* ! @function
  @abstract     Return a literal for an empty hash table.
  @param  name  Name of the hash table [symbol]
 */
    /* ! @function
  @abstract     Instantiate a hash map containing const char* keys
  @param  name  Name of the hash table [symbol]
  @param  khval_t  Type of values [type]
 */
    /* ! @function
  @abstract     Instantiate a hash map containing const char* keys
  @param  name  Name of the hash table [symbol]
 */
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/extmark_defs.h:47"]
pub mod extmark_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:9"]
    pub struct ExtmarkItem {
        pub ns_id: uint64_t,
        pub mark_id: uint64_t,
        pub hl_id: libc::c_int,
        pub virt_text: VirtText,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:9"]
    pub struct VirtText {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut VirtTextChunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "7:9"]
    pub struct VirtTextChunk {
        pub text: *mut libc::c_char,
        pub hl_id: libc::c_int,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:9"]
    pub struct extmark_undo_vec_t {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut ExtmarkUndoObject,
    }
    #[c2rust::src_loc = "25:1"]
    pub type ExtmarkUndoObject = undo_object;
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    extern "C" {
        #[c2rust::src_loc = "25:16"]
        pub type undo_object;
    }
    // NVIM_EXTMARK_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/marktree.h:47"]
pub mod marktree_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "59:9"]
    pub struct MarkTree {
        pub root: *mut mtnode_t,
        pub n_keys: size_t,
        pub n_nodes: size_t,
        pub next_id: uint64_t,
        pub id2node: *mut Map_uint64_t_ptr_t,
    }
    #[c2rust::src_loc = "23:1"]
    pub type mtnode_t = mtnode_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "47:8"]
    pub struct mtnode_s {
        pub n: int32_t,
        pub level: int32_t,
        pub parent: *mut mtnode_t,
        pub key: [mtkey_t; 19],
        pub ptr: [*mut mtnode_t; 0],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:9"]
    pub struct mtkey_t {
        pub pos: mtpos_t,
        pub id: uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:9"]
    pub struct mtpos_t {
        pub row: int32_t,
        pub col: int32_t,
    }
    use super::stddef_h::size_t;
    use super::stdint_uintn_h::uint64_t;
    use super::map_h::Map_uint64_t_ptr_t;
    use super::stdint_intn_h::int32_t;
    // NVIM_MARKTREE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/map_defs.h:47"]
pub mod map_defs_h {
    #[c2rust::src_loc = "7:1"]
    pub type ptr_t = *mut libc::c_void;
    #[c2rust::src_loc = "6:1"]
    pub type cstr_t = *const libc::c_char;
    // NVIM_MAP_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/terminal.h:47"]
pub mod terminal_h {
    #[c2rust::src_loc = "8:1"]
    pub type Terminal = terminal;
    extern "C" {
        #[c2rust::src_loc = "8:16"]
        pub type terminal;
    }
    // NVIM_TERMINAL_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/sign_defs.h:47"]
pub mod sign_defs_h {
    // signs: line annotations
    // Sign group
    // number of signs in this group
    // next sign id for this group
    // sign group name
    // Macros to get the sign group structure from the group name
    #[c2rust::src_loc = "21:1"]
    pub type signlist_T = signlist;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "23:8"]
    pub struct signlist {
        pub id: libc::c_int,
        pub lnum: linenr_T,
        pub typenr: libc::c_int,
        pub group: *mut signgroup_T,
        pub priority: libc::c_int,
        pub next: *mut signlist_T,
        pub prev: *mut signlist_T,
    }
    #[c2rust::src_loc = "10:1"]
    pub type signgroup_T = signgroup_S;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "10:16"]
    pub struct signgroup_S {
        pub refcount: uint16_t,
        pub next_sign_id: libc::c_int,
        pub sg_name: [char_u; 1],
    }
    use super::pos_h::linenr_T;
    use super::stdint_uintn_h::uint16_t;
    use super::nvim_types_h::char_u;
    // NVIM_SIGN_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/regexp_defs.h:47"]
pub mod regexp_defs_h {
    /*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by Henry
 * Spencer.  This code has been modified specifically for use with Vim, and
 * should not be used apart from compiling Vim.  If you want a good regular
 * expression library, get the original code.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 */
    /*
 * The number of sub-matches is limited to 10.
 * The first one (index 0) is the whole match, referenced with "\0".
 * The second one (index 1) is the first sub-match, referenced with "\1".
 * This goes up to the tenth (index 9), referenced with "\9".
 */
    /*
 * In the NFA engine: how many braces are allowed.
 * TODO(RE): Use dynamic memory allocation instead of static, like here
 */
    // In the NFA engine: how many states are allowed.
    // Which regexp engine to use? Needed for vim_regcomp().
// Must match with 'regexpengine'.
    #[c2rust::src_loc = "46:1"]
    pub type regprog_T = regprog;
    // / Structure to be used for multi-line matching.
// / Sub-match "no" starts in line "startpos[no].lnum" column "startpos[no].col"
// / and ends in line "endpos[no].lnum" just before column "endpos[no].col".
// / The line numbers are relative to the first line, thus startpos[0].lnum is
// / always 0.
// / When there is no match, the line number is -1.
    // / when not zero: maximum column
    /*
 * Structure returned by vim_regcomp() to pass on to vim_regexec().
 * This is the general structure. For the actual matcher, two specific
 * structures are used. See code below.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "70:8"]
    pub struct regprog {
        pub engine: *mut regengine_T,
        pub regflags: libc::c_uint,
        pub re_engine: libc::c_uint,
        pub re_flags: libc::c_uint,
    }
    #[c2rust::src_loc = "45:1"]
    pub type regengine_T = regengine;
    // /< Second argument for vim_regcomp().
    /*
 * Structure used by the back track matcher.
 * These fields are only to be used in regexp.c!
 * See regexp.c for an explanation.
 */
    // These four members implement regprog_T.
    // /< Second argument for vim_regcomp().
    /* actually longer.. */
    // Structure representing a NFA state.
// An NFA state may have no outgoing edge, when it is a NFA_MATCH state.
    /* 0: normal, 1: recursive */
    /*
 * Structure used by the NFA matcher.
 */
    // These four members implement regprog_T.
    // /< Second argument for vim_regcomp().
    /* points into state[] */
    /* pattern starts with ^ */
    /* char at start of pattern */
    /* plain text to match with */
    /* pattern contains \ze */
    /* pattern contains \1 .. \9 */
    /* number of () */
    /* actually longer.. */
    /*
 * Structure to be used for single-line matching.
 * Sub-match "no" starts at "startp[no]" and ends just before "endp[no]".
 * When there is no match, the pointer is NULL.
 */
    /*
 * Structure used to store external references: "\z\(\)" to "\z\1".
 * Use a reference count to avoid the need to copy this around.  When it goes
 * from 1 to zero the matches need to be freed.
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "156:8"]
    pub struct regengine {
        pub regcomp: Option<unsafe extern "C" fn(_: *mut char_u,
                                                 _: libc::c_int)
                                -> *mut regprog_T>,
        pub regfree: Option<unsafe extern "C" fn(_: *mut regprog_T) -> ()>,
        pub regexec_nl: Option<unsafe extern "C" fn(_: *mut regmatch_T,
                                                    _: *mut char_u,
                                                    _: colnr_T, _: bool)
                                   -> libc::c_int>,
        pub regexec_multi: Option<unsafe extern "C" fn(_: *mut regmmatch_T,
                                                       _: *mut win_T,
                                                       _: *mut buf_T,
                                                       _: linenr_T,
                                                       _: colnr_T,
                                                       _: *mut proftime_T,
                                                       _: *mut libc::c_int)
                                      -> libc::c_long>,
        pub expr: *mut char_u,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "55:9"]
    pub struct regmmatch_T {
        pub regprog: *mut regprog_T,
        pub startpos: [lpos_T; 10],
        pub endpos: [lpos_T; 10],
        pub rmm_ic: libc::c_int,
        pub rmm_maxcol: colnr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "139:9"]
    pub struct regmatch_T {
        pub regprog: *mut regprog_T,
        pub startp: [*mut char_u; 10],
        pub endp: [*mut char_u; 10],
        pub rm_ic: bool,
    }
    #[c2rust::src_loc = "47:1"]
    pub type reg_extmatch_T = reg_extmatch;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "151:8"]
    pub struct reg_extmatch {
        pub refcnt: int16_t,
        pub matches: [*mut char_u; 10],
    }
    use super::nvim_types_h::char_u;
    use super::pos_h::{colnr_T, linenr_T, lpos_T};
    use super::buffer_defs_h::{win_T, buf_T};
    use super::profile_h::proftime_T;
    use super::stdint_intn_h::int16_t;
    // NVIM_REGEXP_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/api/private/defs.h:47"]
pub mod defs_h {
    // Basic types
    // Per msgpack-rpc spec.
    // / Mask for all internal calls
    // / Internal call from VimL code
    // / Internal call from lua code
    // / Check whether call is internal
// /
// / @param[in]  channel_id  Channel id.
// /
// / @return true if channel_id refers to internal channel.
    // / Maximum value of an Integer
    // / Minimum value of an Integer
    #[c2rust::src_loc = "82:1"]
    pub type Window = handle_T;
    #[c2rust::src_loc = "66:1"]
    pub type Boolean = bool;
    #[c2rust::src_loc = "67:1"]
    pub type Integer = int64_t;
    #[c2rust::src_loc = "68:1"]
    pub type Float = libc::c_double;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "76:9"]
    pub struct String_0 {
        pub data: *mut libc::c_char,
        pub size: size_t,
    }
    // EXT types, cannot be split or reordered, see #EXT_OBJECT_TYPE_SHIFT
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "114:8"]
    pub struct object {
        pub type_0: ObjectType,
        pub data: C2RustUnnamed_14,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "116:3"]
    pub union C2RustUnnamed_14 {
        pub boolean: Boolean,
        pub integer: Integer,
        pub floating: Float,
        pub string: String_0,
        pub array: Array,
        pub dictionary: Dictionary,
        pub luaref: LuaRef,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:9"]
    pub struct Dictionary {
        pub items: *mut KeyValuePair,
        pub size: size_t,
        pub capacity: size_t,
    }
    #[c2rust::src_loc = "92:1"]
    pub type KeyValuePair = key_value_pair;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "127:8"]
    pub struct key_value_pair {
        pub key: String_0,
        pub value: Object,
    }
    #[c2rust::src_loc = "85:1"]
    pub type Object = object;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "87:9"]
    pub struct Array {
        pub items: *mut Object,
        pub size: size_t,
        pub capacity: size_t,
    }
    #[c2rust::src_loc = "99:9"]
    pub type ObjectType = libc::c_uint;
    #[c2rust::src_loc = "111:3"]
    pub const kObjectTypeTabpage: ObjectType = 10;
    #[c2rust::src_loc = "110:3"]
    pub const kObjectTypeWindow: ObjectType = 9;
    #[c2rust::src_loc = "109:3"]
    pub const kObjectTypeBuffer: ObjectType = 8;
    #[c2rust::src_loc = "107:3"]
    pub const kObjectTypeLuaRef: ObjectType = 7;
    #[c2rust::src_loc = "106:3"]
    pub const kObjectTypeDictionary: ObjectType = 6;
    #[c2rust::src_loc = "105:3"]
    pub const kObjectTypeArray: ObjectType = 5;
    #[c2rust::src_loc = "104:3"]
    pub const kObjectTypeString: ObjectType = 4;
    #[c2rust::src_loc = "103:3"]
    pub const kObjectTypeFloat: ObjectType = 3;
    #[c2rust::src_loc = "102:3"]
    pub const kObjectTypeInteger: ObjectType = 2;
    #[c2rust::src_loc = "101:3"]
    pub const kObjectTypeBoolean: ObjectType = 1;
    #[c2rust::src_loc = "100:3"]
    pub const kObjectTypeNil: ObjectType = 0;
    #[inline(always)]
    #[c2rust::src_loc = "56:1"]
    pub unsafe extern "C" fn is_internal_call(channel_id: uint64_t) -> bool {
        return channel_id &
                   (1 as libc::c_int as uint64_t) <<
                       (::std::mem::size_of::<uint64_t>() as
                            libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                            libc::c_ulong).wrapping_sub(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_ulong)
                   != 0;
    }
    use super::nvim_types_h::{handle_T, LuaRef};
    use super::stdint_intn_h::int64_t;
    use super::stddef_h::size_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_API_PRIVATE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mark_defs.h:47"]
pub mod mark_defs_h {
    /*
 * marks: positions in a file
 * (a normal mark is a lnum/col pair, the same as a file position)
 */
    // / Number of possible numbered global marks
    // / Maximum possible number of letter marks
    // / Total possible number of global marks
    // / Total possible number of local marks
// /
// / That are uppercase marks plus '"', '^' and '.'. There are other local marks,
// / but they are not saved in ShaDa files.
    // / Maximum number of marks in jump list
    // / Maximum number of tags in tag stack
    // / Structure defining single local mark
    #[c2rust::src_loc = "35:1"]
    pub type fmark_T = filemark;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:16"]
    pub struct filemark {
        pub mark: pos_T,
        pub fnum: libc::c_int,
        pub timestamp: Timestamp,
        pub additional_data: *mut dict_T,
    }
    // /< Cursor position.
    // /< File number.
    // /< Time when this mark was last set.
    // /< Additional data from ShaDa file.
    // / Structure defining extended mark (mark with file name attached)
    #[c2rust::src_loc = "43:1"]
    pub type xfmark_T = xfilemark;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "43:16"]
    pub struct xfilemark {
        pub fmark: fmark_T,
        pub fname: *mut char_u,
    }
    #[c2rust::src_loc = "17:9"]
    pub const NMARKS: libc::c_int =
        'z' as i32 - 'a' as i32 + 1 as libc::c_int;
    use super::pos_h::pos_T;
    use super::time_h::Timestamp;
    use super::typval_h::dict_T;
    use super::nvim_types_h::char_u;
    // /< Actual mark.
    // /< File name, used when fnum == 0.
    // NVIM_MARK_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/time.h:47"]
pub mod time_h {
    #[c2rust::src_loc = "8:1"]
    pub type Timestamp = uint64_t;
    use super::stdint_uintn_h::uint64_t;
    // NVIM_OS_TIME_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/option_defs.h:47"]
pub mod option_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "862:9"]
    pub struct LastSet {
        pub script_ctx: sctx_T,
        pub channel_id: uint64_t,
    }
    #[c2rust::src_loc = "156:1"]
    pub type C2RustUnnamed_13 = libc::c_uint;
    #[c2rust::src_loc = "177:3"]
    pub const SHM_SEARCHCOUNT: C2RustUnnamed_13 = 83;
    #[c2rust::src_loc = "176:3"]
    pub const SHM_FILEINFO: C2RustUnnamed_13 = 70;
    #[c2rust::src_loc = "175:3"]
    pub const SHM_RECORDING: C2RustUnnamed_13 = 113;
    #[c2rust::src_loc = "174:3"]
    pub const SHM_COMPLETIONMENU: C2RustUnnamed_13 = 99;
    #[c2rust::src_loc = "173:3"]
    pub const SHM_INTRO: C2RustUnnamed_13 = 73;
    #[c2rust::src_loc = "172:3"]
    pub const SHM_ATTENTION: C2RustUnnamed_13 = 65;
    #[c2rust::src_loc = "171:3"]
    pub const SHM_SEARCH: C2RustUnnamed_13 = 115;
    #[c2rust::src_loc = "170:3"]
    pub const SHM_OVERALL: C2RustUnnamed_13 = 79;
    #[c2rust::src_loc = "169:3"]
    pub const SHM_OVER: C2RustUnnamed_13 = 111;
    #[c2rust::src_loc = "168:3"]
    pub const SHM_TRUNCALL: C2RustUnnamed_13 = 84;
    #[c2rust::src_loc = "167:3"]
    pub const SHM_TRUNC: C2RustUnnamed_13 = 116;
    #[c2rust::src_loc = "166:3"]
    pub const SHM_WRITE: C2RustUnnamed_13 = 87;
    #[c2rust::src_loc = "165:3"]
    pub const SHM_ABBREVIATIONS: C2RustUnnamed_13 = 97;
    #[c2rust::src_loc = "164:3"]
    pub const SHM_WRI: C2RustUnnamed_13 = 119;
    #[c2rust::src_loc = "163:3"]
    pub const SHM_NEW: C2RustUnnamed_13 = 110;
    #[c2rust::src_loc = "162:3"]
    pub const SHM_LINES: C2RustUnnamed_13 = 108;
    #[c2rust::src_loc = "161:3"]
    pub const SHM_TEXT: C2RustUnnamed_13 = 120;
    #[c2rust::src_loc = "160:3"]
    pub const SHM_LAST: C2RustUnnamed_13 = 105;
    #[c2rust::src_loc = "159:3"]
    pub const SHM_FILE: C2RustUnnamed_13 = 102;
    #[c2rust::src_loc = "158:3"]
    pub const SHM_MOD: C2RustUnnamed_13 = 109;
    #[c2rust::src_loc = "157:3"]
    pub const SHM_RO: C2RustUnnamed_13 = 114;
    #[c2rust::src_loc = "60:9"]
    pub const EOL_DOS: libc::c_int = 1 as libc::c_int;
    use super::typval_h::sctx_T;
    use super::stdint_uintn_h::uint64_t;
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "394:18"]
        pub static mut p_dir: *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "601:18"]
        pub static mut p_shm: *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "662:13"]
        pub static mut p_uc: libc::c_long;
        #[no_mangle]
        #[c2rust::src_loc = "680:13"]
        pub static mut p_verbose: libc::c_long;
    }
    // NVIM_OPTION_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/syntax_defs.h:47"]
pub mod syntax_defs_h {
    /* minimal size for state stack array */
    /* maximal size for state stack array */
    /* size of sst_stack[]. */
    /* normal distance between entries */
    /* invalid syn_state pointer */
    #[c2rust::src_loc = "12:1"]
    pub type synstate_T = syn_state;
    /* struct passed to in_id_list() */
    // ":syn include" unique tag
    // highlight group ID of item
    // cont.in group IDs, if non-zero
    /*
 * Each keyword has one keyentry, which is linked in a hash list.
 */
    // next entry with identical "keyword[]"
    // struct passed to in_id_list()
    // ID list for next match (if non-zero)
    // conceal substitute character
    // actually longer
    /*
 * Struct used to store one state of the state stack.
 */
    /* index of pattern */
    /* flags for pattern */
    /* stores si_seqnr */
    /* stores si_cchar */
    /* external matches from start pattern */
    /*
 * syn_state contains the syntax state stack for the start of one line.
 * Used by b_sst_array[].
 */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "53:8"]
    pub struct syn_state {
        pub sst_next: *mut synstate_T,
        pub sst_lnum: linenr_T,
        pub sst_union: C2RustUnnamed_7,
        pub sst_next_flags: libc::c_int,
        pub sst_stacksize: libc::c_int,
        pub sst_next_list: *mut int16_t,
        pub sst_tick: disptick_T,
        pub sst_change_lnum: linenr_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:3"]
    pub union C2RustUnnamed_7 {
        pub sst_stack: [bufstate_T; 7],
        pub sst_ga: garray_T,
    }
    #[c2rust::src_loc = "41:1"]
    pub type bufstate_T = buf_state;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:16"]
    pub struct buf_state {
        pub bs_idx: libc::c_int,
        pub bs_flags: libc::c_int,
        pub bs_seqnr: libc::c_int,
        pub bs_cchar: libc::c_int,
        pub bs_extmatch: *mut reg_extmatch_T,
    }
    use super::pos_h::linenr_T;
    use super::stdint_intn_h::int16_t;
    use super::buffer_defs_h::disptick_T;
    use super::garray_h::garray_T;
    use super::regexp_defs_h::reg_extmatch_T;
    // NVIM_SYNTAX_DEFS_H
    // when non-zero, change in this line
                                // may have made the state invalid
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/undo_defs.h:47"]
pub mod undo_defs_h {
    // for time_t
    #[c2rust::src_loc = "10:1"]
    pub type u_header_T = u_header;
    /* Structure to store info about the Visual area. */
    /* start pos of last VIsual */
    /* end position of last VIsual */
    /* VIsual_mode of last VIsual */
    /* MAXCOL from w_curswant */
    /* pointer to next entry in list */
    /* number of line above undo block */
    /* number of line below undo block */
    /* linecount when u_save called */
    /* array of lines in undo block */
    /* number of lines in ue_array */
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:8"]
    pub struct u_header {
        pub uh_next: C2RustUnnamed_11,
        pub uh_prev: C2RustUnnamed_10,
        pub uh_alt_next: C2RustUnnamed_9,
        pub uh_alt_prev: C2RustUnnamed_8,
        pub uh_seq: libc::c_long,
        pub uh_walk: libc::c_int,
        pub uh_entry: *mut u_entry_T,
        pub uh_getbot_entry: *mut u_entry_T,
        pub uh_cursor: pos_T,
        pub uh_cursor_vcol: libc::c_long,
        pub uh_flags: libc::c_int,
        pub uh_namedm: [fmark_T; 26],
        pub uh_extmark: extmark_undo_vec_t,
        pub uh_visual: visualinfo_T,
        pub uh_time: time_t,
        pub uh_save_nr: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "13:9"]
    pub struct visualinfo_T {
        pub vi_start: pos_T,
        pub vi_end: pos_T,
        pub vi_mode: libc::c_int,
        pub vi_curswant: colnr_T,
    }
    #[c2rust::src_loc = "22:1"]
    pub type u_entry_T = u_entry;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "23:8"]
    pub struct u_entry {
        pub ue_next: *mut u_entry_T,
        pub ue_top: linenr_T,
        pub ue_bot: linenr_T,
        pub ue_lcount: linenr_T,
        pub ue_array: *mut *mut char_u,
        pub ue_size: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "50:3"]
    pub union C2RustUnnamed_8 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:3"]
    pub union C2RustUnnamed_9 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "42:3"]
    pub union C2RustUnnamed_10 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "38:3"]
    pub union C2RustUnnamed_11 {
        pub ptr: *mut u_header_T,
        pub seq: libc::c_long,
    }
    use super::pos_h::{pos_T, colnr_T, linenr_T};
    use super::mark_defs_h::fmark_T;
    use super::extmark_defs_h::extmark_undo_vec_t;
    use super::time_t_h::time_t;
    use super::nvim_types_h::char_u;
    // NVIM_UNDO_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/fs_defs.h:47"]
pub mod fs_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "12:9"]
    pub struct FileID {
        pub inode: uint64_t,
        pub device_id: uint64_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "7:9"]
    pub struct FileInfo {
        pub stat: uv_stat_t,
    }
    use super::stdint_uintn_h::uint64_t;
    use super::uv_h::uv_stat_t;
    // NVIM_OS_FS_DEFS_H
    // non-writable thing (e.g., block device)
    // something we can write to (character
                           // device, fifo, socket, ..)
    // file or directory, check with os_isdir()
    // Values returned by os_nodetype()
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/memline_defs.h:47"]
pub mod memline_defs_h {
    // /
// / When searching for a specific line, we remember what blocks in the tree
// / are the branches leading to that block. This is stored in ml_stack.  Each
// / entry is a pointer to info in a block (may be data block or pointer block)
// /
    // block number
    // lowest lnum in this block
    // highest lnum in this block
    // index for block with current lnum
    // block/index pair
    // Flags when calling ml_updatechunk()
    // / memline structure: the contents of a buffer.
// / Essentially a tree with a branch factor of 128.
// / Lines are stored at leaf nodes.
// / Nodes are stored on ml_mfp (memfile_T):
// /   pointer_block: internal nodes
// /   data_block: leaf nodes
// /
// / Memline also has "chunks" of 800 lines that are separate from the 128-tree
// / structure, primarily used to speed up line2byte() and byte2line().
// /
// / Motivation: If you have a file that is 10000 lines long, and you insert
// /             a line at linenr 1000, you don't want to move 9000 lines in
// /             memory.  With this structure it is roughly (N * 128) pointer
// /             moves, where N is the height (typically 1-3).
// /
    #[c2rust::src_loc = "43:1"]
    pub type memline_T = memline;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "43:16"]
    pub struct memline {
        pub ml_line_count: linenr_T,
        pub ml_mfp: *mut memfile_T,
        pub ml_flags: libc::c_int,
        pub ml_stack: *mut infoptr_T,
        pub ml_stack_top: libc::c_int,
        pub ml_stack_size: libc::c_int,
        pub ml_line_lnum: linenr_T,
        pub ml_line_ptr: *mut char_u,
        pub ml_locked: *mut bhdr_T,
        pub ml_locked_low: linenr_T,
        pub ml_locked_high: linenr_T,
        pub ml_locked_lineadd: libc::c_int,
        pub ml_chunksize: *mut chunksize_T,
        pub ml_numchunks: libc::c_int,
        pub ml_usedchunks: libc::c_int,
    }
    #[c2rust::src_loc = "18:1"]
    pub type chunksize_T = ml_chunksize;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "18:16"]
    pub struct ml_chunksize {
        pub mlcs_numlines: libc::c_int,
        pub mlcs_totalsize: libc::c_long,
    }
    #[c2rust::src_loc = "11:1"]
    pub type infoptr_T = info_pointer;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:16"]
    pub struct info_pointer {
        pub ip_bnum: blocknr_T,
        pub ip_low: linenr_T,
        pub ip_high: linenr_T,
        pub ip_index: libc::c_int,
    }
    #[c2rust::src_loc = "26:9"]
    pub const ML_CHNK_UPDLINE: libc::c_int = 3 as libc::c_int;
    #[c2rust::src_loc = "24:9"]
    pub const ML_CHNK_ADDLINE: libc::c_int = 1 as libc::c_int;
    #[c2rust::src_loc = "50:9"]
    pub const ML_LOCKED_DIRTY: libc::c_int = 4 as libc::c_int;
    #[c2rust::src_loc = "51:9"]
    pub const ML_LOCKED_POS: libc::c_int = 8 as libc::c_int;
    #[c2rust::src_loc = "25:9"]
    pub const ML_CHNK_DELLINE: libc::c_int = 2 as libc::c_int;
    #[c2rust::src_loc = "49:9"]
    pub const ML_LINE_DIRTY: libc::c_int = 2 as libc::c_int;
    #[c2rust::src_loc = "48:9"]
    pub const ML_EMPTY: libc::c_int = 1 as libc::c_int;
    use super::pos_h::linenr_T;
    use super::memfile_defs_h::{memfile_T, bhdr_T, blocknr_T};
    use super::nvim_types_h::char_u;
    // number of lines in the buffer
    // pointer to associated memfile
    // empty buffer
    // cached line was changed and allocated
    // ml_locked was changed
    // ml_locked needs positive block number
    // stack of pointer blocks (array of IPTRs)
    // current top of ml_stack
    // total number of entries in ml_stack
    // line number of cached line, 0 if not valid
    // pointer to cached line
    // block used by last ml_get
    // first line in ml_locked
    // last line in ml_locked
    // number of lines inserted in ml_locked
    // NVIM_MEMLINE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/memfile_defs.h:47"]
pub mod memfile_defs_h {
    // / A block number.
// /
// / Blocks numbered from 0 upwards have been assigned a place in the actual
// / file. The block number is equal to the page number in the file. The blocks
// / with negative numbers are currently in memory only.
    // / A hash item.
// /
// / Items' keys are block numbers.
// / Items in the same bucket are organized into a doubly-linked list.
// /
// / Therefore, items can be arbitrary data structures beginning with pointers
// / for the list and and a block number key.
    // / Initial size for a hashtable.
    // / A chained hashtable with block numbers as keys and arbitrary data structures
// / as items.
// /
// / This is an intrusive data structure: we require that items begin with
// / mf_hashitem_T which contains the key and linked list pointers. List of items
// / in each bucket is doubly-linked.
    // / mask used to mod hash value to array index
                                // / (nr of items in array is 'mht_mask + 1')
    // / number of items inserted
    // / points to the array of buckets (can be
                                // / mht_small_buckets or a newly allocated array
                                // / when mht_small_buckets becomes too small)
    // / initial buckets
    // / A block header.
// /
// / There is a block header for each previously used block in the memfile.
// /
// / The block may be linked in the used list OR in the free list.
// / The used blocks are also kept in hash lists.
// /
// / The used list is a doubly linked list, most recently used block first.
// / The blocks in the used list have a block of memory allocated.
// / The hash lists are used to quickly find a block in the used list.
// / The free list is a single linked list, not sorted.
// / The blocks in the free list have no block of memory allocated and
// / the contents of the block in the file (if any) is irrelevant.
    #[c2rust::src_loc = "63:1"]
    pub type bhdr_T = bhdr;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "63:16"]
    pub struct bhdr {
        pub bh_hashitem: mf_hashitem_T,
        pub bh_next: *mut bhdr,
        pub bh_prev: *mut bhdr,
        pub bh_data: *mut libc::c_void,
        pub bh_page_count: libc::c_uint,
        pub bh_flags: libc::c_uint,
    }
    #[c2rust::src_loc = "25:1"]
    pub type mf_hashitem_T = mf_hashitem;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "25:16"]
    pub struct mf_hashitem {
        pub mhi_next: *mut mf_hashitem,
        pub mhi_prev: *mut mf_hashitem,
        pub mhi_key: blocknr_T,
    }
    #[c2rust::src_loc = "16:1"]
    pub type blocknr_T = int64_t;
    // / header for hash table and key
    // / block number, part of bh_hashitem
    // / next block header in free or used list
    // / previous block header in used list
    // / pointer to memory (for used block)
    // / number of pages in this block
    // BH_DIRTY or BH_LOCKED
    // / A block number translation list item.
// /
// / When a block with a negative number is flushed to the file, it gets
// / a positive number. Because the reference to the block is still the negative
// / number, we remember the translation to the new positive number in the
// / double linked trans lists. The structure is the same as the hash lists.
    // / header for hash table and key
    // / old, negative, number
    // / new, positive, number
    // / A memory file.
    #[c2rust::src_loc = "90:1"]
    pub type memfile_T = memfile;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "90:16"]
    pub struct memfile {
        pub mf_fname: *mut char_u,
        pub mf_ffname: *mut char_u,
        pub mf_fd: libc::c_int,
        pub mf_free_first: *mut bhdr_T,
        pub mf_used_first: *mut bhdr_T,
        pub mf_used_last: *mut bhdr_T,
        pub mf_hash: mf_hashtab_T,
        pub mf_trans: mf_hashtab_T,
        pub mf_blocknr_max: blocknr_T,
        pub mf_blocknr_min: blocknr_T,
        pub mf_neg_count: blocknr_T,
        pub mf_infile_count: blocknr_T,
        pub mf_page_size: libc::c_uint,
        pub mf_dirty: bool,
    }
    #[c2rust::src_loc = "40:1"]
    pub type mf_hashtab_T = mf_hashtab;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:16"]
    pub struct mf_hashtab {
        pub mht_mask: size_t,
        pub mht_count: size_t,
        pub mht_buckets: *mut *mut mf_hashitem_T,
        pub mht_small_buckets: [*mut mf_hashitem_T; 64],
    }
    #[c2rust::src_loc = "72:9"]
    pub const BH_DIRTY: libc::c_uint = 1 as libc::c_uint;
    use super::stdint_intn_h::int64_t;
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    // / name of the file
    // / idem, full path
    // / file descriptor
    // / first block header in free list
    // / mru block header in used list
    // / lru block header in used list
    // / hash lists
    // / trans lists
    // / highest positive block number + 1
    // / lowest negative block number - 1
    // / number of negative blocks numbers
    // / number of pages in the file
    // / number of bytes in a page
    // / TRUE if there are dirty blocks
    // NVIM_MEMFILE_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/highlight_defs.h:47"]
pub mod highlight_defs_h {
    // / Values for index in highlight_attr[].
// / When making changes, also update hlf_names below!
    #[c2rust::src_loc = "48:9"]
    pub type C2RustUnnamed_12 = libc::c_uint;
    // MUST be the last one
    // Message area
    #[c2rust::src_loc = "101:5"]
    pub const HLF_COUNT: C2RustUnnamed_12 = 50;
    // Floating window
    #[c2rust::src_loc = "100:5"]
    pub const HLF_MSG: C2RustUnnamed_12 = 49;
    // message separator line
    #[c2rust::src_loc = "99:5"]
    pub const HLF_NFLOAT: C2RustUnnamed_12 = 48;
    // NormalNC: Normal text in non-current windows
    #[c2rust::src_loc = "98:5"]
    pub const HLF_MSGSEP: C2RustUnnamed_12 = 47;
    // Whitespace
    #[c2rust::src_loc = "97:5"]
    pub const HLF_INACTIVE: C2RustUnnamed_12 = 46;
    // selected quickfix line
    #[c2rust::src_loc = "96:5"]
    pub const HLF_0: C2RustUnnamed_12 = 45;
    // 'colorcolumn'
    #[c2rust::src_loc = "95:5"]
    pub const HLF_QFL: C2RustUnnamed_12 = 44;
    // 'cursorline'
    #[c2rust::src_loc = "94:5"]
    pub const HLF_MC: C2RustUnnamed_12 = 43;
    // 'cursorcolumn'
    #[c2rust::src_loc = "93:5"]
    pub const HLF_CUL: C2RustUnnamed_12 = 42;
    // tabpage line filler
    #[c2rust::src_loc = "92:5"]
    pub const HLF_CUC: C2RustUnnamed_12 = 41;
    // tabpage line selected
    #[c2rust::src_loc = "91:5"]
    pub const HLF_TPF: C2RustUnnamed_12 = 40;
    // tabpage line
    #[c2rust::src_loc = "90:5"]
    pub const HLF_TPS: C2RustUnnamed_12 = 39;
    // popup menu scrollbar thumb
    #[c2rust::src_loc = "89:5"]
    pub const HLF_TP: C2RustUnnamed_12 = 38;
    // popup menu scrollbar
    #[c2rust::src_loc = "88:5"]
    pub const HLF_PST: C2RustUnnamed_12 = 37;
    // popup menu selected item
    #[c2rust::src_loc = "87:5"]
    pub const HLF_PSB: C2RustUnnamed_12 = 36;
    // popup menu normal item
    #[c2rust::src_loc = "86:5"]
    pub const HLF_PSI: C2RustUnnamed_12 = 35;
    // SpellLocal
    #[c2rust::src_loc = "85:5"]
    pub const HLF_PNI: C2RustUnnamed_12 = 34;
    // SpellRare
    #[c2rust::src_loc = "84:5"]
    pub const HLF_SPL: C2RustUnnamed_12 = 33;
    // SpellCap
    #[c2rust::src_loc = "83:5"]
    pub const HLF_SPR: C2RustUnnamed_12 = 32;
    // SpellBad
    #[c2rust::src_loc = "82:5"]
    pub const HLF_SPC: C2RustUnnamed_12 = 31;
    // Concealed text
    #[c2rust::src_loc = "81:5"]
    pub const HLF_SPB: C2RustUnnamed_12 = 30;
    // Sign column
    #[c2rust::src_loc = "80:5"]
    pub const HLF_CONCEAL: C2RustUnnamed_12 = 29;
    // Text Changed in diff line
    #[c2rust::src_loc = "79:5"]
    pub const HLF_SC: C2RustUnnamed_12 = 28;
    // Deleted diff line
    #[c2rust::src_loc = "78:5"]
    pub const HLF_TXD: C2RustUnnamed_12 = 27;
    // Changed diff line
    #[c2rust::src_loc = "77:5"]
    pub const HLF_DED: C2RustUnnamed_12 = 26;
    // Added diff line
    #[c2rust::src_loc = "76:5"]
    pub const HLF_CHD: C2RustUnnamed_12 = 25;
    // Fold column
    #[c2rust::src_loc = "75:5"]
    pub const HLF_ADD: C2RustUnnamed_12 = 24;
    // Folded line
    #[c2rust::src_loc = "74:5"]
    pub const HLF_FC: C2RustUnnamed_12 = 23;
    // Wildmenu highlight
    #[c2rust::src_loc = "73:5"]
    pub const HLF_FL: C2RustUnnamed_12 = 22;
    // warning messages
    #[c2rust::src_loc = "72:5"]
    pub const HLF_WM: C2RustUnnamed_12 = 21;
    // Visual mode, autoselecting and not clipboard owner
    #[c2rust::src_loc = "71:5"]
    pub const HLF_W: C2RustUnnamed_12 = 20;
    // Visual mode
    #[c2rust::src_loc = "70:5"]
    pub const HLF_VNC: C2RustUnnamed_12 = 19;
    // Titles for output from ":set all", ":autocmd" etc.
    #[c2rust::src_loc = "69:5"]
    pub const HLF_V: C2RustUnnamed_12 = 18;
    // column to separate vertically split windows
    #[c2rust::src_loc = "68:5"]
    pub const HLF_T: C2RustUnnamed_12 = 17;
    // status lines of not-current windows
    #[c2rust::src_loc = "67:5"]
    pub const HLF_C: C2RustUnnamed_12 = 16;
    // status lines
    #[c2rust::src_loc = "66:5"]
    pub const HLF_SNC: C2RustUnnamed_12 = 15;
    // return to continue message and yes/no questions
    #[c2rust::src_loc = "65:5"]
    pub const HLF_S: C2RustUnnamed_12 = 14;
    // current line number
    #[c2rust::src_loc = "64:5"]
    pub const HLF_R: C2RustUnnamed_12 = 13;
    // line number for ":number" and ":#" commands
    #[c2rust::src_loc = "63:5"]
    pub const HLF_CLN: C2RustUnnamed_12 = 12;
    // Mode (e.g., "-- INSERT --")
    #[c2rust::src_loc = "62:5"]
    pub const HLF_N: C2RustUnnamed_12 = 11;
    // "--More--" message
    #[c2rust::src_loc = "61:5"]
    pub const HLF_CM: C2RustUnnamed_12 = 10;
    // last search string
    #[c2rust::src_loc = "60:5"]
    pub const HLF_M: C2RustUnnamed_12 = 9;
    // incremental search
    #[c2rust::src_loc = "59:5"]
    pub const HLF_L: C2RustUnnamed_12 = 8;
    // error messages
    #[c2rust::src_loc = "58:5"]
    pub const HLF_I: C2RustUnnamed_12 = 7;
    // directories in CTRL-D listing
    #[c2rust::src_loc = "57:5"]
    pub const HLF_E: C2RustUnnamed_12 = 6;
    // @ characters at end of screen, characters that
                    // don't really exist in the text
    #[c2rust::src_loc = "56:5"]
    pub const HLF_D: C2RustUnnamed_12 = 5;
    // terminal cursor unfocused
    #[c2rust::src_loc = "54:5"]
    pub const HLF_AT: C2RustUnnamed_12 = 4;
    // terminal cursor focused
    #[c2rust::src_loc = "53:5"]
    pub const HLF_TERMNC: C2RustUnnamed_12 = 3;
    // after the last line in the buffer
    #[c2rust::src_loc = "52:5"]
    pub const HLF_TERM: C2RustUnnamed_12 = 2;
    // Meta & special keys listed with ":map", text that is
                    // displayed different from what it is
    #[c2rust::src_loc = "51:5"]
    pub const HLF_EOB: C2RustUnnamed_12 = 1;
    #[c2rust::src_loc = "49:3"]
    pub const HLF_8: C2RustUnnamed_12 = 0;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "158:12"]
        pub static mut highlight_attr: [libc::c_int; 50];
    }
    // NVIM_HIGHLIGHT_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/.deps/usr/include/uv.h:47"]
pub mod uv_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1693:8"]
    pub struct uv_loop_s {
        pub data: *mut libc::c_void,
        pub active_handles: libc::c_uint,
        pub handle_queue: [*mut libc::c_void; 2],
        pub active_reqs: C2RustUnnamed_20,
        pub stop_flag: libc::c_uint,
        pub flags: libc::c_ulong,
        pub backend_fd: libc::c_int,
        pub pending_queue: [*mut libc::c_void; 2],
        pub watcher_queue: [*mut libc::c_void; 2],
        pub watchers: *mut *mut uv__io_t,
        pub nwatchers: libc::c_uint,
        pub nfds: libc::c_uint,
        pub wq: [*mut libc::c_void; 2],
        pub wq_mutex: uv_mutex_t,
        pub wq_async: uv_async_t,
        pub cloexec_lock: uv_rwlock_t,
        pub closing_handles: *mut uv_handle_t,
        pub process_handles: [*mut libc::c_void; 2],
        pub prepare_handles: [*mut libc::c_void; 2],
        pub check_handles: [*mut libc::c_void; 2],
        pub idle_handles: [*mut libc::c_void; 2],
        pub async_handles: [*mut libc::c_void; 2],
        pub async_unused: Option<unsafe extern "C" fn() -> ()>,
        pub async_io_watcher: uv__io_t,
        pub async_wfd: libc::c_int,
        pub timer_heap: C2RustUnnamed_18,
        pub timer_counter: uint64_t,
        pub time: uint64_t,
        pub signal_pipefd: [libc::c_int; 2],
        pub signal_io_watcher: uv__io_t,
        pub child_watcher: uv_signal_t,
        pub emfile_fd: libc::c_int,
        pub inotify_read_watcher: uv__io_t,
        pub inotify_watchers: *mut libc::c_void,
        pub inotify_fd: libc::c_int,
    }
    #[c2rust::src_loc = "225:1"]
    pub type uv_signal_t = uv_signal_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1508:8"]
    pub struct uv_signal_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_17,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub signal_cb: uv_signal_cb,
        pub signum: libc::c_int,
        pub tree_entry: C2RustUnnamed_15,
        pub caught_signals: libc::c_uint,
        pub dispatched_signals: libc::c_uint,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1512:3"]
    pub struct C2RustUnnamed_15 {
        pub rbe_left: *mut uv_signal_s,
        pub rbe_right: *mut uv_signal_s,
        pub rbe_parent: *mut uv_signal_s,
        pub rbe_color: libc::c_int,
    }
    #[c2rust::src_loc = "370:1"]
    pub type uv_signal_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_signal_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "209:1"]
    pub type uv_handle_t = uv_handle_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "435:8"]
    pub struct uv_handle_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_16,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "436:3"]
    pub union C2RustUnnamed_16 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "314:1"]
    pub type uv_close_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_handle_t) -> ()>;
    #[c2rust::src_loc = "188:9"]
    pub type uv_handle_type = libc::c_uint;
    #[c2rust::src_loc = "194:3"]
    pub const UV_HANDLE_TYPE_MAX: uv_handle_type = 18;
    #[c2rust::src_loc = "193:3"]
    pub const UV_FILE: uv_handle_type = 17;
    #[c2rust::src_loc = "191:22"]
    pub const UV_SIGNAL: uv_handle_type = 16;
    #[c2rust::src_loc = "191:22"]
    pub const UV_UDP: uv_handle_type = 15;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TTY: uv_handle_type = 14;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TIMER: uv_handle_type = 13;
    #[c2rust::src_loc = "191:22"]
    pub const UV_TCP: uv_handle_type = 12;
    #[c2rust::src_loc = "191:22"]
    pub const UV_STREAM: uv_handle_type = 11;
    #[c2rust::src_loc = "191:22"]
    pub const UV_PROCESS: uv_handle_type = 10;
    #[c2rust::src_loc = "191:22"]
    pub const UV_PREPARE: uv_handle_type = 9;
    #[c2rust::src_loc = "191:22"]
    pub const UV_POLL: uv_handle_type = 8;
    #[c2rust::src_loc = "191:22"]
    pub const UV_NAMED_PIPE: uv_handle_type = 7;
    #[c2rust::src_loc = "191:22"]
    pub const UV_IDLE: uv_handle_type = 6;
    #[c2rust::src_loc = "191:22"]
    pub const UV_HANDLE: uv_handle_type = 5;
    #[c2rust::src_loc = "191:22"]
    pub const UV_FS_POLL: uv_handle_type = 4;
    #[c2rust::src_loc = "191:22"]
    pub const UV_FS_EVENT: uv_handle_type = 3;
    #[c2rust::src_loc = "191:22"]
    pub const UV_CHECK: uv_handle_type = 2;
    #[c2rust::src_loc = "191:22"]
    pub const UV_ASYNC: uv_handle_type = 1;
    #[c2rust::src_loc = "189:3"]
    pub const UV_UNKNOWN_HANDLE: uv_handle_type = 0;
    #[c2rust::src_loc = "208:1"]
    pub type uv_loop_t = uv_loop_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1509:3"]
    pub union C2RustUnnamed_17 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1705:3"]
    pub struct C2RustUnnamed_18 {
        pub min: *mut libc::c_void,
        pub nelts: libc::c_uint,
    }
    #[c2rust::src_loc = "221:1"]
    pub type uv_async_t = uv_async_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "803:8"]
    pub struct uv_async_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_19,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub async_cb: uv_async_cb,
        pub queue: [*mut libc::c_void; 2],
        pub pending: libc::c_int,
    }
    #[c2rust::src_loc = "317:1"]
    pub type uv_async_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_async_t) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "804:3"]
    pub union C2RustUnnamed_19 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1699:3"]
    pub union C2RustUnnamed_20 {
        pub unused: [*mut libc::c_void; 2],
        pub count: libc::c_uint,
    }
    #[c2rust::src_loc = "197:9"]
    pub type uv_req_type = libc::c_uint;
    #[c2rust::src_loc = "203:3"]
    pub const UV_REQ_TYPE_MAX: uv_req_type = 10;
    #[c2rust::src_loc = "200:19"]
    pub const UV_GETNAMEINFO: uv_req_type = 9;
    #[c2rust::src_loc = "200:19"]
    pub const UV_GETADDRINFO: uv_req_type = 8;
    #[c2rust::src_loc = "200:19"]
    pub const UV_WORK: uv_req_type = 7;
    #[c2rust::src_loc = "200:19"]
    pub const UV_FS: uv_req_type = 6;
    #[c2rust::src_loc = "200:19"]
    pub const UV_UDP_SEND: uv_req_type = 5;
    #[c2rust::src_loc = "200:19"]
    pub const UV_SHUTDOWN: uv_req_type = 4;
    #[c2rust::src_loc = "200:19"]
    pub const UV_WRITE: uv_req_type = 3;
    #[c2rust::src_loc = "200:19"]
    pub const UV_CONNECT: uv_req_type = 2;
    #[c2rust::src_loc = "200:19"]
    pub const UV_REQ: uv_req_type = 1;
    #[c2rust::src_loc = "198:3"]
    pub const UV_UNKNOWN_REQ: uv_req_type = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "485:8"]
    pub struct uv_stream_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_21,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
    }
    #[c2rust::src_loc = "313:1"]
    pub type uv_connection_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_stream_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "211:1"]
    pub type uv_stream_t = uv_stream_s;
    #[c2rust::src_loc = "231:1"]
    pub type uv_shutdown_t = uv_shutdown_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "411:8"]
    pub struct uv_shutdown_s {
        pub data: *mut libc::c_void,
        pub type_0: uv_req_type,
        pub reserved: [*mut libc::c_void; 6],
        pub handle: *mut uv_stream_t,
        pub cb: uv_shutdown_cb,
    }
    #[c2rust::src_loc = "312:1"]
    pub type uv_shutdown_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_shutdown_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "233:1"]
    pub type uv_connect_t = uv_connect_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "574:8"]
    pub struct uv_connect_s {
        pub data: *mut libc::c_void,
        pub type_0: uv_req_type,
        pub reserved: [*mut libc::c_void; 6],
        pub cb: uv_connect_cb,
        pub handle: *mut uv_stream_t,
        pub queue: [*mut libc::c_void; 2],
    }
    #[c2rust::src_loc = "311:1"]
    pub type uv_connect_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_connect_t, _: libc::c_int)
                   -> ()>;
    #[c2rust::src_loc = "307:1"]
    pub type uv_read_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_stream_t, _: ssize_t,
                                    _: *const uv_buf_t) -> ()>;
    #[c2rust::src_loc = "304:1"]
    pub type uv_alloc_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_handle_t, _: size_t,
                                    _: *mut uv_buf_t) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "486:3"]
    pub union C2RustUnnamed_21 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "538:8"]
    pub struct uv_tcp_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_22,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "539:3"]
    pub union C2RustUnnamed_22 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "212:1"]
    pub type uv_tcp_t = uv_tcp_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "726:8"]
    pub struct uv_pipe_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_23,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub write_queue_size: size_t,
        pub alloc_cb: uv_alloc_cb,
        pub read_cb: uv_read_cb,
        pub connect_req: *mut uv_connect_t,
        pub shutdown_req: *mut uv_shutdown_t,
        pub io_watcher: uv__io_t,
        pub write_queue: [*mut libc::c_void; 2],
        pub write_completed_queue: [*mut libc::c_void; 2],
        pub connection_cb: uv_connection_cb,
        pub delayed_error: libc::c_int,
        pub accepted_fd: libc::c_int,
        pub queued_fds: *mut libc::c_void,
        pub ipc: libc::c_int,
        pub pipe_fname: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "727:3"]
    pub union C2RustUnnamed_23 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[c2rust::src_loc = "214:1"]
    pub type uv_pipe_t = uv_pipe_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "819:8"]
    pub struct uv_timer_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_24,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub timer_cb: uv_timer_cb,
        pub heap_node: [*mut libc::c_void; 3],
        pub timeout: uint64_t,
        pub repeat: uint64_t,
        pub start_id: uint64_t,
    }
    #[c2rust::src_loc = "316:1"]
    pub type uv_timer_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_timer_t) -> ()>;
    #[c2rust::src_loc = "217:1"]
    pub type uv_timer_t = uv_timer_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "820:3"]
    pub union C2RustUnnamed_24 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "793:8"]
    pub struct uv_idle_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_25,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub idle_cb: uv_idle_cb,
        pub queue: [*mut libc::c_void; 2],
    }
    #[c2rust::src_loc = "320:1"]
    pub type uv_idle_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_idle_t) -> ()>;
    #[c2rust::src_loc = "220:1"]
    pub type uv_idle_t = uv_idle_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "794:3"]
    pub union C2RustUnnamed_25 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1006:8"]
    pub struct uv_process_s {
        pub data: *mut libc::c_void,
        pub loop_0: *mut uv_loop_t,
        pub type_0: uv_handle_type,
        pub close_cb: uv_close_cb,
        pub handle_queue: [*mut libc::c_void; 2],
        pub u: C2RustUnnamed_26,
        pub next_closing: *mut uv_handle_t,
        pub flags: libc::c_uint,
        pub exit_cb: uv_exit_cb,
        pub pid: libc::c_int,
        pub queue: [*mut libc::c_void; 2],
        pub status: libc::c_int,
    }
    #[c2rust::src_loc = "321:1"]
    pub type uv_exit_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_process_t, _: int64_t,
                                    _: libc::c_int) -> ()>;
    #[c2rust::src_loc = "222:1"]
    pub type uv_process_t = uv_process_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "1007:3"]
    pub union C2RustUnnamed_26 {
        pub fd: libc::c_int,
        pub reserved: [*mut libc::c_void; 4],
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "340:9"]
    pub struct uv_stat_t {
        pub st_dev: uint64_t,
        pub st_mode: uint64_t,
        pub st_nlink: uint64_t,
        pub st_uid: uint64_t,
        pub st_gid: uint64_t,
        pub st_rdev: uint64_t,
        pub st_ino: uint64_t,
        pub st_size: uint64_t,
        pub st_blksize: uint64_t,
        pub st_blocks: uint64_t,
        pub st_flags: uint64_t,
        pub st_gen: uint64_t,
        pub st_atim: uv_timespec_t,
        pub st_mtim: uv_timespec_t,
        pub st_ctim: uv_timespec_t,
        pub st_birthtim: uv_timespec_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "334:9"]
    pub struct uv_timespec_t {
        pub tv_sec: libc::c_long,
        pub tv_nsec: libc::c_long,
    }
    #[c2rust::src_loc = "879:9"]
    pub type uv_stdio_flags = libc::c_uint;
    #[c2rust::src_loc = "897:3"]
    pub const UV_OVERLAPPED_PIPE: uv_stdio_flags = 64;
    #[c2rust::src_loc = "891:3"]
    pub const UV_WRITABLE_PIPE: uv_stdio_flags = 32;
    #[c2rust::src_loc = "890:3"]
    pub const UV_READABLE_PIPE: uv_stdio_flags = 16;
    #[c2rust::src_loc = "883:3"]
    pub const UV_INHERIT_STREAM: uv_stdio_flags = 4;
    #[c2rust::src_loc = "882:3"]
    pub const UV_INHERIT_FD: uv_stdio_flags = 2;
    #[c2rust::src_loc = "881:3"]
    pub const UV_CREATE_PIPE: uv_stdio_flags = 1;
    #[c2rust::src_loc = "880:3"]
    pub const UV_IGNORE: uv_stdio_flags = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "900:16"]
    pub struct uv_stdio_container_s {
        pub flags: uv_stdio_flags,
        pub data: C2RustUnnamed_27,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "903:3"]
    pub union C2RustUnnamed_27 {
        pub stream: *mut uv_stream_t,
        pub fd: libc::c_int,
    }
    #[c2rust::src_loc = "900:1"]
    pub type uv_stdio_container_t = uv_stdio_container_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "909:16"]
    pub struct uv_process_options_s {
        pub exit_cb: uv_exit_cb,
        pub file: *const libc::c_char,
        pub args: *mut *mut libc::c_char,
        pub env: *mut *mut libc::c_char,
        pub cwd: *const libc::c_char,
        pub flags: libc::c_uint,
        pub stdio_count: libc::c_int,
        pub stdio: *mut uv_stdio_container_t,
        pub uid: uv_uid_t,
        pub gid: uv_gid_t,
    }
    #[c2rust::src_loc = "909:1"]
    pub type uv_process_options_t = uv_process_options_s;
    use super::unix_h::{uv__io_t, uv_mutex_t, uv_rwlock_t, uv_buf_t, uv_uid_t,
                        uv_gid_t};
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    use super::stdio_h::ssize_t;
    use super::stdint_intn_h::int64_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "381:1"]
        pub fn uv_strerror(err: libc::c_int) -> *const libc::c_char;
    }
}
#[c2rust::header_src = "/home/vole/neovim/.deps/usr/include/uv/unix.h:47"]
pub mod unix_h {
    #[c2rust::src_loc = "92:1"]
    pub type uv__io_t = uv__io_s;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "94:8"]
    pub struct uv__io_s {
        pub cb: uv__io_cb,
        pub pending_queue: [*mut libc::c_void; 2],
        pub watcher_queue: [*mut libc::c_void; 2],
        pub pevents: libc::c_uint,
        pub events: libc::c_uint,
        pub fd: libc::c_int,
    }
    #[c2rust::src_loc = "89:1"]
    pub type uv__io_cb
        =
        Option<unsafe extern "C" fn(_: *mut uv_loop_s, _: *mut uv__io_s,
                                    _: libc::c_uint) -> ()>;
    #[c2rust::src_loc = "136:1"]
    pub type uv_rwlock_t = pthread_rwlock_t;
    #[c2rust::src_loc = "135:1"]
    pub type uv_mutex_t = pthread_mutex_t;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "121:16"]
    pub struct uv_buf_t {
        pub base: *mut libc::c_char,
        pub len: size_t,
    }
    #[c2rust::src_loc = "126:1"]
    pub type uv_file = libc::c_int;
    #[c2rust::src_loc = "166:1"]
    pub type uv_gid_t = gid_t;
    #[c2rust::src_loc = "167:1"]
    pub type uv_uid_t = uid_t;
    use super::uv_h::uv_loop_s;
    use super::pthreadtypes_h::{pthread_rwlock_t, pthread_mutex_t};
    use super::stddef_h::size_t;
    use super::sys_types_h::{gid_t, uid_t};
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/ex_cmds_enum.generated.h:47"]
pub mod ex_cmds_enum_generated_h {
    #[c2rust::src_loc = "1:9"]
    pub type CMD_index = libc::c_int;
    #[c2rust::src_loc = "544:3"]
    pub const CMD_USER_BUF: CMD_index = -2;
    #[c2rust::src_loc = "543:3"]
    pub const CMD_USER: CMD_index = -1;
    #[c2rust::src_loc = "542:3"]
    pub const CMD_SIZE: CMD_index = 540;
    #[c2rust::src_loc = "541:3"]
    pub const CMD_tilde: CMD_index = 539;
    #[c2rust::src_loc = "540:3"]
    pub const CMD_Next: CMD_index = 538;
    #[c2rust::src_loc = "539:3"]
    pub const CMD_at: CMD_index = 537;
    #[c2rust::src_loc = "538:3"]
    pub const CMD_rshift: CMD_index = 536;
    #[c2rust::src_loc = "537:3"]
    pub const CMD_equal: CMD_index = 535;
    #[c2rust::src_loc = "536:3"]
    pub const CMD_lshift: CMD_index = 534;
    #[c2rust::src_loc = "535:3"]
    pub const CMD_and: CMD_index = 533;
    #[c2rust::src_loc = "534:3"]
    pub const CMD_pound: CMD_index = 532;
    #[c2rust::src_loc = "533:3"]
    pub const CMD_bang: CMD_index = 531;
    #[c2rust::src_loc = "532:3"]
    pub const CMD_z: CMD_index = 530;
    #[c2rust::src_loc = "531:3"]
    pub const CMD_yank: CMD_index = 529;
    #[c2rust::src_loc = "530:3"]
    pub const CMD_xunmenu: CMD_index = 528;
    #[c2rust::src_loc = "529:3"]
    pub const CMD_xunmap: CMD_index = 527;
    #[c2rust::src_loc = "528:3"]
    pub const CMD_xnoremenu: CMD_index = 526;
    #[c2rust::src_loc = "527:3"]
    pub const CMD_xnoremap: CMD_index = 525;
    #[c2rust::src_loc = "526:3"]
    pub const CMD_xmenu: CMD_index = 524;
    #[c2rust::src_loc = "525:3"]
    pub const CMD_xmapclear: CMD_index = 523;
    #[c2rust::src_loc = "524:3"]
    pub const CMD_xmap: CMD_index = 522;
    #[c2rust::src_loc = "523:3"]
    pub const CMD_xall: CMD_index = 521;
    #[c2rust::src_loc = "522:3"]
    pub const CMD_xit: CMD_index = 520;
    #[c2rust::src_loc = "521:3"]
    pub const CMD_wviminfo: CMD_index = 519;
    #[c2rust::src_loc = "520:3"]
    pub const CMD_wundo: CMD_index = 518;
    #[c2rust::src_loc = "519:3"]
    pub const CMD_wshada: CMD_index = 517;
    #[c2rust::src_loc = "518:3"]
    pub const CMD_wqall: CMD_index = 516;
    #[c2rust::src_loc = "517:3"]
    pub const CMD_wq: CMD_index = 515;
    #[c2rust::src_loc = "516:3"]
    pub const CMD_wprevious: CMD_index = 514;
    #[c2rust::src_loc = "515:3"]
    pub const CMD_wnext: CMD_index = 513;
    #[c2rust::src_loc = "514:3"]
    pub const CMD_winpos: CMD_index = 512;
    #[c2rust::src_loc = "513:3"]
    pub const CMD_windo: CMD_index = 511;
    #[c2rust::src_loc = "512:3"]
    pub const CMD_wincmd: CMD_index = 510;
    #[c2rust::src_loc = "511:3"]
    pub const CMD_winsize: CMD_index = 509;
    #[c2rust::src_loc = "510:3"]
    pub const CMD_while: CMD_index = 508;
    #[c2rust::src_loc = "509:3"]
    pub const CMD_wall: CMD_index = 507;
    #[c2rust::src_loc = "508:3"]
    pub const CMD_wNext: CMD_index = 506;
    #[c2rust::src_loc = "507:3"]
    pub const CMD_write: CMD_index = 505;
    #[c2rust::src_loc = "506:3"]
    pub const CMD_vunmenu: CMD_index = 504;
    #[c2rust::src_loc = "505:3"]
    pub const CMD_vunmap: CMD_index = 503;
    #[c2rust::src_loc = "504:3"]
    pub const CMD_vsplit: CMD_index = 502;
    #[c2rust::src_loc = "503:3"]
    pub const CMD_vnoremenu: CMD_index = 501;
    #[c2rust::src_loc = "502:3"]
    pub const CMD_vnew: CMD_index = 500;
    #[c2rust::src_loc = "501:3"]
    pub const CMD_vnoremap: CMD_index = 499;
    #[c2rust::src_loc = "500:3"]
    pub const CMD_vmenu: CMD_index = 498;
    #[c2rust::src_loc = "499:3"]
    pub const CMD_vmapclear: CMD_index = 497;
    #[c2rust::src_loc = "498:3"]
    pub const CMD_vmap: CMD_index = 496;
    #[c2rust::src_loc = "497:3"]
    pub const CMD_viusage: CMD_index = 495;
    #[c2rust::src_loc = "496:3"]
    pub const CMD_vimgrepadd: CMD_index = 494;
    #[c2rust::src_loc = "495:3"]
    pub const CMD_vimgrep: CMD_index = 493;
    #[c2rust::src_loc = "494:3"]
    pub const CMD_view: CMD_index = 492;
    #[c2rust::src_loc = "493:3"]
    pub const CMD_visual: CMD_index = 491;
    #[c2rust::src_loc = "492:3"]
    pub const CMD_vertical: CMD_index = 490;
    #[c2rust::src_loc = "491:3"]
    pub const CMD_verbose: CMD_index = 489;
    #[c2rust::src_loc = "490:3"]
    pub const CMD_version: CMD_index = 488;
    #[c2rust::src_loc = "489:3"]
    pub const CMD_vglobal: CMD_index = 487;
    #[c2rust::src_loc = "488:3"]
    pub const CMD_update: CMD_index = 486;
    #[c2rust::src_loc = "487:3"]
    pub const CMD_unsilent: CMD_index = 485;
    #[c2rust::src_loc = "486:3"]
    pub const CMD_unmenu: CMD_index = 484;
    #[c2rust::src_loc = "485:3"]
    pub const CMD_unmap: CMD_index = 483;
    #[c2rust::src_loc = "484:3"]
    pub const CMD_unlockvar: CMD_index = 482;
    #[c2rust::src_loc = "483:3"]
    pub const CMD_unlet: CMD_index = 481;
    #[c2rust::src_loc = "482:3"]
    pub const CMD_unhide: CMD_index = 480;
    #[c2rust::src_loc = "481:3"]
    pub const CMD_unabbreviate: CMD_index = 479;
    #[c2rust::src_loc = "480:3"]
    pub const CMD_undolist: CMD_index = 478;
    #[c2rust::src_loc = "479:3"]
    pub const CMD_undojoin: CMD_index = 477;
    #[c2rust::src_loc = "478:3"]
    pub const CMD_undo: CMD_index = 476;
    #[c2rust::src_loc = "477:3"]
    pub const CMD_tunmap: CMD_index = 475;
    #[c2rust::src_loc = "476:3"]
    pub const CMD_tunmenu: CMD_index = 474;
    #[c2rust::src_loc = "475:3"]
    pub const CMD_tselect: CMD_index = 473;
    #[c2rust::src_loc = "474:3"]
    pub const CMD_try: CMD_index = 472;
    #[c2rust::src_loc = "473:3"]
    pub const CMD_trewind: CMD_index = 471;
    #[c2rust::src_loc = "472:3"]
    pub const CMD_tprevious: CMD_index = 470;
    #[c2rust::src_loc = "471:3"]
    pub const CMD_topleft: CMD_index = 469;
    #[c2rust::src_loc = "470:3"]
    pub const CMD_tnoremap: CMD_index = 468;
    #[c2rust::src_loc = "469:3"]
    pub const CMD_tnext: CMD_index = 467;
    #[c2rust::src_loc = "468:3"]
    pub const CMD_tmapclear: CMD_index = 466;
    #[c2rust::src_loc = "467:3"]
    pub const CMD_tmap: CMD_index = 465;
    #[c2rust::src_loc = "466:3"]
    pub const CMD_tmenu: CMD_index = 464;
    #[c2rust::src_loc = "465:3"]
    pub const CMD_tlast: CMD_index = 463;
    #[c2rust::src_loc = "464:3"]
    pub const CMD_tjump: CMD_index = 462;
    #[c2rust::src_loc = "463:3"]
    pub const CMD_throw: CMD_index = 461;
    #[c2rust::src_loc = "462:3"]
    pub const CMD_tfirst: CMD_index = 460;
    #[c2rust::src_loc = "461:3"]
    pub const CMD_terminal: CMD_index = 459;
    #[c2rust::src_loc = "460:3"]
    pub const CMD_tclfile: CMD_index = 458;
    #[c2rust::src_loc = "459:3"]
    pub const CMD_tcldo: CMD_index = 457;
    #[c2rust::src_loc = "458:3"]
    pub const CMD_tcl: CMD_index = 456;
    #[c2rust::src_loc = "457:3"]
    pub const CMD_tabs: CMD_index = 455;
    #[c2rust::src_loc = "456:3"]
    pub const CMD_tabrewind: CMD_index = 454;
    #[c2rust::src_loc = "455:3"]
    pub const CMD_tabNext: CMD_index = 453;
    #[c2rust::src_loc = "454:3"]
    pub const CMD_tabprevious: CMD_index = 452;
    #[c2rust::src_loc = "453:3"]
    pub const CMD_tabonly: CMD_index = 451;
    #[c2rust::src_loc = "452:3"]
    pub const CMD_tabnew: CMD_index = 450;
    #[c2rust::src_loc = "451:3"]
    pub const CMD_tabnext: CMD_index = 449;
    #[c2rust::src_loc = "450:3"]
    pub const CMD_tablast: CMD_index = 448;
    #[c2rust::src_loc = "449:3"]
    pub const CMD_tabmove: CMD_index = 447;
    #[c2rust::src_loc = "448:3"]
    pub const CMD_tabfirst: CMD_index = 446;
    #[c2rust::src_loc = "447:3"]
    pub const CMD_tabfind: CMD_index = 445;
    #[c2rust::src_loc = "446:3"]
    pub const CMD_tabedit: CMD_index = 444;
    #[c2rust::src_loc = "445:3"]
    pub const CMD_tabdo: CMD_index = 443;
    #[c2rust::src_loc = "444:3"]
    pub const CMD_tabclose: CMD_index = 442;
    #[c2rust::src_loc = "443:3"]
    pub const CMD_tab: CMD_index = 441;
    #[c2rust::src_loc = "442:3"]
    pub const CMD_tags: CMD_index = 440;
    #[c2rust::src_loc = "441:3"]
    pub const CMD_tag: CMD_index = 439;
    #[c2rust::src_loc = "440:3"]
    pub const CMD_tNext: CMD_index = 438;
    #[c2rust::src_loc = "439:3"]
    pub const CMD_tchdir: CMD_index = 437;
    #[c2rust::src_loc = "438:3"]
    pub const CMD_tcd: CMD_index = 436;
    #[c2rust::src_loc = "437:3"]
    pub const CMD_t: CMD_index = 435;
    #[c2rust::src_loc = "436:3"]
    pub const CMD_syncbind: CMD_index = 434;
    #[c2rust::src_loc = "435:3"]
    pub const CMD_syntime: CMD_index = 433;
    #[c2rust::src_loc = "434:3"]
    pub const CMD_syntax: CMD_index = 432;
    #[c2rust::src_loc = "433:3"]
    pub const CMD_swapname: CMD_index = 431;
    #[c2rust::src_loc = "432:3"]
    pub const CMD_sview: CMD_index = 430;
    #[c2rust::src_loc = "431:3"]
    pub const CMD_suspend: CMD_index = 429;
    #[c2rust::src_loc = "430:3"]
    pub const CMD_sunmenu: CMD_index = 428;
    #[c2rust::src_loc = "429:3"]
    pub const CMD_sunmap: CMD_index = 427;
    #[c2rust::src_loc = "428:3"]
    pub const CMD_sunhide: CMD_index = 426;
    #[c2rust::src_loc = "427:3"]
    pub const CMD_stselect: CMD_index = 425;
    #[c2rust::src_loc = "426:3"]
    pub const CMD_stjump: CMD_index = 424;
    #[c2rust::src_loc = "425:3"]
    pub const CMD_stopinsert: CMD_index = 423;
    #[c2rust::src_loc = "424:3"]
    pub const CMD_startreplace: CMD_index = 422;
    #[c2rust::src_loc = "423:3"]
    pub const CMD_startgreplace: CMD_index = 421;
    #[c2rust::src_loc = "422:3"]
    pub const CMD_startinsert: CMD_index = 420;
    #[c2rust::src_loc = "421:3"]
    pub const CMD_stag: CMD_index = 419;
    #[c2rust::src_loc = "420:3"]
    pub const CMD_stop: CMD_index = 418;
    #[c2rust::src_loc = "419:3"]
    pub const CMD_srewind: CMD_index = 417;
    #[c2rust::src_loc = "418:3"]
    pub const CMD_sprevious: CMD_index = 416;
    #[c2rust::src_loc = "417:3"]
    pub const CMD_spellwrong: CMD_index = 415;
    #[c2rust::src_loc = "416:3"]
    pub const CMD_spellundo: CMD_index = 414;
    #[c2rust::src_loc = "415:3"]
    pub const CMD_spellrepall: CMD_index = 413;
    #[c2rust::src_loc = "414:3"]
    pub const CMD_spellinfo: CMD_index = 412;
    #[c2rust::src_loc = "413:3"]
    pub const CMD_spelldump: CMD_index = 411;
    #[c2rust::src_loc = "412:3"]
    pub const CMD_spellgood: CMD_index = 410;
    #[c2rust::src_loc = "411:3"]
    pub const CMD_split: CMD_index = 409;
    #[c2rust::src_loc = "410:3"]
    pub const CMD_sort: CMD_index = 408;
    #[c2rust::src_loc = "409:3"]
    pub const CMD_source: CMD_index = 407;
    #[c2rust::src_loc = "408:3"]
    pub const CMD_snoremenu: CMD_index = 406;
    #[c2rust::src_loc = "407:3"]
    pub const CMD_snoremap: CMD_index = 405;
    #[c2rust::src_loc = "406:3"]
    pub const CMD_snomagic: CMD_index = 404;
    #[c2rust::src_loc = "405:3"]
    pub const CMD_snext: CMD_index = 403;
    #[c2rust::src_loc = "404:3"]
    pub const CMD_smenu: CMD_index = 402;
    #[c2rust::src_loc = "403:3"]
    pub const CMD_smapclear: CMD_index = 401;
    #[c2rust::src_loc = "402:3"]
    pub const CMD_smap: CMD_index = 400;
    #[c2rust::src_loc = "401:3"]
    pub const CMD_smagic: CMD_index = 399;
    #[c2rust::src_loc = "400:3"]
    pub const CMD_slast: CMD_index = 398;
    #[c2rust::src_loc = "399:3"]
    pub const CMD_sleep: CMD_index = 397;
    #[c2rust::src_loc = "398:3"]
    pub const CMD_silent: CMD_index = 396;
    #[c2rust::src_loc = "397:3"]
    pub const CMD_sign: CMD_index = 395;
    #[c2rust::src_loc = "396:3"]
    pub const CMD_simalt: CMD_index = 394;
    #[c2rust::src_loc = "395:3"]
    pub const CMD_sfirst: CMD_index = 393;
    #[c2rust::src_loc = "394:3"]
    pub const CMD_sfind: CMD_index = 392;
    #[c2rust::src_loc = "393:3"]
    pub const CMD_setlocal: CMD_index = 391;
    #[c2rust::src_loc = "392:3"]
    pub const CMD_setglobal: CMD_index = 390;
    #[c2rust::src_loc = "391:3"]
    pub const CMD_setfiletype: CMD_index = 389;
    #[c2rust::src_loc = "390:3"]
    pub const CMD_set: CMD_index = 388;
    #[c2rust::src_loc = "389:3"]
    pub const CMD_scscope: CMD_index = 387;
    #[c2rust::src_loc = "388:3"]
    pub const CMD_scriptencoding: CMD_index = 386;
    #[c2rust::src_loc = "387:3"]
    pub const CMD_scriptnames: CMD_index = 385;
    #[c2rust::src_loc = "386:3"]
    pub const CMD_sbrewind: CMD_index = 384;
    #[c2rust::src_loc = "385:3"]
    pub const CMD_sbprevious: CMD_index = 383;
    #[c2rust::src_loc = "384:3"]
    pub const CMD_sbnext: CMD_index = 382;
    #[c2rust::src_loc = "383:3"]
    pub const CMD_sbmodified: CMD_index = 381;
    #[c2rust::src_loc = "382:3"]
    pub const CMD_sblast: CMD_index = 380;
    #[c2rust::src_loc = "381:3"]
    pub const CMD_sbfirst: CMD_index = 379;
    #[c2rust::src_loc = "380:3"]
    pub const CMD_sball: CMD_index = 378;
    #[c2rust::src_loc = "379:3"]
    pub const CMD_sbNext: CMD_index = 377;
    #[c2rust::src_loc = "378:3"]
    pub const CMD_sbuffer: CMD_index = 376;
    #[c2rust::src_loc = "377:3"]
    pub const CMD_saveas: CMD_index = 375;
    #[c2rust::src_loc = "376:3"]
    pub const CMD_sandbox: CMD_index = 374;
    #[c2rust::src_loc = "375:3"]
    pub const CMD_sall: CMD_index = 373;
    #[c2rust::src_loc = "374:3"]
    pub const CMD_sargument: CMD_index = 372;
    #[c2rust::src_loc = "373:3"]
    pub const CMD_sNext: CMD_index = 371;
    #[c2rust::src_loc = "372:3"]
    pub const CMD_substitute: CMD_index = 370;
    #[c2rust::src_loc = "371:3"]
    pub const CMD_rviminfo: CMD_index = 369;
    #[c2rust::src_loc = "370:3"]
    pub const CMD_rubyfile: CMD_index = 368;
    #[c2rust::src_loc = "369:3"]
    pub const CMD_rubydo: CMD_index = 367;
    #[c2rust::src_loc = "368:3"]
    pub const CMD_ruby: CMD_index = 366;
    #[c2rust::src_loc = "367:3"]
    pub const CMD_rundo: CMD_index = 365;
    #[c2rust::src_loc = "366:3"]
    pub const CMD_runtime: CMD_index = 364;
    #[c2rust::src_loc = "365:3"]
    pub const CMD_rshada: CMD_index = 363;
    #[c2rust::src_loc = "364:3"]
    pub const CMD_rightbelow: CMD_index = 362;
    #[c2rust::src_loc = "363:3"]
    pub const CMD_right: CMD_index = 361;
    #[c2rust::src_loc = "362:3"]
    pub const CMD_rewind: CMD_index = 360;
    #[c2rust::src_loc = "361:3"]
    pub const CMD_return: CMD_index = 359;
    #[c2rust::src_loc = "360:3"]
    pub const CMD_retab: CMD_index = 358;
    #[c2rust::src_loc = "359:3"]
    pub const CMD_resize: CMD_index = 357;
    #[c2rust::src_loc = "358:3"]
    pub const CMD_registers: CMD_index = 356;
    #[c2rust::src_loc = "357:3"]
    pub const CMD_redrawtabline: CMD_index = 355;
    #[c2rust::src_loc = "356:3"]
    pub const CMD_redrawstatus: CMD_index = 354;
    #[c2rust::src_loc = "355:3"]
    pub const CMD_redraw: CMD_index = 353;
    #[c2rust::src_loc = "354:3"]
    pub const CMD_redir: CMD_index = 352;
    #[c2rust::src_loc = "353:3"]
    pub const CMD_redo: CMD_index = 351;
    #[c2rust::src_loc = "352:3"]
    pub const CMD_recover: CMD_index = 350;
    #[c2rust::src_loc = "351:3"]
    pub const CMD_read: CMD_index = 349;
    #[c2rust::src_loc = "350:3"]
    pub const CMD_qall: CMD_index = 348;
    #[c2rust::src_loc = "349:3"]
    pub const CMD_quitall: CMD_index = 347;
    #[c2rust::src_loc = "348:3"]
    pub const CMD_quit: CMD_index = 346;
    #[c2rust::src_loc = "347:3"]
    pub const CMD_pyxfile: CMD_index = 345;
    #[c2rust::src_loc = "346:3"]
    pub const CMD_pythonx: CMD_index = 344;
    #[c2rust::src_loc = "345:3"]
    pub const CMD_pyxdo: CMD_index = 343;
    #[c2rust::src_loc = "344:3"]
    pub const CMD_pyx: CMD_index = 342;
    #[c2rust::src_loc = "343:3"]
    pub const CMD_py3file: CMD_index = 341;
    #[c2rust::src_loc = "342:3"]
    pub const CMD_python3: CMD_index = 340;
    #[c2rust::src_loc = "341:3"]
    pub const CMD_py3do: CMD_index = 339;
    #[c2rust::src_loc = "340:3"]
    pub const CMD_py3: CMD_index = 338;
    #[c2rust::src_loc = "339:3"]
    pub const CMD_pyfile: CMD_index = 337;
    #[c2rust::src_loc = "338:3"]
    pub const CMD_pydo: CMD_index = 336;
    #[c2rust::src_loc = "337:3"]
    pub const CMD_python: CMD_index = 335;
    #[c2rust::src_loc = "336:3"]
    pub const CMD_pwd: CMD_index = 334;
    #[c2rust::src_loc = "335:3"]
    pub const CMD_put: CMD_index = 333;
    #[c2rust::src_loc = "334:3"]
    pub const CMD_ptselect: CMD_index = 332;
    #[c2rust::src_loc = "333:3"]
    pub const CMD_ptrewind: CMD_index = 331;
    #[c2rust::src_loc = "332:3"]
    pub const CMD_ptprevious: CMD_index = 330;
    #[c2rust::src_loc = "331:3"]
    pub const CMD_ptnext: CMD_index = 329;
    #[c2rust::src_loc = "330:3"]
    pub const CMD_ptlast: CMD_index = 328;
    #[c2rust::src_loc = "329:3"]
    pub const CMD_ptjump: CMD_index = 327;
    #[c2rust::src_loc = "328:3"]
    pub const CMD_ptfirst: CMD_index = 326;
    #[c2rust::src_loc = "327:3"]
    pub const CMD_ptNext: CMD_index = 325;
    #[c2rust::src_loc = "326:3"]
    pub const CMD_ptag: CMD_index = 324;
    #[c2rust::src_loc = "325:3"]
    pub const CMD_psearch: CMD_index = 323;
    #[c2rust::src_loc = "324:3"]
    pub const CMD_profdel: CMD_index = 322;
    #[c2rust::src_loc = "323:3"]
    pub const CMD_profile: CMD_index = 321;
    #[c2rust::src_loc = "322:3"]
    pub const CMD_previous: CMD_index = 320;
    #[c2rust::src_loc = "321:3"]
    pub const CMD_preserve: CMD_index = 319;
    #[c2rust::src_loc = "320:3"]
    pub const CMD_ppop: CMD_index = 318;
    #[c2rust::src_loc = "319:3"]
    pub const CMD_popup: CMD_index = 317;
    #[c2rust::src_loc = "318:3"]
    pub const CMD_pop: CMD_index = 316;
    #[c2rust::src_loc = "317:3"]
    pub const CMD_pedit: CMD_index = 315;
    #[c2rust::src_loc = "316:3"]
    pub const CMD_perldo: CMD_index = 314;
    #[c2rust::src_loc = "315:3"]
    pub const CMD_perl: CMD_index = 313;
    #[c2rust::src_loc = "314:3"]
    pub const CMD_pclose: CMD_index = 312;
    #[c2rust::src_loc = "313:3"]
    pub const CMD_packloadall: CMD_index = 311;
    #[c2rust::src_loc = "312:3"]
    pub const CMD_packadd: CMD_index = 310;
    #[c2rust::src_loc = "311:3"]
    pub const CMD_print: CMD_index = 309;
    #[c2rust::src_loc = "310:3"]
    pub const CMD_ownsyntax: CMD_index = 308;
    #[c2rust::src_loc = "309:3"]
    pub const CMD_ounmenu: CMD_index = 307;
    #[c2rust::src_loc = "308:3"]
    pub const CMD_ounmap: CMD_index = 306;
    #[c2rust::src_loc = "307:3"]
    pub const CMD_options: CMD_index = 305;
    #[c2rust::src_loc = "306:3"]
    pub const CMD_onoremenu: CMD_index = 304;
    #[c2rust::src_loc = "305:3"]
    pub const CMD_onoremap: CMD_index = 303;
    #[c2rust::src_loc = "304:3"]
    pub const CMD_only: CMD_index = 302;
    #[c2rust::src_loc = "303:3"]
    pub const CMD_omenu: CMD_index = 301;
    #[c2rust::src_loc = "302:3"]
    pub const CMD_omapclear: CMD_index = 300;
    #[c2rust::src_loc = "301:3"]
    pub const CMD_omap: CMD_index = 299;
    #[c2rust::src_loc = "300:3"]
    pub const CMD_oldfiles: CMD_index = 298;
    #[c2rust::src_loc = "299:3"]
    pub const CMD_nunmenu: CMD_index = 297;
    #[c2rust::src_loc = "298:3"]
    pub const CMD_nunmap: CMD_index = 296;
    #[c2rust::src_loc = "297:3"]
    pub const CMD_number: CMD_index = 295;
    #[c2rust::src_loc = "296:3"]
    pub const CMD_normal: CMD_index = 294;
    #[c2rust::src_loc = "295:3"]
    pub const CMD_noswapfile: CMD_index = 293;
    #[c2rust::src_loc = "294:3"]
    pub const CMD_noremenu: CMD_index = 292;
    #[c2rust::src_loc = "293:3"]
    pub const CMD_noreabbrev: CMD_index = 291;
    #[c2rust::src_loc = "292:3"]
    pub const CMD_nohlsearch: CMD_index = 290;
    #[c2rust::src_loc = "291:3"]
    pub const CMD_noautocmd: CMD_index = 289;
    #[c2rust::src_loc = "290:3"]
    pub const CMD_noremap: CMD_index = 288;
    #[c2rust::src_loc = "289:3"]
    pub const CMD_nnoremenu: CMD_index = 287;
    #[c2rust::src_loc = "288:3"]
    pub const CMD_nnoremap: CMD_index = 286;
    #[c2rust::src_loc = "287:3"]
    pub const CMD_nmenu: CMD_index = 285;
    #[c2rust::src_loc = "286:3"]
    pub const CMD_nmapclear: CMD_index = 284;
    #[c2rust::src_loc = "285:3"]
    pub const CMD_nmap: CMD_index = 283;
    #[c2rust::src_loc = "284:3"]
    pub const CMD_new: CMD_index = 282;
    #[c2rust::src_loc = "283:3"]
    pub const CMD_next: CMD_index = 281;
    #[c2rust::src_loc = "282:3"]
    pub const CMD_mzfile: CMD_index = 280;
    #[c2rust::src_loc = "281:3"]
    pub const CMD_mzscheme: CMD_index = 279;
    #[c2rust::src_loc = "280:3"]
    pub const CMD_mode: CMD_index = 278;
    #[c2rust::src_loc = "279:3"]
    pub const CMD_mkview: CMD_index = 277;
    #[c2rust::src_loc = "278:3"]
    pub const CMD_mkvimrc: CMD_index = 276;
    #[c2rust::src_loc = "277:3"]
    pub const CMD_mkspell: CMD_index = 275;
    #[c2rust::src_loc = "276:3"]
    pub const CMD_mksession: CMD_index = 274;
    #[c2rust::src_loc = "275:3"]
    pub const CMD_mkexrc: CMD_index = 273;
    #[c2rust::src_loc = "274:3"]
    pub const CMD_messages: CMD_index = 272;
    #[c2rust::src_loc = "273:3"]
    pub const CMD_menutranslate: CMD_index = 271;
    #[c2rust::src_loc = "272:3"]
    pub const CMD_menu: CMD_index = 270;
    #[c2rust::src_loc = "271:3"]
    pub const CMD_match: CMD_index = 269;
    #[c2rust::src_loc = "270:3"]
    pub const CMD_marks: CMD_index = 268;
    #[c2rust::src_loc = "269:3"]
    pub const CMD_mapclear: CMD_index = 267;
    #[c2rust::src_loc = "268:3"]
    pub const CMD_map: CMD_index = 266;
    #[c2rust::src_loc = "267:3"]
    pub const CMD_make: CMD_index = 265;
    #[c2rust::src_loc = "266:3"]
    pub const CMD_mark: CMD_index = 264;
    #[c2rust::src_loc = "265:3"]
    pub const CMD_move: CMD_index = 263;
    #[c2rust::src_loc = "264:3"]
    pub const CMD_ls: CMD_index = 262;
    #[c2rust::src_loc = "263:3"]
    pub const CMD_lwindow: CMD_index = 261;
    #[c2rust::src_loc = "262:3"]
    pub const CMD_lvimgrepadd: CMD_index = 260;
    #[c2rust::src_loc = "261:3"]
    pub const CMD_lvimgrep: CMD_index = 259;
    #[c2rust::src_loc = "260:3"]
    pub const CMD_luafile: CMD_index = 258;
    #[c2rust::src_loc = "259:3"]
    pub const CMD_luado: CMD_index = 257;
    #[c2rust::src_loc = "258:3"]
    pub const CMD_lua: CMD_index = 256;
    #[c2rust::src_loc = "257:3"]
    pub const CMD_lunmap: CMD_index = 255;
    #[c2rust::src_loc = "256:3"]
    pub const CMD_ltag: CMD_index = 254;
    #[c2rust::src_loc = "255:3"]
    pub const CMD_lrewind: CMD_index = 253;
    #[c2rust::src_loc = "254:3"]
    pub const CMD_lpfile: CMD_index = 252;
    #[c2rust::src_loc = "253:3"]
    pub const CMD_lprevious: CMD_index = 251;
    #[c2rust::src_loc = "252:3"]
    pub const CMD_lopen: CMD_index = 250;
    #[c2rust::src_loc = "251:3"]
    pub const CMD_lolder: CMD_index = 249;
    #[c2rust::src_loc = "250:3"]
    pub const CMD_lockvar: CMD_index = 248;
    #[c2rust::src_loc = "249:3"]
    pub const CMD_lockmarks: CMD_index = 247;
    #[c2rust::src_loc = "248:3"]
    pub const CMD_loadkeymap: CMD_index = 246;
    #[c2rust::src_loc = "247:3"]
    pub const CMD_loadview: CMD_index = 245;
    #[c2rust::src_loc = "246:3"]
    pub const CMD_lnfile: CMD_index = 244;
    #[c2rust::src_loc = "245:3"]
    pub const CMD_lnewer: CMD_index = 243;
    #[c2rust::src_loc = "244:3"]
    pub const CMD_lnext: CMD_index = 242;
    #[c2rust::src_loc = "243:3"]
    pub const CMD_lnoremap: CMD_index = 241;
    #[c2rust::src_loc = "242:3"]
    pub const CMD_lmake: CMD_index = 240;
    #[c2rust::src_loc = "241:3"]
    pub const CMD_lmapclear: CMD_index = 239;
    #[c2rust::src_loc = "240:3"]
    pub const CMD_lmap: CMD_index = 238;
    #[c2rust::src_loc = "239:3"]
    pub const CMD_llist: CMD_index = 237;
    #[c2rust::src_loc = "238:3"]
    pub const CMD_llast: CMD_index = 236;
    #[c2rust::src_loc = "237:3"]
    pub const CMD_ll: CMD_index = 235;
    #[c2rust::src_loc = "236:3"]
    pub const CMD_lhistory: CMD_index = 234;
    #[c2rust::src_loc = "235:3"]
    pub const CMD_lhelpgrep: CMD_index = 233;
    #[c2rust::src_loc = "234:3"]
    pub const CMD_lgrepadd: CMD_index = 232;
    #[c2rust::src_loc = "233:3"]
    pub const CMD_lgrep: CMD_index = 231;
    #[c2rust::src_loc = "232:3"]
    pub const CMD_lgetexpr: CMD_index = 230;
    #[c2rust::src_loc = "231:3"]
    pub const CMD_lgetbuffer: CMD_index = 229;
    #[c2rust::src_loc = "230:3"]
    pub const CMD_lgetfile: CMD_index = 228;
    #[c2rust::src_loc = "229:3"]
    pub const CMD_lfirst: CMD_index = 227;
    #[c2rust::src_loc = "228:3"]
    pub const CMD_lfdo: CMD_index = 226;
    #[c2rust::src_loc = "227:3"]
    pub const CMD_lfile: CMD_index = 225;
    #[c2rust::src_loc = "226:3"]
    pub const CMD_lexpr: CMD_index = 224;
    #[c2rust::src_loc = "225:3"]
    pub const CMD_let: CMD_index = 223;
    #[c2rust::src_loc = "224:3"]
    pub const CMD_leftabove: CMD_index = 222;
    #[c2rust::src_loc = "223:3"]
    pub const CMD_left: CMD_index = 221;
    #[c2rust::src_loc = "222:3"]
    pub const CMD_ldo: CMD_index = 220;
    #[c2rust::src_loc = "221:3"]
    pub const CMD_lcscope: CMD_index = 219;
    #[c2rust::src_loc = "220:3"]
    pub const CMD_lclose: CMD_index = 218;
    #[c2rust::src_loc = "219:3"]
    pub const CMD_lchdir: CMD_index = 217;
    #[c2rust::src_loc = "218:3"]
    pub const CMD_lcd: CMD_index = 216;
    #[c2rust::src_loc = "217:3"]
    pub const CMD_lbottom: CMD_index = 215;
    #[c2rust::src_loc = "216:3"]
    pub const CMD_lbelow: CMD_index = 214;
    #[c2rust::src_loc = "215:3"]
    pub const CMD_lbuffer: CMD_index = 213;
    #[c2rust::src_loc = "214:3"]
    pub const CMD_later: CMD_index = 212;
    #[c2rust::src_loc = "213:3"]
    pub const CMD_laddfile: CMD_index = 211;
    #[c2rust::src_loc = "212:3"]
    pub const CMD_laddbuffer: CMD_index = 210;
    #[c2rust::src_loc = "211:3"]
    pub const CMD_laddexpr: CMD_index = 209;
    #[c2rust::src_loc = "210:3"]
    pub const CMD_language: CMD_index = 208;
    #[c2rust::src_loc = "209:3"]
    pub const CMD_labove: CMD_index = 207;
    #[c2rust::src_loc = "208:3"]
    pub const CMD_last: CMD_index = 206;
    #[c2rust::src_loc = "207:3"]
    pub const CMD_lNfile: CMD_index = 205;
    #[c2rust::src_loc = "206:3"]
    pub const CMD_lNext: CMD_index = 204;
    #[c2rust::src_loc = "205:3"]
    pub const CMD_list: CMD_index = 203;
    #[c2rust::src_loc = "204:3"]
    pub const CMD_keepalt: CMD_index = 202;
    #[c2rust::src_loc = "203:3"]
    pub const CMD_keeppatterns: CMD_index = 201;
    #[c2rust::src_loc = "202:3"]
    pub const CMD_keepjumps: CMD_index = 200;
    #[c2rust::src_loc = "201:3"]
    pub const CMD_keepmarks: CMD_index = 199;
    #[c2rust::src_loc = "200:3"]
    pub const CMD_k: CMD_index = 198;
    #[c2rust::src_loc = "199:3"]
    pub const CMD_jumps: CMD_index = 197;
    #[c2rust::src_loc = "198:3"]
    pub const CMD_join: CMD_index = 196;
    #[c2rust::src_loc = "197:3"]
    pub const CMD_iunmenu: CMD_index = 195;
    #[c2rust::src_loc = "196:3"]
    pub const CMD_iunabbrev: CMD_index = 194;
    #[c2rust::src_loc = "195:3"]
    pub const CMD_iunmap: CMD_index = 193;
    #[c2rust::src_loc = "194:3"]
    pub const CMD_isplit: CMD_index = 192;
    #[c2rust::src_loc = "193:3"]
    pub const CMD_isearch: CMD_index = 191;
    #[c2rust::src_loc = "192:3"]
    pub const CMD_intro: CMD_index = 190;
    #[c2rust::src_loc = "191:3"]
    pub const CMD_inoremenu: CMD_index = 189;
    #[c2rust::src_loc = "190:3"]
    pub const CMD_inoreabbrev: CMD_index = 188;
    #[c2rust::src_loc = "189:3"]
    pub const CMD_inoremap: CMD_index = 187;
    #[c2rust::src_loc = "188:3"]
    pub const CMD_imenu: CMD_index = 186;
    #[c2rust::src_loc = "187:3"]
    pub const CMD_imapclear: CMD_index = 185;
    #[c2rust::src_loc = "186:3"]
    pub const CMD_imap: CMD_index = 184;
    #[c2rust::src_loc = "185:3"]
    pub const CMD_ilist: CMD_index = 183;
    #[c2rust::src_loc = "184:3"]
    pub const CMD_ijump: CMD_index = 182;
    #[c2rust::src_loc = "183:3"]
    pub const CMD_if: CMD_index = 181;
    #[c2rust::src_loc = "182:3"]
    pub const CMD_iabclear: CMD_index = 180;
    #[c2rust::src_loc = "181:3"]
    pub const CMD_iabbrev: CMD_index = 179;
    #[c2rust::src_loc = "180:3"]
    pub const CMD_insert: CMD_index = 178;
    #[c2rust::src_loc = "179:3"]
    pub const CMD_history: CMD_index = 177;
    #[c2rust::src_loc = "178:3"]
    pub const CMD_hide: CMD_index = 176;
    #[c2rust::src_loc = "177:3"]
    pub const CMD_highlight: CMD_index = 175;
    #[c2rust::src_loc = "176:3"]
    pub const CMD_hardcopy: CMD_index = 174;
    #[c2rust::src_loc = "175:3"]
    pub const CMD_helptags: CMD_index = 173;
    #[c2rust::src_loc = "174:3"]
    pub const CMD_helpgrep: CMD_index = 172;
    #[c2rust::src_loc = "173:3"]
    pub const CMD_helpclose: CMD_index = 171;
    #[c2rust::src_loc = "172:3"]
    pub const CMD_help: CMD_index = 170;
    #[c2rust::src_loc = "171:3"]
    pub const CMD_gvim: CMD_index = 169;
    #[c2rust::src_loc = "170:3"]
    pub const CMD_gui: CMD_index = 168;
    #[c2rust::src_loc = "169:3"]
    pub const CMD_grepadd: CMD_index = 167;
    #[c2rust::src_loc = "168:3"]
    pub const CMD_grep: CMD_index = 166;
    #[c2rust::src_loc = "167:3"]
    pub const CMD_goto: CMD_index = 165;
    #[c2rust::src_loc = "166:3"]
    pub const CMD_global: CMD_index = 164;
    #[c2rust::src_loc = "165:3"]
    pub const CMD_function: CMD_index = 163;
    #[c2rust::src_loc = "164:3"]
    pub const CMD_for: CMD_index = 162;
    #[c2rust::src_loc = "163:3"]
    pub const CMD_foldopen: CMD_index = 161;
    #[c2rust::src_loc = "162:3"]
    pub const CMD_folddoclosed: CMD_index = 160;
    #[c2rust::src_loc = "161:3"]
    pub const CMD_folddoopen: CMD_index = 159;
    #[c2rust::src_loc = "160:3"]
    pub const CMD_foldclose: CMD_index = 158;
    #[c2rust::src_loc = "159:3"]
    pub const CMD_fold: CMD_index = 157;
    #[c2rust::src_loc = "158:3"]
    pub const CMD_first: CMD_index = 156;
    #[c2rust::src_loc = "157:3"]
    pub const CMD_finish: CMD_index = 155;
    #[c2rust::src_loc = "156:3"]
    pub const CMD_finally: CMD_index = 154;
    #[c2rust::src_loc = "155:3"]
    pub const CMD_find: CMD_index = 153;
    #[c2rust::src_loc = "154:3"]
    pub const CMD_filter: CMD_index = 152;
    #[c2rust::src_loc = "153:3"]
    pub const CMD_filetype: CMD_index = 151;
    #[c2rust::src_loc = "152:3"]
    pub const CMD_files: CMD_index = 150;
    #[c2rust::src_loc = "151:3"]
    pub const CMD_file: CMD_index = 149;
    #[c2rust::src_loc = "150:3"]
    pub const CMD_exusage: CMD_index = 148;
    #[c2rust::src_loc = "149:3"]
    pub const CMD_exit: CMD_index = 147;
    #[c2rust::src_loc = "148:3"]
    pub const CMD_execute: CMD_index = 146;
    #[c2rust::src_loc = "147:3"]
    pub const CMD_ex: CMD_index = 145;
    #[c2rust::src_loc = "146:3"]
    pub const CMD_enew: CMD_index = 144;
    #[c2rust::src_loc = "145:3"]
    pub const CMD_endwhile: CMD_index = 143;
    #[c2rust::src_loc = "144:3"]
    pub const CMD_endtry: CMD_index = 142;
    #[c2rust::src_loc = "143:3"]
    pub const CMD_endfor: CMD_index = 141;
    #[c2rust::src_loc = "142:3"]
    pub const CMD_endfunction: CMD_index = 140;
    #[c2rust::src_loc = "141:3"]
    pub const CMD_endif: CMD_index = 139;
    #[c2rust::src_loc = "140:3"]
    pub const CMD_emenu: CMD_index = 138;
    #[c2rust::src_loc = "139:3"]
    pub const CMD_elseif: CMD_index = 137;
    #[c2rust::src_loc = "138:3"]
    pub const CMD_else: CMD_index = 136;
    #[c2rust::src_loc = "137:3"]
    pub const CMD_echon: CMD_index = 135;
    #[c2rust::src_loc = "136:3"]
    pub const CMD_echomsg: CMD_index = 134;
    #[c2rust::src_loc = "135:3"]
    pub const CMD_echohl: CMD_index = 133;
    #[c2rust::src_loc = "134:3"]
    pub const CMD_echoerr: CMD_index = 132;
    #[c2rust::src_loc = "133:3"]
    pub const CMD_echo: CMD_index = 131;
    #[c2rust::src_loc = "132:3"]
    pub const CMD_earlier: CMD_index = 130;
    #[c2rust::src_loc = "131:3"]
    pub const CMD_edit: CMD_index = 129;
    #[c2rust::src_loc = "130:3"]
    pub const CMD_dsplit: CMD_index = 128;
    #[c2rust::src_loc = "129:3"]
    pub const CMD_dsearch: CMD_index = 127;
    #[c2rust::src_loc = "128:3"]
    pub const CMD_drop: CMD_index = 126;
    #[c2rust::src_loc = "127:3"]
    pub const CMD_doautoall: CMD_index = 125;
    #[c2rust::src_loc = "126:3"]
    pub const CMD_doautocmd: CMD_index = 124;
    #[c2rust::src_loc = "125:3"]
    pub const CMD_dlist: CMD_index = 123;
    #[c2rust::src_loc = "124:3"]
    pub const CMD_djump: CMD_index = 122;
    #[c2rust::src_loc = "123:3"]
    pub const CMD_digraphs: CMD_index = 121;
    #[c2rust::src_loc = "122:3"]
    pub const CMD_diffthis: CMD_index = 120;
    #[c2rust::src_loc = "121:3"]
    pub const CMD_diffsplit: CMD_index = 119;
    #[c2rust::src_loc = "120:3"]
    pub const CMD_diffput: CMD_index = 118;
    #[c2rust::src_loc = "119:3"]
    pub const CMD_diffpatch: CMD_index = 117;
    #[c2rust::src_loc = "118:3"]
    pub const CMD_diffoff: CMD_index = 116;
    #[c2rust::src_loc = "117:3"]
    pub const CMD_diffget: CMD_index = 115;
    #[c2rust::src_loc = "116:3"]
    pub const CMD_diffupdate: CMD_index = 114;
    #[c2rust::src_loc = "115:3"]
    pub const CMD_display: CMD_index = 113;
    #[c2rust::src_loc = "114:3"]
    pub const CMD_delfunction: CMD_index = 112;
    #[c2rust::src_loc = "113:3"]
    pub const CMD_delcommand: CMD_index = 111;
    #[c2rust::src_loc = "112:3"]
    pub const CMD_debuggreedy: CMD_index = 110;
    #[c2rust::src_loc = "111:3"]
    pub const CMD_debug: CMD_index = 109;
    #[c2rust::src_loc = "110:3"]
    pub const CMD_delmarks: CMD_index = 108;
    #[c2rust::src_loc = "109:3"]
    pub const CMD_delete: CMD_index = 107;
    #[c2rust::src_loc = "108:3"]
    pub const CMD_cwindow: CMD_index = 106;
    #[c2rust::src_loc = "107:3"]
    pub const CMD_cunmenu: CMD_index = 105;
    #[c2rust::src_loc = "106:3"]
    pub const CMD_cunabbrev: CMD_index = 104;
    #[c2rust::src_loc = "105:3"]
    pub const CMD_cunmap: CMD_index = 103;
    #[c2rust::src_loc = "104:3"]
    pub const CMD_cstag: CMD_index = 102;
    #[c2rust::src_loc = "103:3"]
    pub const CMD_cscope: CMD_index = 101;
    #[c2rust::src_loc = "102:3"]
    pub const CMD_crewind: CMD_index = 100;
    #[c2rust::src_loc = "101:3"]
    pub const CMD_cquit: CMD_index = 99;
    #[c2rust::src_loc = "100:3"]
    pub const CMD_cpfile: CMD_index = 98;
    #[c2rust::src_loc = "99:3"]
    pub const CMD_cprevious: CMD_index = 97;
    #[c2rust::src_loc = "98:3"]
    pub const CMD_copen: CMD_index = 96;
    #[c2rust::src_loc = "97:3"]
    pub const CMD_const: CMD_index = 95;
    #[c2rust::src_loc = "96:3"]
    pub const CMD_confirm: CMD_index = 94;
    #[c2rust::src_loc = "95:3"]
    pub const CMD_continue: CMD_index = 93;
    #[c2rust::src_loc = "94:3"]
    pub const CMD_compiler: CMD_index = 92;
    #[c2rust::src_loc = "93:3"]
    pub const CMD_comclear: CMD_index = 91;
    #[c2rust::src_loc = "92:3"]
    pub const CMD_command: CMD_index = 90;
    #[c2rust::src_loc = "91:3"]
    pub const CMD_colorscheme: CMD_index = 89;
    #[c2rust::src_loc = "90:3"]
    pub const CMD_colder: CMD_index = 88;
    #[c2rust::src_loc = "89:3"]
    pub const CMD_copy: CMD_index = 87;
    #[c2rust::src_loc = "88:3"]
    pub const CMD_cnoremenu: CMD_index = 86;
    #[c2rust::src_loc = "87:3"]
    pub const CMD_cnoreabbrev: CMD_index = 85;
    #[c2rust::src_loc = "86:3"]
    pub const CMD_cnoremap: CMD_index = 84;
    #[c2rust::src_loc = "85:3"]
    pub const CMD_cnfile: CMD_index = 83;
    #[c2rust::src_loc = "84:3"]
    pub const CMD_cnewer: CMD_index = 82;
    #[c2rust::src_loc = "83:3"]
    pub const CMD_cnext: CMD_index = 81;
    #[c2rust::src_loc = "82:3"]
    pub const CMD_cmenu: CMD_index = 80;
    #[c2rust::src_loc = "81:3"]
    pub const CMD_cmapclear: CMD_index = 79;
    #[c2rust::src_loc = "80:3"]
    pub const CMD_cmap: CMD_index = 78;
    #[c2rust::src_loc = "79:3"]
    pub const CMD_clearjumps: CMD_index = 77;
    #[c2rust::src_loc = "78:3"]
    pub const CMD_close: CMD_index = 76;
    #[c2rust::src_loc = "77:3"]
    pub const CMD_clast: CMD_index = 75;
    #[c2rust::src_loc = "76:3"]
    pub const CMD_clist: CMD_index = 74;
    #[c2rust::src_loc = "75:3"]
    pub const CMD_chistory: CMD_index = 73;
    #[c2rust::src_loc = "74:3"]
    pub const CMD_checktime: CMD_index = 72;
    #[c2rust::src_loc = "73:3"]
    pub const CMD_checkpath: CMD_index = 71;
    #[c2rust::src_loc = "72:3"]
    pub const CMD_checkhealth: CMD_index = 70;
    #[c2rust::src_loc = "71:3"]
    pub const CMD_changes: CMD_index = 69;
    #[c2rust::src_loc = "70:3"]
    pub const CMD_chdir: CMD_index = 68;
    #[c2rust::src_loc = "69:3"]
    pub const CMD_cgetexpr: CMD_index = 67;
    #[c2rust::src_loc = "68:3"]
    pub const CMD_cgetbuffer: CMD_index = 66;
    #[c2rust::src_loc = "67:3"]
    pub const CMD_cgetfile: CMD_index = 65;
    #[c2rust::src_loc = "66:3"]
    pub const CMD_cfirst: CMD_index = 64;
    #[c2rust::src_loc = "65:3"]
    pub const CMD_cfdo: CMD_index = 63;
    #[c2rust::src_loc = "64:3"]
    pub const CMD_cfile: CMD_index = 62;
    #[c2rust::src_loc = "63:3"]
    pub const CMD_cexpr: CMD_index = 61;
    #[c2rust::src_loc = "62:3"]
    pub const CMD_center: CMD_index = 60;
    #[c2rust::src_loc = "61:3"]
    pub const CMD_cdo: CMD_index = 59;
    #[c2rust::src_loc = "60:3"]
    pub const CMD_cd: CMD_index = 58;
    #[c2rust::src_loc = "59:3"]
    pub const CMD_cclose: CMD_index = 57;
    #[c2rust::src_loc = "58:3"]
    pub const CMD_cc: CMD_index = 56;
    #[c2rust::src_loc = "57:3"]
    pub const CMD_cbottom: CMD_index = 55;
    #[c2rust::src_loc = "56:3"]
    pub const CMD_cbelow: CMD_index = 54;
    #[c2rust::src_loc = "55:3"]
    pub const CMD_cbuffer: CMD_index = 53;
    #[c2rust::src_loc = "54:3"]
    pub const CMD_catch: CMD_index = 52;
    #[c2rust::src_loc = "53:3"]
    pub const CMD_call: CMD_index = 51;
    #[c2rust::src_loc = "52:3"]
    pub const CMD_caddfile: CMD_index = 50;
    #[c2rust::src_loc = "51:3"]
    pub const CMD_caddexpr: CMD_index = 49;
    #[c2rust::src_loc = "50:3"]
    pub const CMD_caddbuffer: CMD_index = 48;
    #[c2rust::src_loc = "49:3"]
    pub const CMD_cabove: CMD_index = 47;
    #[c2rust::src_loc = "48:3"]
    pub const CMD_cabclear: CMD_index = 46;
    #[c2rust::src_loc = "47:3"]
    pub const CMD_cabbrev: CMD_index = 45;
    #[c2rust::src_loc = "46:3"]
    pub const CMD_cNfile: CMD_index = 44;
    #[c2rust::src_loc = "45:3"]
    pub const CMD_cNext: CMD_index = 43;
    #[c2rust::src_loc = "44:3"]
    pub const CMD_change: CMD_index = 42;
    #[c2rust::src_loc = "43:3"]
    pub const CMD_bwipeout: CMD_index = 41;
    #[c2rust::src_loc = "42:3"]
    pub const CMD_bunload: CMD_index = 40;
    #[c2rust::src_loc = "41:3"]
    pub const CMD_bufdo: CMD_index = 39;
    #[c2rust::src_loc = "40:3"]
    pub const CMD_buffers: CMD_index = 38;
    #[c2rust::src_loc = "39:3"]
    pub const CMD_browse: CMD_index = 37;
    #[c2rust::src_loc = "38:3"]
    pub const CMD_breaklist: CMD_index = 36;
    #[c2rust::src_loc = "37:3"]
    pub const CMD_breakdel: CMD_index = 35;
    #[c2rust::src_loc = "36:3"]
    pub const CMD_breakadd: CMD_index = 34;
    #[c2rust::src_loc = "35:3"]
    pub const CMD_break: CMD_index = 33;
    #[c2rust::src_loc = "34:3"]
    pub const CMD_brewind: CMD_index = 32;
    #[c2rust::src_loc = "33:3"]
    pub const CMD_bprevious: CMD_index = 31;
    #[c2rust::src_loc = "32:3"]
    pub const CMD_botright: CMD_index = 30;
    #[c2rust::src_loc = "31:3"]
    pub const CMD_bnext: CMD_index = 29;
    #[c2rust::src_loc = "30:3"]
    pub const CMD_bmodified: CMD_index = 28;
    #[c2rust::src_loc = "29:3"]
    pub const CMD_blast: CMD_index = 27;
    #[c2rust::src_loc = "28:3"]
    pub const CMD_bfirst: CMD_index = 26;
    #[c2rust::src_loc = "27:3"]
    pub const CMD_belowright: CMD_index = 25;
    #[c2rust::src_loc = "26:3"]
    pub const CMD_behave: CMD_index = 24;
    #[c2rust::src_loc = "25:3"]
    pub const CMD_bdelete: CMD_index = 23;
    #[c2rust::src_loc = "24:3"]
    pub const CMD_badd: CMD_index = 22;
    #[c2rust::src_loc = "23:3"]
    pub const CMD_ball: CMD_index = 21;
    #[c2rust::src_loc = "22:3"]
    pub const CMD_bNext: CMD_index = 20;
    #[c2rust::src_loc = "21:3"]
    pub const CMD_buffer: CMD_index = 19;
    #[c2rust::src_loc = "20:3"]
    pub const CMD_aunmenu: CMD_index = 18;
    #[c2rust::src_loc = "19:3"]
    pub const CMD_augroup: CMD_index = 17;
    #[c2rust::src_loc = "18:3"]
    pub const CMD_autocmd: CMD_index = 16;
    #[c2rust::src_loc = "17:3"]
    pub const CMD_ascii: CMD_index = 15;
    #[c2rust::src_loc = "16:3"]
    pub const CMD_argument: CMD_index = 14;
    #[c2rust::src_loc = "15:3"]
    pub const CMD_arglocal: CMD_index = 13;
    #[c2rust::src_loc = "14:3"]
    pub const CMD_argglobal: CMD_index = 12;
    #[c2rust::src_loc = "13:3"]
    pub const CMD_argedit: CMD_index = 11;
    #[c2rust::src_loc = "12:3"]
    pub const CMD_argdo: CMD_index = 10;
    #[c2rust::src_loc = "11:3"]
    pub const CMD_argdelete: CMD_index = 9;
    #[c2rust::src_loc = "10:3"]
    pub const CMD_argadd: CMD_index = 8;
    #[c2rust::src_loc = "9:3"]
    pub const CMD_args: CMD_index = 7;
    #[c2rust::src_loc = "8:3"]
    pub const CMD_anoremenu: CMD_index = 6;
    #[c2rust::src_loc = "7:3"]
    pub const CMD_amenu: CMD_index = 5;
    #[c2rust::src_loc = "6:3"]
    pub const CMD_all: CMD_index = 4;
    #[c2rust::src_loc = "5:3"]
    pub const CMD_aboveleft: CMD_index = 3;
    #[c2rust::src_loc = "4:3"]
    pub const CMD_abclear: CMD_index = 2;
    #[c2rust::src_loc = "3:3"]
    pub const CMD_abbreviate: CMD_index = 1;
    #[c2rust::src_loc = "2:3"]
    pub const CMD_append: CMD_index = 0;
    #[c2rust::src_loc = "1:1"]
    pub type cmdidx_T = CMD_index;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/ex_cmds_defs.h:47"]
pub mod ex_cmds_defs_h {
    // for linenr_T
    // When adding an Ex command:
// 1. Add an entry to the table in src/nvim/ex_cmds.lua.  Keep it sorted on the
//    shortest version of the command name that works.  If it doesn't start with
//    a lower case letter, add it at the end.
//
//    Each table entry is a table with the following keys:
//
//      Key     | Description
//      ------- | -------------------------------------------------------------
//      command | Name of the command. Required.
//      enum    | Name of the enum entry. If not set defaults to CMD_{command}.
//      flags   | A set of the flags from below list joined by bitwise or.
//      func    | Name of the function containing the implementation.
//
//    Referenced function should be either non-static one or defined in
//    ex_docmd.c and be coercible to ex_func_T type from below.
//
//    All keys not described in the above table are reserved for future use.
//
// 2. Add a "case: CMD_xxx" in the big switch in ex_docmd.c.
// 3. Add an entry in the index for Ex commands at ":help ex-cmd-index".
// 4. Add documentation in ../doc/xxx.txt.  Add a tag for both the short and
//    long name of the command.
    // allow a linespecs
    // allow a ! after the command name
    // allow extra args after command name
    // expand wildcards in extra part
    // no spaces allowed in the extra part
    // default file range is 1,$
    // extend range to include whole fold also
                                // when less than two numbers given
    // argument required
    // check for trailing vertical bar
    // allow "x for register designation
    // allow count in argument, after command
    // no trailing comment allowed
    // zero line number allowed
    // do not remove CTRL-V from argument
    // number before command is not an address
    // allow "+command" argument
    // accepts buffer name
    // accepts unlisted buffer too
    // allow "++opt=val" argument
    // allowed in the sandbox
    // allowed in cmdline window; when missing
                                // disallows editing another buffer when
                                // curbuf_lock is set
    // forbidden in non-'modifiable' buffer
    // allow flags after count in argument
    // forbidden in restricted mode
    // multiple extra files allowed
    // one extra word allowed
    // 1 file allowed, defaults to current file
    // values for cmd_addr_type
    // Tab page that only relative
    /* behavior for bad character, "++bad=" argument */
    /* replace it with '?' (default) */
    /* leave it */
    /* erase it */
    // / Structure for command definition.
    // /< Name of the command.
    // /< Function with implementation of this command.
    // /< Relevant flags from the declared above.
    // /< Flag for address type
    // A list used for saving values of "emsg_silent".  Used by ex_try() to save the
// value of "emsg_silent" if it was non-zero.  When this is done, the CSF_SILENT
// flag below is set.
    // saved value of "emsg_silent"
    // next element on the list
    // For conditional commands a stack is kept of nested conditionals.
// When cs_idx < 0, there is no conditional command.
    // CSF_ flags
    // CSTP_: what's pending in ":finally"
    // return typeval for pending return
    // exception for pending throw
    // info used by ":for"
    // line nr of ":while"/":for" line
    // current entry, or -1 if none
    // nr of nested ":while"s and ":for"s
    // nr of nested ":try"s
    // saved values of "emsg_silent"
    // loop flags: CSL_ flags
    // Flags for the cs_lflags item in cstack_T.
    // just found ":while" or ":for"
    // just found ":endwhile" or ":endfor"
    // just found ":continue"
    // just found ":finally"
    // / Arguments used for Ex commands.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "142:8"]
    pub struct exarg {
        pub arg: *mut char_u,
        pub nextcmd: *mut char_u,
        pub cmd: *mut char_u,
        pub cmdlinep: *mut *mut char_u,
        pub cmdidx: cmdidx_T,
        pub argt: uint32_t,
        pub skip: libc::c_int,
        pub forceit: libc::c_int,
        pub addr_count: libc::c_int,
        pub line1: linenr_T,
        pub line2: linenr_T,
        pub addr_type: libc::c_int,
        pub flags: libc::c_int,
        pub do_ecmd_cmd: *mut char_u,
        pub do_ecmd_lnum: linenr_T,
        pub append: libc::c_int,
        pub usefilter: libc::c_int,
        pub amount: libc::c_int,
        pub regname: libc::c_int,
        pub force_bin: libc::c_int,
        pub read_edit: libc::c_int,
        pub force_ff: libc::c_int,
        pub force_enc: libc::c_int,
        pub bad_char: libc::c_int,
        pub useridx: libc::c_int,
        pub errmsg: *mut char_u,
        pub getline: LineGetter,
        pub cookie: *mut libc::c_void,
        pub cstack: *mut cstack_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "115:9"]
    pub struct cstack_T {
        pub cs_flags: [libc::c_int; 50],
        pub cs_pending: [libc::c_char; 50],
        pub cs_pend: C2RustUnnamed_28,
        pub cs_forinfo: [*mut libc::c_void; 50],
        pub cs_line: [libc::c_int; 50],
        pub cs_idx: libc::c_int,
        pub cs_looplevel: libc::c_int,
        pub cs_trylevel: libc::c_int,
        pub cs_emsg_silent_list: *mut eslist_T,
        pub cs_lflags: libc::c_int,
    }
    #[c2rust::src_loc = "103:1"]
    pub type eslist_T = eslist_elem;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "104:8"]
    pub struct eslist_elem {
        pub saved_emsg_silent: libc::c_int,
        pub next: *mut eslist_T,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "118:3"]
    pub union C2RustUnnamed_28 {
        pub csp_rv: [*mut libc::c_void; 50],
        pub csp_ex: [*mut libc::c_void; 50],
    }
    #[c2rust::src_loc = "90:1"]
    pub type LineGetter
        =
        Option<unsafe extern "C" fn(_: libc::c_int, _: *mut libc::c_void,
                                    _: libc::c_int, _: bool) -> *mut char_u>;
    #[c2rust::src_loc = "81:1"]
    pub type exarg_T = exarg;
    // type of expansion
    // start of item to expand
    // bytes in xp_pattern before cursor
    // completion function
    // SCTX for completion function
    // one of the XP_BS_ values
    // TRUE for a shell command, more
                                // characters need to be escaped
    // number of files found by file name completion
    // list of files
    // text being completed
    // cursor position in line
    // values for xp_backslash
    // nothing special for backslashes
    // uses one backslash before a space
    // uses three backslashes before a space
    // / Command modifiers ":vertical", ":browse", ":confirm", ":hide", etc. set a
// / flag.  This needs to be saved for recursive commands, put them in a
// / structure for easy manipulation.
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "208:9"]
    pub struct cmdmod_T {
        pub split: libc::c_int,
        pub tab: libc::c_int,
        pub browse: bool,
        pub confirm: bool,
        pub hide: bool,
        pub keepalt: bool,
        pub keepjumps: bool,
        pub keepmarks: bool,
        pub keeppatterns: bool,
        pub lockmarks: bool,
        pub noswapfile: bool,
        pub save_ei: *mut char_u,
        pub filter_regmatch: regmatch_T,
        pub filter_force: bool,
    }
    use super::nvim_types_h::char_u;
    use super::ex_cmds_enum_generated_h::cmdidx_T;
    use super::stdint_uintn_h::uint32_t;
    use super::pos_h::linenr_T;
    use super::regexp_defs_h::regmatch_T;
    // NVIM_EX_CMDS_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/defs.h:47"]
pub mod event_defs_h {
    #[c2rust::src_loc = "9:1"]
    pub type argv_callback
        =
        Option<unsafe extern "C" fn(_: *mut *mut libc::c_void) -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "10:16"]
    pub struct message {
        pub handler: argv_callback,
        pub argv: [*mut libc::c_void; 10],
    }
    #[c2rust::src_loc = "10:1"]
    pub type Event = message;
    #[inline]
    #[c2rust::src_loc = "30:1"]
    pub unsafe extern "C" fn event_create(mut cb: argv_callback,
                                          mut argc: libc::c_int,
                                          mut args: ...) -> Event {
        if argc <= 10 as libc::c_int {
        } else {
            __assert_fail(b"argc <= EVENT_HANDLER_MAX_ARGC\x00" as *const u8
                              as *const libc::c_char,
                          b"../src/nvim/event/defs.h\x00" as *const u8 as
                              *const libc::c_char,
                          32 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 44],
                                                    &[libc::c_char; 44]>(b"Event event_create(argv_callback, int, ...)\x00")).as_ptr());
        }
        let mut event =
            Event{handler: None, argv: [0 as *mut libc::c_void; 10],};
        if argc <= 10 as libc::c_int {
        } else {
            __assert_fail(b"argc <= EVENT_HANDLER_MAX_ARGC\x00" as *const u8
                              as *const libc::c_char,
                          b"../src/nvim/event/defs.h\x00" as *const u8 as
                              *const libc::c_char,
                          34 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 44],
                                                    &[libc::c_char; 44]>(b"Event event_create(argv_callback, int, ...)\x00")).as_ptr());
        }
        event.handler = cb;
        if argc != 0 {
            let mut args_0: ::std::ffi::VaListImpl;
            args_0 = args.clone();
            let mut i = 0 as libc::c_int;
            while i < argc {
                event.argv[i as usize] = args_0.arg::<*mut libc::c_void>();
                i += 1
            }
        }
        return event;
    }
    use super::assert_h::__assert_fail;
    // NVIM_EVENT_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/multiqueue.h:47"]
pub mod multiqueue_h {
    #[c2rust::src_loc = "10:1"]
    pub type MultiQueue = multiqueue;
    extern "C" {
        #[c2rust::src_loc = "10:16"]
        pub type multiqueue;
    }
    // NVIM_EVENT_MULTIQUEUE_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/loop.h:47"]
pub mod loop_h {
    #[c2rust::src_loc = "12:1"]
    pub type WatcherPtr = *mut libc::c_void;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct __kl1_WatcherPtr {
        pub data: WatcherPtr,
        pub next: *mut __kl1_WatcherPtr,
    }
    #[c2rust::src_loc = "15:1"]
    pub type kl1_WatcherPtr = __kl1_WatcherPtr;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct kmp_WatcherPtr_t {
        pub cnt: size_t,
        pub n: size_t,
        pub max: size_t,
        pub buf: *mut *mut kl1_WatcherPtr,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:1"]
    pub struct kl_WatcherPtr_t {
        pub head: *mut kl1_WatcherPtr,
        pub tail: *mut kl1_WatcherPtr,
        pub mp: *mut kmp_WatcherPtr_t,
        pub size: size_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "17:16"]
    pub struct loop_0 {
        pub uv: uv_loop_t,
        pub events: *mut MultiQueue,
        pub thread_events: *mut MultiQueue,
        pub fast_events: *mut MultiQueue,
        pub children: *mut kl_WatcherPtr_t,
        pub children_watcher: uv_signal_t,
        pub children_kill_timer: uv_timer_t,
        pub poll_timer: uv_timer_t,
        pub async_0: uv_async_t,
        pub mutex: uv_mutex_t,
        pub recursive: libc::c_int,
    }
    #[c2rust::src_loc = "17:1"]
    pub type Loop = loop_0;
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_init_WatcherPtr() -> *mut kmp_WatcherPtr_t {
        return xcalloc(1 as libc::c_int as size_t,
                       ::std::mem::size_of::<kmp_WatcherPtr_t>() as
                           libc::c_ulong) as *mut kmp_WatcherPtr_t;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_destroy_WatcherPtr(mut mp:
                                                        *mut kmp_WatcherPtr_t) {
        let mut k: size_t = 0;
        k = 0 as libc::c_int as size_t;
        while k < (*mp).n {
            let mut ptr_ =
                &mut *(*mp).buf.offset(k as isize) as *mut *mut kl1_WatcherPtr
                    as *mut *mut libc::c_void;
            xfree(*ptr_);
            *ptr_ = NULL_1 as *mut libc::c_void;
            k = k.wrapping_add(1)
        }
        let mut ptr__0 =
            &mut (*mp).buf as *mut *mut *mut kl1_WatcherPtr as
                *mut *mut libc::c_void;
        xfree(*ptr__0);
        *ptr__0 = NULL_1 as *mut libc::c_void;
        let mut ptr__1 =
            &mut mp as *mut *mut kmp_WatcherPtr_t as *mut *mut libc::c_void;
        xfree(*ptr__1);
        *ptr__1 = NULL_1 as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_alloc_WatcherPtr(mut mp:
                                                      *mut kmp_WatcherPtr_t)
     -> *mut kl1_WatcherPtr {
        (*mp).cnt = (*mp).cnt.wrapping_add(1);
        if (*mp).n == 0 as libc::c_int as libc::c_ulong {
            return xcalloc(1 as libc::c_int as size_t,
                           ::std::mem::size_of::<kl1_WatcherPtr>() as
                               libc::c_ulong) as *mut kl1_WatcherPtr
        }
        (*mp).n = (*mp).n.wrapping_sub(1);
        return *(*mp).buf.offset((*mp).n as isize);
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kmp_free_WatcherPtr(mut mp:
                                                     *mut kmp_WatcherPtr_t,
                                                 mut p: *mut kl1_WatcherPtr) {
        (*mp).cnt = (*mp).cnt.wrapping_sub(1);
        if (*mp).n == (*mp).max {
            (*mp).max =
                if (*mp).max != 0 {
                    ((*mp).max) << 1 as libc::c_int
                } else { 16 as libc::c_int as libc::c_ulong };
            (*mp).buf =
                xrealloc((*mp).buf as *mut libc::c_void,
                         (::std::mem::size_of::<*mut kl1_WatcherPtr>() as
                              libc::c_ulong).wrapping_mul((*mp).max)) as
                    *mut *mut kl1_WatcherPtr
        }
        let fresh1 = (*mp).n;
        (*mp).n = (*mp).n.wrapping_add(1);
        let ref mut fresh2 = *(*mp).buf.offset(fresh1 as isize);
        *fresh2 = p;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_init_WatcherPtr() -> *mut kl_WatcherPtr_t {
        let mut kl =
            xcalloc(1 as libc::c_int as size_t,
                    ::std::mem::size_of::<kl_WatcherPtr_t>() as libc::c_ulong)
                as *mut kl_WatcherPtr_t;
        (*kl).mp = kmp_init_WatcherPtr();
        (*kl).tail = kmp_alloc_WatcherPtr((*kl).mp);
        (*kl).head = (*kl).tail;
        (*(*kl).head).next = 0 as *mut __kl1_WatcherPtr;
        return kl;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_destroy_WatcherPtr(mut kl:
                                                       *mut kl_WatcherPtr_t) {
        let mut p = 0 as *mut kl1_WatcherPtr;
        p = (*kl).head;
        while p != (*kl).tail {
            kmp_free_WatcherPtr((*kl).mp, p);
            p = (*p).next
        }
        kmp_free_WatcherPtr((*kl).mp, p);
        kmp_destroy_WatcherPtr((*kl).mp);
        let mut ptr_ =
            &mut kl as *mut *mut kl_WatcherPtr_t as *mut *mut libc::c_void;
        xfree(*ptr_);
        *ptr_ = NULL_1 as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_push_WatcherPtr(mut kl: *mut kl_WatcherPtr_t,
                                                mut d: WatcherPtr) {
        let mut q = 0 as *mut kl1_WatcherPtr;
        let mut p = kmp_alloc_WatcherPtr((*kl).mp);
        q = (*kl).tail;
        (*p).next = 0 as *mut __kl1_WatcherPtr;
        (*(*kl).tail).next = p;
        (*kl).tail = p;
        (*kl).size = (*kl).size.wrapping_add(1);
        (*q).data = d;
    }
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn kl_shift_at_WatcherPtr(mut kl:
                                                        *mut kl_WatcherPtr_t,
                                                    mut n:
                                                        *mut *mut kl1_WatcherPtr)
     -> WatcherPtr {
        if !(**n).next.is_null() {
        } else {
            __assert_fail(b"(*n)->next\x00" as *const u8 as
                              *const libc::c_char,
                          b"../src/nvim/event/loop.h\x00" as *const u8 as
                              *const libc::c_char,
                          15 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 72],
                                                    &[libc::c_char; 72]>(b"WatcherPtr kl_shift_at_WatcherPtr(kl_WatcherPtr_t *, kl1_WatcherPtr **)\x00")).as_ptr());
        }
        let mut p = 0 as *mut kl1_WatcherPtr;
        (*kl).size = (*kl).size.wrapping_sub(1);
        p = *n;
        *n = (**n).next;
        if p == (*kl).head { (*kl).head = *n }
        let mut d = (*p).data;
        kmp_free_WatcherPtr((*kl).mp, p);
        return d;
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::uv_h::{uv_loop_t, uv_signal_t, uv_timer_t, uv_async_t};
    use super::multiqueue_h::MultiQueue;
    use super::unix_h::uv_mutex_t;
    use super::memory_h_generated_h::{xcalloc, xfree, xrealloc};
    use super::assert_h::__assert_fail;
    // NVIM_EVENT_LOOP_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/globals.h:47"]
pub mod globals_h {
    #[c2rust::src_loc = "111:1"]
    pub type off_T = off_t;
    // file I/O and sprintf buffer size
    // length of buffer for small messages
    // cell length (worst case: utf-8
                                         // takes 6 bytes for one cell)
    // Values for "starting".
    // no screen updating yet
    // not all buffers loaded yet
    //                      0          not starting anymore
    // Number of Rows and Columns in the screen.
// Note: Use default_grid.Rows and default_grid.Columns to access items in
// default_grid.chars[]. They may have different values when the screen
// wasn't (re)allocated yet after setting Rows or Columns (e.g., when starting
// up).
    // default value for 'columns'
    // default value for 'lines'
    // nr of rows in the screen
    // nr of columns in the screen
    // We use 64-bit file functions here, if available.  E.g. ftello() returns
// off_t instead of long, which helps if long is 32 bit and off_t is 64 bit.
// We assume that when fseeko() is available then ftello() is too.
// Note that Windows has different function names.
    // When vgetc() is called, it sets mod_mask to the set of modifiers that are
// held down based on the MOD_MASK_* symbols that are read first.
    // current key modifiers
    // Cmdline_row is the row where the command line starts, just below the
// last window.
// When the cmdline gets longer than the available space the screen gets
// scrolled up. After a CTRL-D (show matches), after hitting ':' after
// "hit return", and for the :global command, the command line is
// temporarily moved.  The old position is restored with the next call to
// update_screen().
    // cmdline must be redrawn
    // cmdline must be cleared
    // mode is being displayed
    // cmdline is crypted
    // cmdline is being redrawn
    // cmdline was last drawn
    // executing register
    // When '$' is included in 'cpoptions' option set:
// When a change command is given that deletes only part of a line, a dollar
// is put at the end of the changed text. dollar_vcol is set to the virtual
// column of this '$'.  -1 is used to indicate no $ is being displayed.
    // Variables for Insert mode completion.
    // Length in bytes of the text being completed (this is deleted to be replaced
// by the match.)
    // Set when character typed while looking for matches and it means we should
// stop looking for matches.
    // Set when doing something for completion that may call edit() recursively,
// which is not allowed. Also used to disable folding during completion
    // List of flags for method of completion.
    // "normal" or "adding" expansion
    // a ^X interrupted the current expansion
                                // it's set only iff N_ADDS is set
    // next ^X<> will add-new or expand-current
    // next ^X<> will set initial_pos?
                                // if so, word-wise-expansion will set SOL
    // pattern includes start of line, just for
                                // word-wise expansion, not set for ^X^L
    // for ctrl_x_mode 0, ^X^P/^X^N do a local
                                // expansion, (eg use complete=.)
    // state for putting characters in the message area
    // cmdline is drawn right to left
    // Number of screen lines that windows have
                                // scrolled because of printing messages.
    // when true don't set need_wait_return in msg_puts_attr()
// when msg_scrolled is non-zero
    // Whether the screen is damaged due to scrolling. Sometimes msg_scrolled
// is reset before the screen is redrawn, so we need to keep track of this.
    // msg to be shown after redraw
    // highlight attr for keep_msg
    // keep_msg was set by msgmore()
    // do fileinfo() after redraw
    // msg_start() will scroll
    // msg_outstr() was used in line
    // msg_outstr() was used at all
    // don't wait for this msg
    // don't display errors for now,
                                            // unless 'debug' is set.
    // printing informative message
    // don't add messages to history
    // need to clear text before
                                            // displaying a message.
    // don't display errors for
                                            // expression that is skipped
    // use message of next of several
                                            //  emsg() calls for throw
    // just had ":endif"
    // Dictionary with v: variables
    // Dictionary with g: variables
    // set by emsg() when the message
                                            // is displayed or thrown
    // set if vim_beep() is called
    // did_emsg set because of a
                                            // syntax error
    // always set by emsg()
    // exit value for ex mode
    // there is an error message
    // vim_regcomp() called emsg()
    // don't wait for return for now
    // need to wait for return later
    // wait_return() was used and
                                            // nothing written since then
    // call maketitle() soon
    // 'q' hit at "--more--" msg
    // getexmodeline(): keep indent
    // when inside vgetc() then > 0
    // did set $VIM ourselves
    // idem for $VIMRUNTIME
    // / Lines left before a "more" message.  Ex mode needs to be able to reset this
// / after you type something.
    // lines left for listing
    // don't use more prompt, truncate
                                            // messages
    // name of error message source
    // line number of the source file
    // nesting level
    // break below this level
    // did "debug mode" message
    // breakpoint change count
    // breakpoint backtrace level
    // Values for "do_profiling".
    // /< profiling not started
    // /< profiling busy
    // /< profiling paused
    // /< PROF_ values
    // / Exception currently being thrown.  Used to pass an exception to a different
// / cstack.  Also used for discarding an exception before it is caught or made
// / pending.
    // / Set when a throw that cannot be handled in do_cmdline() must be propagated
// / to the cstack of the previously called do_cmdline().
    // / Set when a ":finish" or ":return" that cannot be handled in do_cmdline()
// / must be propagated to the cstack of the previously called do_cmdline().
    // / Number of nested try conditionals (across function calls and ":source"
// / commands).
    // / When "force_abort" is true, always skip commands after an error message,
// / even after the outermost ":endif", ":endwhile" or ":endfor" or for a
// / function without the "abort" flag.  It is set to true when "trylevel" is
// / non-zero (and ":silent!" was not used) or an exception is being thrown at
// / the time an error is detected.  It is set to false when "trylevel" gets
// / zero again and there was no error or interrupt or throw.
    // / "msg_list" points to a variable in the stack of do_cmdline() which keeps
// / the list of arguments of several emsg() calls, one of which is to be
// / converted to an error exception immediately after the failing command
// / returns.  The message to be used for the exception value is pointed to by
// / the "throw_msg" field of the first element in the list.  It is usually the
// / same as the "msg" field of that element, but can be identical to the "msg"
// / field of a later list element, when the "emsg_severe" flag was set when the
// / emsg() call was made.
    // / When set, don't convert an error to an exception.  Used when displaying the
// / interrupt message or reporting an exception that is still uncaught at the
// / top level (which has already been discarded then).  Also used for the error
// / message when no exception can be thrown.
    // / The stack of all caught and not finished exceptions.  The exception on the
// / top of the stack is the one got by evaluation of v:exception.  The complete
// / stack of all caught and pending exceptions is embedded in the various
// / cstacks; the pending exceptions, however, are not on the caught stack.
    // /
// / Garbage collection can only take place when we are sure there are no Lists
// / or Dictionaries being used internally.  This is flagged with
// / "may_garbage_collect" when we are at the toplevel.
// / "want_garbage_collect" is set by the garbagecollect() function, which means
// / we do garbage collection before waiting for a char at the toplevel.
// / "garbage_collect_at_exit" indicates garbagecollect(1) was called.
// /
    // Special values for current_SID.
    // when using a modeline
    // for "--cmd" argument
    // for "-c" argument
    // for sourcing environment variable
    // option was reset because of an error
    // don't set scriptID
    // for Lua scripts/chunks
    // for API clients
    // for sourcing a string
    // Script CTX being sourced or was sourced to define the current function.
    // ID of the current channel making a client API call
    // Scope information for the code that indirectly triggered the current
// provider function call
    // int value of T_CCO
    // When highlight_match is true, highlight a match, starting at the cursor
// position.  Search_match_lines is the number of lines after the match (0 for
// a match within one line), search_match_endcol the column number of the
// character just after the match in the last line.
    // show search match pos
    // lines of of matched string
    // col nr of match end
    // don't use 'smartcase' once
    // need to check file
                                                 // timestamps asap
    // did check timestamps
                                                 // recently
    // Don't check timestamps
    // Is apply_autocmds() busy?
    // *Enter autocmds disabled
    // *Leave autocmds disabled
    // did ":set modified"
    // FileType event found
    // value for did_filetype when starting to execute autocommands
    // When deleting the current buffer, another one must be loaded.
// If we know which one is preferred, au_new_curbuf is set to it.
    // When deleting a buffer/window and autocmd_busy is true, do not free the
// buffer/window. but link it in the list starting with
// au_pending_free_buf/ap_pending_free_win, using b_next/w_next.
// Free the buffer/window when autocmd_busy is being set to false.
    // Mouse coordinates, set by handle_mouse_event()
    // mouse below last line
    // mouse right of line
    // extending Visual area with
                                              // mouse dragging
    // The root of the menu hierarchy.
    // While defining the system menu, sys_menu is true.  This avoids
// overruling of menus that the user already defined.
    // While redrawing the screen this flag is set.  It means the screen size
// ('lines' and 'rows') must not be changed.
    // All windows are linked in a list. firstwin points to the first entry,
// lastwin to the last entry (can be the same as firstwin) and curwin to the
// currently active window.
    // first window
    // last window
    // previous window
    // NOLINT
    // When using this macro "break" only breaks out of the inner loop. Use "goto"
// to break out of the tabpage loop.
    // -V:FOR_ALL_WINDOWS_IN_TAB:501
    // currently active window
    // window used in aucmd_prepbuf()
    // aucmd_win is being used
    // The window layout is kept in a tree of frames.  topframe points to the top
// of the tree.
    // top of the window frame tree
    // Tab pages are alternative topframes.  "first_tabpage" points to the first
// one in the list, "curtab" is the current one.
    // need to redraw tabline
    // Iterates over all tabs in the tab list
    // All buffers are linked in a list. 'firstbuf' points to the first entry,
// 'lastbuf' to the last entry and 'curbuf' to the currently active buffer.
    // first buffer
    // last buffer
    // currently active buffer
    // Iterates over all buffers in the buffer list.
    // Iterate through all the signs placed in a buffer
    // NOLINT
    // List of files being edited (global argument list).  curwin->w_alist points
// to this when the window is using the global argument list.
    // global argument list
    // /< the previous argument list id
    // accessed last file in
                                            // global_alist
    // column for ruler
    // 'rulerfmt' width of ruler when non-zero
    // column for shown command
    // When starting or exiting some things are done differently (e.g. screen
// updating).
    // First NO_SCREEN, then NO_BUFFERS, then 0 when startup finished.
    // true when planning to exit. Might keep running if there is a changed buffer.
    // is stdin a terminal?
    // is stdout a terminal?
    // true when doing full-screen output, otherwise only writing some messages.
// volatile because it is used in a signal handler.
    // When started in restricted mode (-Z).
    // / Non-zero when only "safe" commands are allowed, e.g. when sourcing .exrc or
// / .vimrc in current directory.
    // / Non-zero when changing text and jumping to another window/buffer is not
// / allowed.
    // / Non-zero when the current buffer can't be changed.  Used for FileChangedRO.
    // / Non-zero when no buffer name can be changed, no buffer can be deleted and
// / current directory can't be changed. Used for SwapExists et al.
    // / Non-zero when evaluating an expression in a "sandbox".  Several things are
// / not allowed then.
    // / Batch-mode: "-es" or "-Es" commandline argument was given.
    // / Start position of active Visual selection.
    // / Whether Visual mode is active.
    // / Whether Select mode is active.
    // / Whether to restart the selection after a Select-mode mapping or menu.
    // / Type of Visual mode.
    // / true when redoing Visual.
    // / When pasting text with the middle mouse button in visual mode with
// / restart_edit set, remember where it started so we can set Insstart.
    // This flag is used to make auto-indent work right on lines where only a
// <RETURN> or <ESC> is typed. It is set when an auto-indent is done, and
// reset when any other editing is done on the line. If an <ESC> or <RETURN>
// is received, and did_ai is true, the line is truncated.
    // Column of first char after autoindent.  0 when no autoindent done.  Used
// when 'backspace' is 0, to avoid backspacing over autoindent.
    // This is a character which will end a start-middle-end comment when typed as
// the first character on a new line.  It is taken from the last character of
// the "end" comment leader when the COM_AUTO_END flag is given for that
// comment end in 'comments'.  It is only valid when did_ai is true.
    // This flag is set after a ":syncbind" to let the check_scrollbind() function
// know that it should not attempt to perform scrollbinding due to the scroll
// that was a result of the ":syncbind." (Otherwise, check_scrollbind() will
// undo some of the work done by ":syncbind.")  -ralston
    // This flag is set when a smart indent has been performed. When the next typed
// character is a '{' the inserted tab will be deleted again.
    // This flag is set after an auto indent. If the next typed character is a '}'
// one indent will be removed.
    // This flag is set after an "O" command. If the next typed character is a '{'
// one indent will be removed.
    // w_cursor before formatting text.
    // Stuff for insert mode.
    // This is where the latest
                                        // insert/append mode started.
    // This is where the latest insert/append mode started. In contrast to
// Insstart, this won't be reset by certain keys and is needed for
// op_insert(), to detect correctly where inserting by the user started.
    // Stuff for VREPLACE mode.
    // Line count when "gR" started
    // #Lines changed by "gR" so far
    // increase around internal delete/replace
    // These flags are set based upon 'fileencoding'.
// Note that "enc_utf8" is also set for "unicode", because the characters are
// internally stored as UTF-8 (to avoid trouble with NUL bytes).
    // japan
    // euc-jp
    // korea
    // euc-kr
    // chinese
    // euc-cn
    // taiwan
    // euc-tw
    // 2byte-
    // mbyte flags that used to depend on 'encoding'. These are now deprecated, as
// 'encoding' is always "utf-8". Code that use them can be refactored to
// remove dead code.
    #[c2rust::src_loc = "602:9"]
    pub const has_mbyte: libc::c_int = true_0;
    #[c2rust::src_loc = "113:11"]
    pub const vim_lseek:
              unsafe extern "C" fn(_: libc::c_int, _: __off_t, _: libc::c_int)
                  -> __off_t =
        lseek;
    #[c2rust::src_loc = "660:9"]
    pub const SEA_NONE: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "663:9"]
    pub const SEA_RECOVER: libc::c_int = 3 as libc::c_int;
    #[c2rust::src_loc = "662:9"]
    pub const SEA_QUIT: libc::c_int = 2 as libc::c_int;
    use super::fcntl_h::off_t;
    use super::stdbool_h::true_0;
    use super::unistd_h::lseek;
    use super::types_h::__off_t;
    use super::buffer_defs_h::{win_T, buf_T};
    use super::ex_cmds_defs_h::cmdmod_T;
    use super::nvim_types_h::char_u;
    use super::regexp_defs_h::{regmatch_T, regprog_T};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "137:12"]
        pub static mut cmdline_row: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "184:12"]
        pub static mut msg_row: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "226:12"]
        pub static mut no_wait_return: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "227:12"]
        pub static mut need_wait_return: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "362:12"]
        pub static mut need_check_timestamps: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "364:12"]
        pub static mut did_check_timestamps: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "427:18"]
        pub static mut curwin: *mut win_T;
        #[no_mangle]
        #[c2rust::src_loc = "448:18"]
        pub static mut firstbuf: *mut buf_T;
        #[no_mangle]
        #[c2rust::src_loc = "450:18"]
        pub static mut curbuf: *mut buf_T;
        #[no_mangle]
        #[c2rust::src_loc = "505:12"]
        pub static mut allbuf_lock: libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "582:12"]
        pub static mut inhibit_delete_count: libc::c_int;
        // Modes where CTRL-C is mapped.
        #[no_mangle]
        #[c2rust::src_loc = "652:17"]
        pub static mut cmdmod: cmdmod_T;
        // Ex command modifiers
        #[no_mangle]
        #[c2rust::src_loc = "654:12"]
        pub static mut msg_silent: libc::c_int;
        // don't echo the command line
        // Values for swap_exists_action: what to do when swap file already exists
        // don't use dialog
        // use dialog when possible
        // quit editing the file
        // recover the file
        #[no_mangle]
        #[c2rust::src_loc = "665:12"]
        pub static mut swap_exists_action: libc::c_int;
        // Selected "quit" at the dialog.
        #[no_mangle]
        #[c2rust::src_loc = "671:15"]
        pub static mut IObuff: [char_u; 1025];
        // /< Buffer for sprintf, I/O, etc.
        #[no_mangle]
        #[c2rust::src_loc = "672:15"]
        pub static mut NameBuff: [char_u; 4096];
        // Set to true for "view"
        #[no_mangle]
        #[c2rust::src_loc = "686:12"]
        pub static mut recoverymode: libc::c_int;
        // /< Stream to write script to.
        // volatile because it is used in a signal handler.
        #[no_mangle]
        #[c2rust::src_loc = "710:21"]
        pub static mut got_int: libc::c_int;
        // /< cmdline recursion level
        #[no_mangle]
        #[c2rust::src_loc = "802:15"]
        pub static mut no_lines_msg: [char_u; 0];
    }
    // NVIM_GLOBALS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/getchar.h:53"]
pub mod getchar_h {
    #[c2rust::src_loc = "21:9"]
    pub type flush_buffers_T = libc::c_uint;
    #[c2rust::src_loc = "24:3"]
    pub const FLUSH_INPUT: flush_buffers_T = 2;
    #[c2rust::src_loc = "23:3"]
    pub const FLUSH_TYPEAHEAD: flush_buffers_T = 1;
    #[c2rust::src_loc = "22:3"]
    pub const FLUSH_MINIMAL: flush_buffers_T = 0;
    // NVIM_GETCHAR_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/eval.h:49"]
pub mod eval_h {
    #[c2rust::src_loc = "132:5"]
    pub const VV_SWAPCHOICE: VimVarIndex = 48;
    #[c2rust::src_loc = "83:9"]
    pub type VimVarIndex = libc::c_uint;
    #[c2rust::src_loc = "168:5"]
    pub const VV_LUA: VimVarIndex = 84;
    #[c2rust::src_loc = "167:5"]
    pub const VV_EXITING: VimVarIndex = 83;
    #[c2rust::src_loc = "166:5"]
    pub const VV_ECHOSPACE: VimVarIndex = 82;
    #[c2rust::src_loc = "165:5"]
    pub const VV_TYPE_BOOL: VimVarIndex = 81;
    #[c2rust::src_loc = "164:5"]
    pub const VV_TYPE_FLOAT: VimVarIndex = 80;
    #[c2rust::src_loc = "163:5"]
    pub const VV_TYPE_DICT: VimVarIndex = 79;
    #[c2rust::src_loc = "162:5"]
    pub const VV_TYPE_LIST: VimVarIndex = 78;
    #[c2rust::src_loc = "161:5"]
    pub const VV_TYPE_FUNC: VimVarIndex = 77;
    #[c2rust::src_loc = "160:5"]
    pub const VV_TYPE_STRING: VimVarIndex = 76;
    #[c2rust::src_loc = "159:5"]
    pub const VV_TYPE_NUMBER: VimVarIndex = 75;
    #[c2rust::src_loc = "158:5"]
    pub const VV_TESTING: VimVarIndex = 74;
    #[c2rust::src_loc = "157:5"]
    pub const VV_VIM_DID_ENTER: VimVarIndex = 73;
    #[c2rust::src_loc = "156:5"]
    pub const VV__NULL_DICT: VimVarIndex = 72;
    #[c2rust::src_loc = "155:5"]
    pub const VV__NULL_LIST: VimVarIndex = 71;
    #[c2rust::src_loc = "154:5"]
    pub const VV_NULL: VimVarIndex = 70;
    #[c2rust::src_loc = "153:5"]
    pub const VV_TRUE: VimVarIndex = 69;
    #[c2rust::src_loc = "152:5"]
    pub const VV_FALSE: VimVarIndex = 68;
    #[c2rust::src_loc = "151:5"]
    pub const VV_EVENT: VimVarIndex = 67;
    #[c2rust::src_loc = "150:5"]
    pub const VV_MSGPACK_TYPES: VimVarIndex = 66;
    #[c2rust::src_loc = "149:5"]
    pub const VV_ERRORS: VimVarIndex = 65;
    #[c2rust::src_loc = "148:5"]
    pub const VV_OPTION_TYPE: VimVarIndex = 64;
    #[c2rust::src_loc = "147:5"]
    pub const VV_OPTION_OLD: VimVarIndex = 63;
    #[c2rust::src_loc = "146:5"]
    pub const VV_OPTION_NEW: VimVarIndex = 62;
    #[c2rust::src_loc = "145:5"]
    pub const VV_COMPLETED_ITEM: VimVarIndex = 61;
    #[c2rust::src_loc = "144:5"]
    pub const VV_PROGPATH: VimVarIndex = 60;
    #[c2rust::src_loc = "143:5"]
    pub const VV_WINDOWID: VimVarIndex = 59;
    #[c2rust::src_loc = "142:5"]
    pub const VV_OLDFILES: VimVarIndex = 58;
    #[c2rust::src_loc = "141:5"]
    pub const VV_HLSEARCH: VimVarIndex = 57;
    #[c2rust::src_loc = "140:5"]
    pub const VV_SEARCHFORWARD: VimVarIndex = 56;
    #[c2rust::src_loc = "139:5"]
    pub const VV_OP: VimVarIndex = 55;
    #[c2rust::src_loc = "138:5"]
    pub const VV_MOUSE_COL: VimVarIndex = 54;
    #[c2rust::src_loc = "137:5"]
    pub const VV_MOUSE_LNUM: VimVarIndex = 53;
    #[c2rust::src_loc = "136:5"]
    pub const VV_MOUSE_WINID: VimVarIndex = 52;
    #[c2rust::src_loc = "135:5"]
    pub const VV_MOUSE_WIN: VimVarIndex = 51;
    #[c2rust::src_loc = "134:5"]
    pub const VV_CHAR: VimVarIndex = 50;
    #[c2rust::src_loc = "133:5"]
    pub const VV_SWAPCOMMAND: VimVarIndex = 49;
    #[c2rust::src_loc = "131:5"]
    pub const VV_SWAPNAME: VimVarIndex = 47;
    #[c2rust::src_loc = "130:5"]
    pub const VV_SCROLLSTART: VimVarIndex = 46;
    #[c2rust::src_loc = "129:5"]
    pub const VV_BEVAL_TEXT: VimVarIndex = 45;
    #[c2rust::src_loc = "128:5"]
    pub const VV_BEVAL_COL: VimVarIndex = 44;
    #[c2rust::src_loc = "127:5"]
    pub const VV_BEVAL_LNUM: VimVarIndex = 43;
    #[c2rust::src_loc = "126:5"]
    pub const VV_BEVAL_WINID: VimVarIndex = 42;
    #[c2rust::src_loc = "125:5"]
    pub const VV_BEVAL_WINNR: VimVarIndex = 41;
    #[c2rust::src_loc = "124:5"]
    pub const VV_BEVAL_BUFNR: VimVarIndex = 40;
    #[c2rust::src_loc = "123:5"]
    pub const VV_FCS_CHOICE: VimVarIndex = 39;
    #[c2rust::src_loc = "122:5"]
    pub const VV_FCS_REASON: VimVarIndex = 38;
    #[c2rust::src_loc = "121:5"]
    pub const VV_PROFILING: VimVarIndex = 37;
    #[c2rust::src_loc = "120:5"]
    pub const VV_KEY: VimVarIndex = 36;
    #[c2rust::src_loc = "119:5"]
    pub const VV_VAL: VimVarIndex = 35;
    #[c2rust::src_loc = "118:5"]
    pub const VV_INSERTMODE: VimVarIndex = 34;
    #[c2rust::src_loc = "117:5"]
    pub const VV_CMDBANG: VimVarIndex = 33;
    #[c2rust::src_loc = "116:5"]
    pub const VV_REG: VimVarIndex = 32;
    #[c2rust::src_loc = "115:5"]
    pub const VV_STDERR: VimVarIndex = 31;
    #[c2rust::src_loc = "114:5"]
    pub const VV_THROWPOINT: VimVarIndex = 30;
    #[c2rust::src_loc = "113:5"]
    pub const VV_EXCEPTION: VimVarIndex = 29;
    #[c2rust::src_loc = "112:5"]
    pub const VV_DYING: VimVarIndex = 28;
    #[c2rust::src_loc = "111:5"]
    pub const VV_SEND_SERVER: VimVarIndex = 27;
    #[c2rust::src_loc = "110:5"]
    pub const VV_PROGNAME: VimVarIndex = 26;
    #[c2rust::src_loc = "109:5"]
    pub const VV_FOLDLEVEL: VimVarIndex = 25;
    #[c2rust::src_loc = "108:5"]
    pub const VV_FOLDDASHES: VimVarIndex = 24;
    #[c2rust::src_loc = "107:5"]
    pub const VV_FOLDEND: VimVarIndex = 23;
    #[c2rust::src_loc = "106:5"]
    pub const VV_FOLDSTART: VimVarIndex = 22;
    #[c2rust::src_loc = "105:5"]
    pub const VV_CMDARG: VimVarIndex = 21;
    #[c2rust::src_loc = "104:5"]
    pub const VV_FNAME_DIFF: VimVarIndex = 20;
    #[c2rust::src_loc = "103:5"]
    pub const VV_FNAME_NEW: VimVarIndex = 19;
    #[c2rust::src_loc = "102:5"]
    pub const VV_FNAME_OUT: VimVarIndex = 18;
    #[c2rust::src_loc = "101:5"]
    pub const VV_FNAME_IN: VimVarIndex = 17;
    #[c2rust::src_loc = "100:5"]
    pub const VV_CC_TO: VimVarIndex = 16;
    #[c2rust::src_loc = "99:5"]
    pub const VV_CC_FROM: VimVarIndex = 15;
    #[c2rust::src_loc = "98:5"]
    pub const VV_CTYPE: VimVarIndex = 14;
    #[c2rust::src_loc = "97:5"]
    pub const VV_LC_TIME: VimVarIndex = 13;
    #[c2rust::src_loc = "96:5"]
    pub const VV_LANG: VimVarIndex = 12;
    #[c2rust::src_loc = "95:5"]
    pub const VV_FNAME: VimVarIndex = 11;
    #[c2rust::src_loc = "94:5"]
    pub const VV_TERMRESPONSE: VimVarIndex = 10;
    #[c2rust::src_loc = "93:5"]
    pub const VV_LNUM: VimVarIndex = 9;
    #[c2rust::src_loc = "92:5"]
    pub const VV_VERSION: VimVarIndex = 8;
    #[c2rust::src_loc = "91:5"]
    pub const VV_THIS_SESSION: VimVarIndex = 7;
    #[c2rust::src_loc = "90:5"]
    pub const VV_SHELL_ERROR: VimVarIndex = 6;
    #[c2rust::src_loc = "89:5"]
    pub const VV_STATUSMSG: VimVarIndex = 5;
    #[c2rust::src_loc = "88:5"]
    pub const VV_WARNINGMSG: VimVarIndex = 4;
    #[c2rust::src_loc = "87:5"]
    pub const VV_ERRMSG: VimVarIndex = 3;
    #[c2rust::src_loc = "86:5"]
    pub const VV_PREVCOUNT: VimVarIndex = 2;
    #[c2rust::src_loc = "85:5"]
    pub const VV_COUNT1: VimVarIndex = 1;
    #[c2rust::src_loc = "84:5"]
    pub const VV_COUNT: VimVarIndex = 0;
    // NVIM_EVAL_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/auevents_enum.generated.h:54"]
pub mod auevents_enum_generated_h {
    #[c2rust::src_loc = "1:1"]
    pub type event_T = auto_event;
    #[c2rust::src_loc = "1:9"]
    pub type auto_event = libc::c_uint;
    #[c2rust::src_loc = "114:3"]
    pub const NUM_EVENTS: auto_event = 112;
    #[c2rust::src_loc = "113:3"]
    pub const EVENT_WINNEW: auto_event = 111;
    #[c2rust::src_loc = "112:3"]
    pub const EVENT_WINLEAVE: auto_event = 110;
    #[c2rust::src_loc = "111:3"]
    pub const EVENT_WINENTER: auto_event = 109;
    #[c2rust::src_loc = "110:3"]
    pub const EVENT_WINCLOSED: auto_event = 108;
    #[c2rust::src_loc = "109:3"]
    pub const EVENT_VIMSUSPEND: auto_event = 107;
    #[c2rust::src_loc = "108:3"]
    pub const EVENT_VIMRESUME: auto_event = 106;
    #[c2rust::src_loc = "107:3"]
    pub const EVENT_VIMRESIZED: auto_event = 105;
    #[c2rust::src_loc = "106:3"]
    pub const EVENT_VIMLEAVEPRE: auto_event = 104;
    #[c2rust::src_loc = "105:3"]
    pub const EVENT_VIMLEAVE: auto_event = 103;
    #[c2rust::src_loc = "104:3"]
    pub const EVENT_VIMENTER: auto_event = 102;
    #[c2rust::src_loc = "103:3"]
    pub const EVENT_USER: auto_event = 101;
    #[c2rust::src_loc = "102:3"]
    pub const EVENT_UILEAVE: auto_event = 100;
    #[c2rust::src_loc = "101:3"]
    pub const EVENT_UIENTER: auto_event = 99;
    #[c2rust::src_loc = "100:3"]
    pub const EVENT_TEXTYANKPOST: auto_event = 98;
    #[c2rust::src_loc = "99:3"]
    pub const EVENT_TEXTCHANGEDP: auto_event = 97;
    #[c2rust::src_loc = "98:3"]
    pub const EVENT_TEXTCHANGEDI: auto_event = 96;
    #[c2rust::src_loc = "97:3"]
    pub const EVENT_TEXTCHANGED: auto_event = 95;
    #[c2rust::src_loc = "96:3"]
    pub const EVENT_TERMRESPONSE: auto_event = 94;
    #[c2rust::src_loc = "95:3"]
    pub const EVENT_TERMOPEN: auto_event = 93;
    #[c2rust::src_loc = "94:3"]
    pub const EVENT_TERMLEAVE: auto_event = 92;
    #[c2rust::src_loc = "93:3"]
    pub const EVENT_TERMENTER: auto_event = 91;
    #[c2rust::src_loc = "92:3"]
    pub const EVENT_TERMCLOSE: auto_event = 90;
    #[c2rust::src_loc = "91:3"]
    pub const EVENT_TERMCHANGED: auto_event = 89;
    #[c2rust::src_loc = "90:3"]
    pub const EVENT_TABNEWENTERED: auto_event = 88;
    #[c2rust::src_loc = "89:3"]
    pub const EVENT_TABNEW: auto_event = 87;
    #[c2rust::src_loc = "88:3"]
    pub const EVENT_TABLEAVE: auto_event = 86;
    #[c2rust::src_loc = "87:3"]
    pub const EVENT_TABENTER: auto_event = 85;
    #[c2rust::src_loc = "86:3"]
    pub const EVENT_TABCLOSED: auto_event = 84;
    #[c2rust::src_loc = "85:3"]
    pub const EVENT_SYNTAX: auto_event = 83;
    #[c2rust::src_loc = "84:3"]
    pub const EVENT_SWAPEXISTS: auto_event = 82;
    #[c2rust::src_loc = "83:3"]
    pub const EVENT_STDINREADPRE: auto_event = 81;
    #[c2rust::src_loc = "82:3"]
    pub const EVENT_STDINREADPOST: auto_event = 80;
    #[c2rust::src_loc = "81:3"]
    pub const EVENT_SPELLFILEMISSING: auto_event = 79;
    #[c2rust::src_loc = "80:3"]
    pub const EVENT_SOURCEPRE: auto_event = 78;
    #[c2rust::src_loc = "79:3"]
    pub const EVENT_SOURCEPOST: auto_event = 77;
    #[c2rust::src_loc = "78:3"]
    pub const EVENT_SOURCECMD: auto_event = 76;
    #[c2rust::src_loc = "77:3"]
    pub const EVENT_SIGNAL: auto_event = 75;
    #[c2rust::src_loc = "76:3"]
    pub const EVENT_SHELLFILTERPOST: auto_event = 74;
    #[c2rust::src_loc = "75:3"]
    pub const EVENT_SHELLCMDPOST: auto_event = 73;
    #[c2rust::src_loc = "74:3"]
    pub const EVENT_SESSIONLOADPOST: auto_event = 72;
    #[c2rust::src_loc = "73:3"]
    pub const EVENT_REMOTEREPLY: auto_event = 71;
    #[c2rust::src_loc = "72:3"]
    pub const EVENT_QUITPRE: auto_event = 70;
    #[c2rust::src_loc = "71:3"]
    pub const EVENT_QUICKFIXCMDPRE: auto_event = 69;
    #[c2rust::src_loc = "70:3"]
    pub const EVENT_QUICKFIXCMDPOST: auto_event = 68;
    #[c2rust::src_loc = "69:3"]
    pub const EVENT_OPTIONSET: auto_event = 67;
    #[c2rust::src_loc = "68:3"]
    pub const EVENT_MENUPOPUP: auto_event = 66;
    #[c2rust::src_loc = "67:3"]
    pub const EVENT_INSERTLEAVE: auto_event = 65;
    #[c2rust::src_loc = "66:3"]
    pub const EVENT_INSERTENTER: auto_event = 64;
    #[c2rust::src_loc = "65:3"]
    pub const EVENT_INSERTCHARPRE: auto_event = 63;
    #[c2rust::src_loc = "64:3"]
    pub const EVENT_INSERTCHANGE: auto_event = 62;
    #[c2rust::src_loc = "63:3"]
    pub const EVENT_GUIFAILED: auto_event = 61;
    #[c2rust::src_loc = "62:3"]
    pub const EVENT_GUIENTER: auto_event = 60;
    #[c2rust::src_loc = "61:3"]
    pub const EVENT_FUNCUNDEFINED: auto_event = 59;
    #[c2rust::src_loc = "60:3"]
    pub const EVENT_FOCUSLOST: auto_event = 58;
    #[c2rust::src_loc = "59:3"]
    pub const EVENT_FOCUSGAINED: auto_event = 57;
    #[c2rust::src_loc = "58:3"]
    pub const EVENT_FILTERWRITEPRE: auto_event = 56;
    #[c2rust::src_loc = "57:3"]
    pub const EVENT_FILTERWRITEPOST: auto_event = 55;
    #[c2rust::src_loc = "56:3"]
    pub const EVENT_FILTERREADPRE: auto_event = 54;
    #[c2rust::src_loc = "55:3"]
    pub const EVENT_FILTERREADPOST: auto_event = 53;
    #[c2rust::src_loc = "54:3"]
    pub const EVENT_FILEWRITEPRE: auto_event = 52;
    #[c2rust::src_loc = "53:3"]
    pub const EVENT_FILEWRITEPOST: auto_event = 51;
    #[c2rust::src_loc = "52:3"]
    pub const EVENT_FILEWRITECMD: auto_event = 50;
    #[c2rust::src_loc = "51:3"]
    pub const EVENT_FILETYPE: auto_event = 49;
    #[c2rust::src_loc = "50:3"]
    pub const EVENT_FILEREADPRE: auto_event = 48;
    #[c2rust::src_loc = "49:3"]
    pub const EVENT_FILEREADPOST: auto_event = 47;
    #[c2rust::src_loc = "48:3"]
    pub const EVENT_FILEREADCMD: auto_event = 46;
    #[c2rust::src_loc = "47:3"]
    pub const EVENT_FILECHANGEDSHELLPOST: auto_event = 45;
    #[c2rust::src_loc = "46:3"]
    pub const EVENT_FILECHANGEDSHELL: auto_event = 44;
    #[c2rust::src_loc = "45:3"]
    pub const EVENT_FILECHANGEDRO: auto_event = 43;
    #[c2rust::src_loc = "44:3"]
    pub const EVENT_FILEAPPENDPRE: auto_event = 42;
    #[c2rust::src_loc = "43:3"]
    pub const EVENT_FILEAPPENDPOST: auto_event = 41;
    #[c2rust::src_loc = "42:3"]
    pub const EVENT_FILEAPPENDCMD: auto_event = 40;
    #[c2rust::src_loc = "41:3"]
    pub const EVENT_EXITPRE: auto_event = 39;
    #[c2rust::src_loc = "40:3"]
    pub const EVENT_ENCODINGCHANGED: auto_event = 38;
    #[c2rust::src_loc = "39:3"]
    pub const EVENT_DIRCHANGED: auto_event = 37;
    #[c2rust::src_loc = "38:3"]
    pub const EVENT_DIFFUPDATED: auto_event = 36;
    #[c2rust::src_loc = "37:3"]
    pub const EVENT_CURSORMOVEDI: auto_event = 35;
    #[c2rust::src_loc = "36:3"]
    pub const EVENT_CURSORMOVED: auto_event = 34;
    #[c2rust::src_loc = "35:3"]
    pub const EVENT_CURSORHOLDI: auto_event = 33;
    #[c2rust::src_loc = "34:3"]
    pub const EVENT_CURSORHOLD: auto_event = 32;
    #[c2rust::src_loc = "33:3"]
    pub const EVENT_COMPLETEDONEPRE: auto_event = 31;
    #[c2rust::src_loc = "32:3"]
    pub const EVENT_COMPLETEDONE: auto_event = 30;
    #[c2rust::src_loc = "31:3"]
    pub const EVENT_COMPLETECHANGED: auto_event = 29;
    #[c2rust::src_loc = "30:3"]
    pub const EVENT_COLORSCHEMEPRE: auto_event = 28;
    #[c2rust::src_loc = "29:3"]
    pub const EVENT_COLORSCHEME: auto_event = 27;
    #[c2rust::src_loc = "28:3"]
    pub const EVENT_CMDLINELEAVE: auto_event = 26;
    #[c2rust::src_loc = "27:3"]
    pub const EVENT_CMDLINEENTER: auto_event = 25;
    #[c2rust::src_loc = "26:3"]
    pub const EVENT_CMDLINECHANGED: auto_event = 24;
    #[c2rust::src_loc = "25:3"]
    pub const EVENT_CMDWINLEAVE: auto_event = 23;
    #[c2rust::src_loc = "24:3"]
    pub const EVENT_CMDWINENTER: auto_event = 22;
    #[c2rust::src_loc = "23:3"]
    pub const EVENT_CMDUNDEFINED: auto_event = 21;
    #[c2rust::src_loc = "22:3"]
    pub const EVENT_CHANOPEN: auto_event = 20;
    #[c2rust::src_loc = "21:3"]
    pub const EVENT_CHANINFO: auto_event = 19;
    #[c2rust::src_loc = "20:3"]
    pub const EVENT_BUFWRITEPRE: auto_event = 18;
    #[c2rust::src_loc = "19:3"]
    pub const EVENT_BUFWRITEPOST: auto_event = 17;
    #[c2rust::src_loc = "18:3"]
    pub const EVENT_BUFWRITECMD: auto_event = 16;
    #[c2rust::src_loc = "17:3"]
    pub const EVENT_BUFWIPEOUT: auto_event = 15;
    #[c2rust::src_loc = "16:3"]
    pub const EVENT_BUFWINLEAVE: auto_event = 14;
    #[c2rust::src_loc = "15:3"]
    pub const EVENT_BUFWINENTER: auto_event = 13;
    #[c2rust::src_loc = "14:3"]
    pub const EVENT_BUFUNLOAD: auto_event = 12;
    #[c2rust::src_loc = "13:3"]
    pub const EVENT_BUFREADPRE: auto_event = 11;
    #[c2rust::src_loc = "12:3"]
    pub const EVENT_BUFREADPOST: auto_event = 10;
    #[c2rust::src_loc = "11:3"]
    pub const EVENT_BUFREADCMD: auto_event = 9;
    #[c2rust::src_loc = "10:3"]
    pub const EVENT_BUFNEWFILE: auto_event = 8;
    #[c2rust::src_loc = "9:3"]
    pub const EVENT_BUFNEW: auto_event = 7;
    #[c2rust::src_loc = "8:3"]
    pub const EVENT_BUFLEAVE: auto_event = 6;
    #[c2rust::src_loc = "7:3"]
    pub const EVENT_BUFHIDDEN: auto_event = 5;
    #[c2rust::src_loc = "6:3"]
    pub const EVENT_BUFFILEPRE: auto_event = 4;
    #[c2rust::src_loc = "5:3"]
    pub const EVENT_BUFFILEPOST: auto_event = 3;
    #[c2rust::src_loc = "4:3"]
    pub const EVENT_BUFENTER: auto_event = 2;
    #[c2rust::src_loc = "3:3"]
    pub const EVENT_BUFDELETE: auto_event = 1;
    #[c2rust::src_loc = "2:3"]
    pub const EVENT_BUFADD: auto_event = 0;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/option.h:63"]
pub mod option_h {
    #[c2rust::src_loc = "18:3"]
    pub const OPT_LOCAL: C2RustUnnamed_34 = 4;
    #[c2rust::src_loc = "15:9"]
    pub type C2RustUnnamed_34 = libc::c_uint;
    #[c2rust::src_loc = "21:3"]
    pub const OPT_NOWIN: C2RustUnnamed_34 = 32;
    #[c2rust::src_loc = "20:3"]
    pub const OPT_WINONLY: C2RustUnnamed_34 = 16;
    #[c2rust::src_loc = "19:3"]
    pub const OPT_MODELINE: C2RustUnnamed_34 = 8;
    #[c2rust::src_loc = "17:3"]
    pub const OPT_GLOBAL: C2RustUnnamed_34 = 2;
    #[c2rust::src_loc = "16:3"]
    pub const OPT_FREE: C2RustUnnamed_34 = 1;
    // NVIM_OPTION_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/path.h:65"]
pub mod path_h {
    #[c2rust::src_loc = "32:3"]
    pub const kEqualFiles: file_comparison = 1;
    /* Flags for expand_wildcards() */
    /* include directory names */
    /* include file names */
    /* include not found names */
    /* append slash to directory name */
    /* keep all matches */
    /* don't print "1 returned" from shell */
    /* executable files */
    /* search in 'path' too */
    /* ignore case */
    /* no error for bad regexp */
    /* add match with literal name if exists */
    /* do not escape $, $var is expanded */
    /* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
* is used when executing commands and EW_SILENT for interactive expanding. */
    // also links not pointing to existing file
    // called from expand_shellcmd(), don't check
                                 //  if executable is in $PATH
    // also files starting with a dot
    // no matches is not an error
    // do not expand environment variables
    // / Return value for the comparison of two files. Also @see path_full_compare.
    #[c2rust::src_loc = "31:1"]
    pub type FileComparison = file_comparison;
    #[c2rust::src_loc = "31:9"]
    pub type file_comparison = libc::c_uint;
    #[c2rust::src_loc = "36:3"]
    pub const kEqualFileNames: file_comparison = 7;
    #[c2rust::src_loc = "35:3"]
    pub const kOneFileMissing: file_comparison = 6;
    #[c2rust::src_loc = "34:3"]
    pub const kBothFilesMissing: file_comparison = 4;
    #[c2rust::src_loc = "33:3"]
    pub const kDifferentFiles: file_comparison = 2;
    #[c2rust::src_loc = "10:9"]
    pub const EW_FILE: libc::c_int = 0x2 as libc::c_int;
    #[c2rust::src_loc = "13:9"]
    pub const EW_KEEPALL: libc::c_int = 0x10 as libc::c_int;
    #[c2rust::src_loc = "14:9"]
    pub const EW_SILENT: libc::c_int = 0x20 as libc::c_int;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/rbuffer.h:49"]
pub mod rbuffer_h {
    // /< Both exist and are the same file.
    // /< Both exist and are different files.
    // /< Both don't exist.
    // /< One of them doesn't exist.
    // /< Both don't exist and file names are same.
    // Specialized ring buffer. This is basically an array that wraps read/write
// pointers around the memory region. It should be more efficient than the old
// RBuffer which required memmove() calls to relocate read/write positions.
//
// The main purpose of RBuffer is simplify memory management when reading from
// uv_stream_t instances:
//
// - The event loop writes data to a RBuffer, advancing the write pointer
// - The main loop reads data, advancing the read pointer
// - If the buffer becomes full(size == capacity) the rstream is temporarily
//   stopped(automatic backpressure handling)
//
// Reference: http://en.wikipedia.org/wiki/Circular_buffer
    // Macros that simplify working with the read/write pointers directly by hiding
// ring buffer wrap logic. Some examples:
//
// - Pass the write pointer to a function(write_data) that incrementally
//   produces data, returning the number of bytes actually written to the
//   ring buffer:
//
//       RBUFFER_UNTIL_FULL(rbuf, ptr, cnt)
//         rbuffer_produced(rbuf, write_data(state, ptr, cnt));
//
// - Pass the read pointer to a function(read_data) that incrementally
//   consumes data, returning the number of bytes actually read from the
//   ring buffer:
//
//       RBUFFER_UNTIL_EMPTY(rbuf, ptr, cnt)
//         rbuffer_consumed(rbuf, read_data(state, ptr, cnt));
//
// Note that the rbuffer_{produced,consumed} calls are necessary or these macros
// create infinite loops
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    // Iteration
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    /* NOLINT(readability/braces) */
    // / Type of function invoked during certain events:
// /   - When the RBuffer switches to the full state
// /   - When the RBuffer switches to the non-full state
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "77:8"]
    pub struct rbuffer {
        pub full_cb: rbuffer_callback,
        pub nonfull_cb: rbuffer_callback,
        pub data: *mut libc::c_void,
        pub size: size_t,
        pub temp: *mut libc::c_char,
        pub end_ptr: *mut libc::c_char,
        pub read_ptr: *mut libc::c_char,
        pub write_ptr: *mut libc::c_char,
        pub start_ptr: [libc::c_char; 0],
    }
    #[c2rust::src_loc = "75:1"]
    pub type rbuffer_callback
        =
        Option<unsafe extern "C" fn(_: *mut RBuffer, _: *mut libc::c_void)
                   -> ()>;
    #[c2rust::src_loc = "71:1"]
    pub type RBuffer = rbuffer;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "89:1"]
        pub fn rbuffer_size(buf: *mut RBuffer) -> size_t;
    }
    // NVIM_RBUFFER_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/stream.h:49"]
pub mod stream_h {
    // / Type of function called when the Stream buffer is filled with data
// /
// / @param stream The Stream instance
// / @param buf The associated RBuffer instance
// / @param count Number of bytes that was read.
// / @param data User-defined data
// / @param eof If the stream reached EOF.
    // / Type of function called when the Stream has information about a write
// / request.
// /
// / @param stream The Stream instance
// / @param data User-defined data
// / @param status 0 on success, anything else indicates failure
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:8"]
    pub struct stream {
        pub closed: bool,
        pub did_eof: bool,
        pub uv: C2RustUnnamed_29,
        pub uvstream: *mut uv_stream_t,
        pub uvbuf: uv_buf_t,
        pub buffer: *mut RBuffer,
        pub fd: uv_file,
        pub read_cb: stream_read_cb,
        pub write_cb: stream_write_cb,
        pub cb_data: *mut libc::c_void,
        pub close_cb: stream_close_cb,
        pub internal_close_cb: stream_close_cb,
        pub close_cb_data: *mut libc::c_void,
        pub internal_data: *mut libc::c_void,
        pub fpos: size_t,
        pub curmem: size_t,
        pub maxmem: size_t,
        pub pending_reqs: size_t,
        pub num_bytes: size_t,
        pub events: *mut MultiQueue,
    }
    #[c2rust::src_loc = "30:1"]
    pub type stream_close_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut libc::c_void)
                   -> ()>;
    #[c2rust::src_loc = "12:1"]
    pub type Stream = stream;
    #[c2rust::src_loc = "29:1"]
    pub type stream_write_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut libc::c_void,
                                    _: libc::c_int) -> ()>;
    #[c2rust::src_loc = "20:1"]
    pub type stream_read_cb
        =
        Option<unsafe extern "C" fn(_: *mut Stream, _: *mut RBuffer,
                                    _: size_t, _: *mut libc::c_void, _: bool)
                   -> ()>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "35:3"]
    pub union C2RustUnnamed_29 {
        pub pipe: uv_pipe_t,
        pub tcp: uv_tcp_t,
        pub idle: uv_idle_t,
    }
    use super::uv_h::{uv_stream_t, uv_pipe_t, uv_tcp_t, uv_idle_t};
    use super::unix_h::{uv_buf_t, uv_file};
    use super::rbuffer_h::RBuffer;
    use super::stddef_h::size_t;
    use super::multiqueue_h::MultiQueue;
    // NVIM_EVENT_STREAM_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/process.h:49"]
pub mod process_h {
    #[c2rust::src_loc = "8:9"]
    pub type ProcessType = libc::c_uint;
    #[c2rust::src_loc = "10:3"]
    pub const kProcessTypePty: ProcessType = 1;
    #[c2rust::src_loc = "9:3"]
    pub const kProcessTypeUv: ProcessType = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "17:8"]
    pub struct process {
        pub type_0: ProcessType,
        pub loop_0: *mut Loop,
        pub data: *mut libc::c_void,
        pub pid: libc::c_int,
        pub status: libc::c_int,
        pub refcount: libc::c_int,
        pub exit_signal: uint8_t,
        pub stopped_time: uint64_t,
        pub cwd: *const libc::c_char,
        pub argv: *mut *mut libc::c_char,
        pub env: *mut *mut libc::c_char,
        pub in_0: Stream,
        pub out: Stream,
        pub err: Stream,
        pub cb: process_exit_cb,
        pub internal_exit_cb: internal_process_cb,
        pub internal_close_cb: internal_process_cb,
        pub closed: bool,
        pub detach: bool,
        pub events: *mut MultiQueue,
    }
    #[c2rust::src_loc = "15:1"]
    pub type internal_process_cb
        =
        Option<unsafe extern "C" fn(_: *mut Process) -> ()>;
    #[c2rust::src_loc = "13:1"]
    pub type Process = process;
    #[c2rust::src_loc = "14:1"]
    pub type process_exit_cb
        =
        Option<unsafe extern "C" fn(_: *mut Process, _: libc::c_int,
                                    _: *mut libc::c_void) -> ()>;
    #[inline]
    #[c2rust::src_loc = "35:1"]
    pub unsafe extern "C" fn process_init(mut loop_0: *mut Loop,
                                          mut type_0: ProcessType,
                                          mut data: *mut libc::c_void)
     -> Process {
        return {
                   let mut init =
                       process{type_0: type_0,
                               loop_0: loop_0,
                               data: data,
                               pid: 0 as libc::c_int,
                               status: -(1 as libc::c_int),
                               refcount: 0 as libc::c_int,
                               exit_signal: 0,
                               stopped_time: 0 as libc::c_int as uint64_t,
                               cwd: NULL_1 as *const libc::c_char,
                               argv: NULL_1 as *mut *mut libc::c_char,
                               env: 0 as *mut *mut libc::c_char,
                               in_0:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_29{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               out:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_29{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               err:
                                   {
                                       let mut init =
                                           stream{closed: false_0 != 0,
                                                  did_eof: false,
                                                  uv:
                                                      C2RustUnnamed_29{pipe:
                                                                           uv_pipe_t{data:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     loop_0:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_loop_t,
                                                                                     type_0:
                                                                                         UV_UNKNOWN_HANDLE,
                                                                                     close_cb:
                                                                                         None,
                                                                                     handle_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     u:
                                                                                         C2RustUnnamed_23{fd:
                                                                                                              0,},
                                                                                     next_closing:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_handle_t,
                                                                                     flags:
                                                                                         0,
                                                                                     write_queue_size:
                                                                                         0,
                                                                                     alloc_cb:
                                                                                         None,
                                                                                     read_cb:
                                                                                         None,
                                                                                     connect_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_connect_t,
                                                                                     shutdown_req:
                                                                                         0
                                                                                             as
                                                                                             *mut uv_shutdown_t,
                                                                                     io_watcher:
                                                                                         uv__io_t{cb:
                                                                                                      None,
                                                                                                  pending_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  watcher_queue:
                                                                                                      [0
                                                                                                           as
                                                                                                           *mut libc::c_void;
                                                                                                          2],
                                                                                                  pevents:
                                                                                                      0,
                                                                                                  events:
                                                                                                      0,
                                                                                                  fd:
                                                                                                      0,},
                                                                                     write_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     write_completed_queue:
                                                                                         [0
                                                                                              as
                                                                                              *mut libc::c_void;
                                                                                             2],
                                                                                     connection_cb:
                                                                                         None,
                                                                                     delayed_error:
                                                                                         0,
                                                                                     accepted_fd:
                                                                                         0,
                                                                                     queued_fds:
                                                                                         0
                                                                                             as
                                                                                             *mut libc::c_void,
                                                                                     ipc:
                                                                                         0,
                                                                                     pipe_fname:
                                                                                         0
                                                                                             as
                                                                                             *const libc::c_char,},},
                                                  uvstream:
                                                      0 as *mut uv_stream_t,
                                                  uvbuf:
                                                      uv_buf_t{base:
                                                                   0 as
                                                                       *mut libc::c_char,
                                                               len: 0,},
                                                  buffer: 0 as *mut RBuffer,
                                                  fd: 0,
                                                  read_cb: None,
                                                  write_cb: None,
                                                  cb_data:
                                                      0 as *mut libc::c_void,
                                                  close_cb: None,
                                                  internal_close_cb: None,
                                                  close_cb_data:
                                                      0 as *mut libc::c_void,
                                                  internal_data:
                                                      0 as *mut libc::c_void,
                                                  fpos: 0,
                                                  curmem: 0,
                                                  maxmem: 0,
                                                  pending_reqs: 0,
                                                  num_bytes: 0,
                                                  events:
                                                      0 as *mut MultiQueue,};
                                       init
                                   },
                               cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           process_exit_cb>(NULL_1
                                                                                as
                                                                                libc::intptr_t),
                               internal_exit_cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           internal_process_cb>(NULL_1
                                                                                    as
                                                                                    libc::intptr_t),
                               internal_close_cb:
                                   ::std::mem::transmute::<libc::intptr_t,
                                                           internal_process_cb>(NULL_1
                                                                                    as
                                                                                    libc::intptr_t),
                               closed: false_0 != 0,
                               detach: false_0 != 0,
                               events: NULL_1 as *mut MultiQueue,};
                   init
               };
    }
    #[inline]
    #[c2rust::src_loc = "59:1"]
    pub unsafe extern "C" fn process_is_stopped(mut proc_0: *mut Process)
     -> bool {
        let mut exited = (*proc_0).status >= 0 as libc::c_int;
        return exited as libc::c_int != 0 ||
                   (*proc_0).stopped_time !=
                       0 as libc::c_int as libc::c_ulong;
    }
    use super::loop_h::Loop;
    use super::stdint_uintn_h::{uint8_t, uint64_t};
    use super::stream_h::{Stream, C2RustUnnamed_29, stream_read_cb,
                          stream_write_cb, stream_close_cb};
    use super::multiqueue_h::MultiQueue;
    use super::stddef_h::{NULL_1, size_t};
    use super::uv_h::{uv_stream_t, uv_pipe_t, uv_loop_t, uv_handle_type,
                      uv_close_cb, C2RustUnnamed_23, uv_handle_t, uv_alloc_cb,
                      uv_read_cb, uv_connect_t, uv_shutdown_t,
                      uv_connection_cb, UV_UNKNOWN_HANDLE};
    use super::unix_h::{uv_buf_t, uv_file, uv__io_t, uv__io_cb};
    use super::rbuffer_h::RBuffer;
    use super::stdbool_h::false_0;
    // NVIM_EVENT_PROCESS_H
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h:49"]
pub mod ioctl_types_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:8"]
    pub struct winsize {
        pub ws_row: libc::c_ushort,
        pub ws_col: libc::c_ushort,
        pub ws_xpixel: libc::c_ushort,
        pub ws_ypixel: libc::c_ushort,
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/pty_process_unix.h:49"]
pub mod pty_process_unix_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "8:16"]
    pub struct pty_process {
        pub process: Process,
        pub term_name: *mut libc::c_char,
        pub width: uint16_t,
        pub height: uint16_t,
        pub winsize: winsize,
        pub tty_fd: libc::c_int,
    }
    #[c2rust::src_loc = "8:1"]
    pub type PtyProcess = pty_process;
    #[inline]
    #[c2rust::src_loc = "16:1"]
    pub unsafe extern "C" fn pty_process_init(mut loop_0: *mut Loop,
                                              mut data: *mut libc::c_void)
     -> PtyProcess {
        let mut rv =
            PtyProcess{process:
                           Process{type_0: kProcessTypeUv,
                                   loop_0: 0 as *mut Loop,
                                   data: 0 as *mut libc::c_void,
                                   pid: 0,
                                   status: 0,
                                   refcount: 0,
                                   exit_signal: 0,
                                   stopped_time: 0,
                                   cwd: 0 as *const libc::c_char,
                                   argv: 0 as *mut *mut libc::c_char,
                                   env: 0 as *mut *mut libc::c_char,
                                   in_0:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_29{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   out:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_29{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   err:
                                       Stream{closed: false,
                                              did_eof: false,
                                              uv:
                                                  C2RustUnnamed_29{pipe:
                                                                       uv_pipe_t{data:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 loop_0:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_loop_t,
                                                                                 type_0:
                                                                                     UV_UNKNOWN_HANDLE,
                                                                                 close_cb:
                                                                                     None,
                                                                                 handle_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 u:
                                                                                     C2RustUnnamed_23{fd:
                                                                                                          0,},
                                                                                 next_closing:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_handle_t,
                                                                                 flags:
                                                                                     0,
                                                                                 write_queue_size:
                                                                                     0,
                                                                                 alloc_cb:
                                                                                     None,
                                                                                 read_cb:
                                                                                     None,
                                                                                 connect_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_connect_t,
                                                                                 shutdown_req:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_shutdown_t,
                                                                                 io_watcher:
                                                                                     uv__io_t{cb:
                                                                                                  None,
                                                                                              pending_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              watcher_queue:
                                                                                                  [0
                                                                                                       as
                                                                                                       *mut libc::c_void;
                                                                                                      2],
                                                                                              pevents:
                                                                                                  0,
                                                                                              events:
                                                                                                  0,
                                                                                              fd:
                                                                                                  0,},
                                                                                 write_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 write_completed_queue:
                                                                                     [0
                                                                                          as
                                                                                          *mut libc::c_void;
                                                                                         2],
                                                                                 connection_cb:
                                                                                     None,
                                                                                 delayed_error:
                                                                                     0,
                                                                                 accepted_fd:
                                                                                     0,
                                                                                 queued_fds:
                                                                                     0
                                                                                         as
                                                                                         *mut libc::c_void,
                                                                                 ipc:
                                                                                     0,
                                                                                 pipe_fname:
                                                                                     0
                                                                                         as
                                                                                         *const libc::c_char,},},
                                              uvstream: 0 as *mut uv_stream_t,
                                              uvbuf:
                                                  uv_buf_t{base:
                                                               0 as
                                                                   *mut libc::c_char,
                                                           len: 0,},
                                              buffer: 0 as *mut RBuffer,
                                              fd: 0,
                                              read_cb: None,
                                              write_cb: None,
                                              cb_data: 0 as *mut libc::c_void,
                                              close_cb: None,
                                              internal_close_cb: None,
                                              close_cb_data:
                                                  0 as *mut libc::c_void,
                                              internal_data:
                                                  0 as *mut libc::c_void,
                                              fpos: 0,
                                              curmem: 0,
                                              maxmem: 0,
                                              pending_reqs: 0,
                                              num_bytes: 0,
                                              events: 0 as *mut MultiQueue,},
                                   cb: None,
                                   internal_exit_cb: None,
                                   internal_close_cb: None,
                                   closed: false,
                                   detach: false,
                                   events: 0 as *mut MultiQueue,},
                       term_name: 0 as *mut libc::c_char,
                       width: 0,
                       height: 0,
                       winsize:
                           winsize{ws_row: 0,
                                   ws_col: 0,
                                   ws_xpixel: 0,
                                   ws_ypixel: 0,},
                       tty_fd: 0,};
        rv.process = process_init(loop_0, kProcessTypePty, data);
        rv.term_name = NULL_1 as *mut libc::c_char;
        rv.width = 80 as libc::c_int as uint16_t;
        rv.height = 24 as libc::c_int as uint16_t;
        rv.tty_fd = -(1 as libc::c_int);
        return rv;
    }
    use super::process_h::{Process, ProcessType, process_exit_cb,
                           internal_process_cb, process_init,
                           kProcessTypePty};
    use super::stdint_uintn_h::{uint16_t, uint8_t, uint64_t};
    use super::ioctl_types_h::winsize;
    use super::loop_h::Loop;
    use super::stream_h::{Stream, C2RustUnnamed_29, stream_read_cb,
                          stream_write_cb, stream_close_cb};
    use super::multiqueue_h::MultiQueue;
    use super::uv_h::uv_stream_t;
    use super::unix_h::{uv_buf_t, uv_file};
    use super::rbuffer_h::RBuffer;
    use super::stddef_h::{size_t, NULL_1};
    // NVIM_OS_PTY_PROCESS_UNIX_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/event/libuv_process.h:49"]
pub mod libuv_process_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "8:16"]
    pub struct libuv_process {
        pub process: Process,
        pub uv: uv_process_t,
        pub uvopts: uv_process_options_t,
        pub uvstdio: [uv_stdio_container_t; 3],
    }
    #[c2rust::src_loc = "8:1"]
    pub type LibuvProcess = libuv_process;
    #[inline]
    #[c2rust::src_loc = "15:1"]
    pub unsafe extern "C" fn libuv_process_init(mut loop_0: *mut Loop,
                                                mut data: *mut libc::c_void)
     -> LibuvProcess {
        let mut rv =
            {
                let mut init =
                    libuv_process{process:
                                      process_init(loop_0, kProcessTypeUv,
                                                   data),
                                  uv:
                                      uv_process_t{data:
                                                       0 as *mut libc::c_void,
                                                   loop_0:
                                                       0 as *mut uv_loop_t,
                                                   type_0: UV_UNKNOWN_HANDLE,
                                                   close_cb: None,
                                                   handle_queue:
                                                       [0 as
                                                            *mut libc::c_void;
                                                           2],
                                                   u:
                                                       C2RustUnnamed_26{fd:
                                                                            0,},
                                                   next_closing:
                                                       0 as *mut uv_handle_t,
                                                   flags: 0,
                                                   exit_cb: None,
                                                   pid: 0,
                                                   queue:
                                                       [0 as
                                                            *mut libc::c_void;
                                                           2],
                                                   status: 0,},
                                  uvopts:
                                      uv_process_options_t{exit_cb: None,
                                                           file:
                                                               0 as
                                                                   *const libc::c_char,
                                                           args:
                                                               0 as
                                                                   *mut *mut libc::c_char,
                                                           env:
                                                               0 as
                                                                   *mut *mut libc::c_char,
                                                           cwd:
                                                               0 as
                                                                   *const libc::c_char,
                                                           flags: 0,
                                                           stdio_count: 0,
                                                           stdio:
                                                               0 as
                                                                   *mut uv_stdio_container_t,
                                                           uid: 0,
                                                           gid: 0,},
                                  uvstdio:
                                      [uv_stdio_container_t{flags: UV_IGNORE,
                                                            data:
                                                                C2RustUnnamed_27{stream:
                                                                                     0
                                                                                         as
                                                                                         *mut uv_stream_t,},};
                                          3],};
                init
            };
        return rv;
    }
    use super::process_h::{Process, process_init, kProcessTypeUv,
                           ProcessType};
    use super::uv_h::{uv_process_t, uv_process_options_t,
                      uv_stdio_container_t, uv_loop_t, uv_handle_type,
                      uv_close_cb, C2RustUnnamed_26, uv_handle_t, uv_exit_cb,
                      uv_stdio_flags, C2RustUnnamed_27, UV_IGNORE,
                      uv_stream_t};
    use super::loop_h::Loop;
    use super::unix_h::{uv_uid_t, uv_gid_t};
    // NVIM_EVENT_LIBUV_PROCESS_H
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/zone.h:49"]
pub mod zone_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "26:16"]
    pub struct msgpack_zone_finalizer {
        pub func: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
        pub data: *mut libc::c_void,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "31:16"]
    pub struct msgpack_zone_finalizer_array {
        pub tail: *mut msgpack_zone_finalizer,
        pub end: *mut msgpack_zone_finalizer,
        pub array: *mut msgpack_zone_finalizer,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "40:16"]
    pub struct msgpack_zone_chunk_list {
        pub free: size_t,
        pub ptr: *mut libc::c_char,
        pub head: *mut msgpack_zone_chunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "46:16"]
    pub struct msgpack_zone {
        pub chunk_list: msgpack_zone_chunk_list,
        pub finalizer_array: msgpack_zone_finalizer_array,
        pub chunk_size: size_t,
    }
    #[inline]
    #[c2rust::src_loc = "106:1"]
    pub unsafe extern "C" fn msgpack_zone_malloc(mut zone: *mut msgpack_zone,
                                                 mut size: size_t)
     -> *mut libc::c_void {
        let mut aligned =
            ((*zone).chunk_list.ptr.offset(MSGPACK_ZONE_ALIGN.wrapping_sub(1
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               libc::c_ulong)
                                               as isize) as
                 size_t).wrapping_div(MSGPACK_ZONE_ALIGN).wrapping_mul(MSGPACK_ZONE_ALIGN)
                as *mut libc::c_char;
        let mut adjusted_size =
            size.wrapping_add(aligned.wrapping_offset_from((*zone).chunk_list.ptr)
                                  as libc::c_long as libc::c_ulong);
        if (*zone).chunk_list.free >= adjusted_size {
            (*zone).chunk_list.free =
                ((*zone).chunk_list.free as
                     libc::c_ulong).wrapping_sub(adjusted_size) as size_t as
                    size_t;
            (*zone).chunk_list.ptr =
                (*zone).chunk_list.ptr.offset(adjusted_size as isize);
            return aligned as *mut libc::c_void
        }
        let mut ptr =
            msgpack_zone_malloc_expand(zone,
                                       size.wrapping_add(MSGPACK_ZONE_ALIGN.wrapping_sub(1
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_ulong)));
        if !ptr.is_null() {
            return (ptr as
                        size_t).wrapping_div(MSGPACK_ZONE_ALIGN).wrapping_mul(MSGPACK_ZONE_ALIGN)
                       as *mut libc::c_char as *mut libc::c_void
        }
        return NULL_1 as *mut libc::c_void;
    }
    #[c2rust::src_loc = "84:9"]
    pub const MSGPACK_ZONE_ALIGN: libc::c_ulong =
        ::std::mem::size_of::<*mut libc::c_void>() as libc::c_ulong;
    #[inline]
    #[c2rust::src_loc = "90:1"]
    pub unsafe extern "C" fn msgpack_zone_malloc_no_align(mut zone:
                                                              *mut msgpack_zone,
                                                          mut size: size_t)
     -> *mut libc::c_void {
        let mut ptr = 0 as *mut libc::c_char;
        let mut cl: *mut msgpack_zone_chunk_list = &mut (*zone).chunk_list;
        if (*zone).chunk_list.free < size {
            return msgpack_zone_malloc_expand(zone, size)
        }
        ptr = (*cl).ptr;
        (*cl).free =
            ((*cl).free as libc::c_ulong).wrapping_sub(size) as size_t as
                size_t;
        (*cl).ptr = (*cl).ptr.offset(size as isize);
        return ptr as *mut libc::c_void;
    }
    #[inline]
    #[c2rust::src_loc = "133:1"]
    pub unsafe extern "C" fn msgpack_zone_push_finalizer(mut zone:
                                                             *mut msgpack_zone,
                                                         mut func:
                                                             Option<unsafe extern "C" fn(_:
                                                                                             *mut libc::c_void)
                                                                        ->
                                                                            ()>,
                                                         mut data:
                                                             *mut libc::c_void)
     -> bool {
        let fa: *mut msgpack_zone_finalizer_array =
            &mut (*zone).finalizer_array;
        let mut fin = (*fa).tail;
        if fin == (*fa).end {
            return msgpack_zone_push_finalizer_expand(zone, func, data)
        }
        (*fin).func = func;
        (*fin).data = data;
        (*fa).tail = (*fa).tail.offset(1);
        return true_0 != 0;
    }
    #[inline]
    #[c2rust::src_loc = "151:1"]
    pub unsafe extern "C" fn msgpack_zone_swap(mut a: *mut msgpack_zone,
                                               mut b: *mut msgpack_zone) {
        let mut tmp = *a;
        *a = *b;
        *b = tmp;
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::stdbool_h::true_0;
    extern "C" {
        #[c2rust::src_loc = "37:8"]
        pub type msgpack_zone_chunk;
        #[no_mangle]
        #[c2rust::src_loc = "64:1"]
        pub fn msgpack_zone_free(zone: *mut msgpack_zone);
        #[no_mangle]
        #[c2rust::src_loc = "88:1"]
        pub fn msgpack_zone_malloc_expand(zone: *mut msgpack_zone,
                                          size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "130:1"]
        pub fn msgpack_zone_push_finalizer_expand(zone: *mut msgpack_zone,
                                                  func:
                                                      Option<unsafe extern "C" fn(_:
                                                                                      *mut libc::c_void)
                                                                 -> ()>,
                                                  data: *mut libc::c_void)
         -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/object.h:49"]
pub mod object_h {
    #[c2rust::src_loc = "27:9"]
    pub type msgpack_object_type = libc::c_uint;
    #[c2rust::src_loc = "42:5"]
    pub const MSGPACK_OBJECT_EXT: msgpack_object_type = 9;
    #[c2rust::src_loc = "41:5"]
    pub const MSGPACK_OBJECT_BIN: msgpack_object_type = 8;
    #[c2rust::src_loc = "40:5"]
    pub const MSGPACK_OBJECT_MAP: msgpack_object_type = 7;
    #[c2rust::src_loc = "39:5"]
    pub const MSGPACK_OBJECT_ARRAY: msgpack_object_type = 6;
    #[c2rust::src_loc = "38:5"]
    pub const MSGPACK_OBJECT_STR: msgpack_object_type = 5;
    #[c2rust::src_loc = "34:5"]
    pub const MSGPACK_OBJECT_FLOAT: msgpack_object_type = 4;
    #[c2rust::src_loc = "33:5"]
    pub const MSGPACK_OBJECT_FLOAT64: msgpack_object_type = 4;
    #[c2rust::src_loc = "32:5"]
    pub const MSGPACK_OBJECT_FLOAT32: msgpack_object_type = 10;
    #[c2rust::src_loc = "31:5"]
    pub const MSGPACK_OBJECT_NEGATIVE_INTEGER: msgpack_object_type = 3;
    #[c2rust::src_loc = "30:5"]
    pub const MSGPACK_OBJECT_POSITIVE_INTEGER: msgpack_object_type = 2;
    #[c2rust::src_loc = "29:5"]
    pub const MSGPACK_OBJECT_BOOLEAN: msgpack_object_type = 1;
    #[c2rust::src_loc = "28:5"]
    pub const MSGPACK_OBJECT_NIL: msgpack_object_type = 0;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "90:16"]
    pub struct msgpack_object {
        pub type_0: msgpack_object_type,
        pub via: msgpack_object_union,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "75:9"]
    pub union msgpack_object_union {
        pub boolean: bool,
        pub u64_0: uint64_t,
        pub i64_0: int64_t,
        pub f64_0: libc::c_double,
        pub array: msgpack_object_array,
        pub map: msgpack_object_map,
        pub str_0: msgpack_object_str,
        pub bin: msgpack_object_bin,
        pub ext: msgpack_object_ext,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "69:9"]
    pub struct msgpack_object_ext {
        pub type_0: int8_t,
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "64:9"]
    pub struct msgpack_object_bin {
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "59:9"]
    pub struct msgpack_object_str {
        pub size: uint32_t,
        pub ptr: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "54:9"]
    pub struct msgpack_object_map {
        pub size: uint32_t,
        pub ptr: *mut msgpack_object_kv,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "95:16"]
    pub struct msgpack_object_kv {
        pub key: msgpack_object,
        pub val: msgpack_object,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "49:9"]
    pub struct msgpack_object_array {
        pub size: uint32_t,
        pub ptr: *mut msgpack_object,
    }
    use super::stdint_uintn_h::{uint64_t, uint32_t};
    use super::stdint_intn_h::{int64_t, int8_t};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/pack.h:49"]
pub mod pack_h {
    #[c2rust::src_loc = "35:1"]
    pub type msgpack_packer_write
        =
        Option<unsafe extern "C" fn(_: *mut libc::c_void,
                                    _: *const libc::c_char, _: size_t)
                   -> libc::c_int>;
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:16"]
    pub struct msgpack_packer {
        pub data: *mut libc::c_void,
        pub callback: msgpack_packer_write,
    }
    #[inline]
    #[c2rust::src_loc = "124:1"]
    pub unsafe extern "C" fn msgpack_packer_init(mut pk: *mut msgpack_packer,
                                                 mut data: *mut libc::c_void,
                                                 mut callback:
                                                     msgpack_packer_write) {
        (*pk).data = data;
        (*pk).callback = callback;
    }
    #[inline]
    #[c2rust::src_loc = "130:1"]
    pub unsafe extern "C" fn msgpack_packer_new(mut data: *mut libc::c_void,
                                                mut callback:
                                                    msgpack_packer_write)
     -> *mut msgpack_packer {
        let mut pk =
            calloc(1 as libc::c_int as libc::c_ulong,
                   ::std::mem::size_of::<msgpack_packer>() as libc::c_ulong)
                as *mut msgpack_packer;
        if pk.is_null() { return NULL_1 as *mut msgpack_packer }
        msgpack_packer_init(pk, data, callback);
        return pk;
    }
    #[inline]
    #[c2rust::src_loc = "138:1"]
    pub unsafe extern "C" fn msgpack_packer_free(mut pk:
                                                     *mut msgpack_packer) {
        free(pk as *mut libc::c_void);
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::stdlib_h::{calloc, free};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/pack_template.h:49"]
pub mod pack_template_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "654:5"]
    pub union C2RustUnnamed_30 {
        pub f: libc::c_float,
        pub i: uint32_t,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "663:5"]
    pub union C2RustUnnamed_31 {
        pub f: libc::c_double,
        pub i: uint64_t,
    }
    #[inline]
    #[c2rust::src_loc = "369:1"]
    pub unsafe extern "C" fn msgpack_pack_char(mut x: *mut msgpack_packer,
                                               mut d: libc::c_char)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_char as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_char
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "382:1"]
    pub unsafe extern "C" fn msgpack_pack_signed_char(mut x:
                                                          *mut msgpack_packer,
                                                      mut d: libc::c_schar)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_schar as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_schar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "394:1"]
    pub unsafe extern "C" fn msgpack_pack_short(mut x: *mut msgpack_packer,
                                                mut d: libc::c_short)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            if (d as libc::c_int) < -((1 as libc::c_int) << 7 as libc::c_int)
               {
                let mut buf: [libc::c_uchar; 3] = [0; 3];
                buf[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val = ntohs(d as uint16_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_0: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_short as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_short
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf_1: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_short as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 3] = [0; 3];
            buf_2[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohs(d as uint16_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "425:1"]
    pub unsafe extern "C" fn msgpack_pack_int(mut x: *mut msgpack_packer,
                                              mut d: libc::c_int)
     -> libc::c_int {
        if d < -((1 as libc::c_int) << 5 as libc::c_int) {
            if d < -((1 as libc::c_int) << 15 as libc::c_int) {
                let mut buf: [libc::c_uchar; 5] = [0; 5];
                buf[0 as libc::c_int as usize] =
                    0xd2 as libc::c_int as libc::c_uchar;
                let mut val = ntohl(d as uint32_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint32_t as *const libc::c_void,
                       4 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   5
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else if d < -((1 as libc::c_int) << 7 as libc::c_int) {
                let mut buf_0: [libc::c_uchar; 3] = [0; 3];
                buf_0[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_0 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_0 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_1: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_int as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_int
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 8 as libc::c_int {
            let mut buf_2: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_int as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 16 as libc::c_int {
            let mut buf_3: [libc::c_uchar; 3] = [0; 3];
            buf_3[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_1 = ntohs(d as uint16_t);
            memcpy(&mut *buf_3.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_3.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_4: [libc::c_uchar; 5] = [0; 5];
            buf_4[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_2 = ntohl(d as uint32_t);
            memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_2 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_4.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "456:1"]
    pub unsafe extern "C" fn msgpack_pack_long(mut x: *mut msgpack_packer,
                                               mut d: libc::c_long)
     -> libc::c_int {
        if (d as libc::c_longlong) <
               -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if (d as libc::c_longlong) <
                   -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if (d as libc::c_longlong) <
                       -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_long {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_long as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_long
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_long
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 16 as libc::c_int {
            if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_long {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_long as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "487:1"]
    pub unsafe extern "C" fn msgpack_pack_long_long(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: libc::c_longlong)
     -> libc::c_int {
        if d < -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if d < -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if d < -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_longlong {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_longlong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 7 as libc::c_int) as
                          libc::c_longlong {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_longlong
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_longlong) << 16 as libc::c_int {
            if d <
                   ((1 as libc::c_int) << 8 as libc::c_int) as
                       libc::c_longlong {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_longlong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "387:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_char(mut x:
                                                            *mut msgpack_packer,
                                                        mut d: libc::c_uchar)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_uchar as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "518:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_short(mut x:
                                                             *mut msgpack_packer,
                                                         mut d:
                                                             libc::c_ushort)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_ushort
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut libc::c_ushort as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "549:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_int(mut x:
                                                           *mut msgpack_packer,
                                                       mut d: libc::c_uint)
     -> libc::c_int {
        if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint {
            if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_uint
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_uint as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 16 as libc::c_int) as
                          libc::c_uint {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "580:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_long(mut x:
                                                            *mut msgpack_packer,
                                                        mut d: libc::c_ulong)
     -> libc::c_int {
        if (d as libc::c_ulonglong) <
               (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if (d as libc::c_ulonglong) <
                   (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_ulong
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_ulong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "611:1"]
    pub unsafe extern "C" fn msgpack_pack_unsigned_long_long(mut x:
                                                                 *mut msgpack_packer,
                                                             mut d:
                                                                 libc::c_ulonglong)
     -> libc::c_int {
        if d < (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if d < (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut libc::c_ulonglong
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut libc::c_ulonglong as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "329:1"]
    pub unsafe extern "C" fn msgpack_pack_uint8(mut x: *mut msgpack_packer,
                                                mut d: uint8_t)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "334:1"]
    pub unsafe extern "C" fn msgpack_pack_uint16(mut x: *mut msgpack_packer,
                                                 mut d: uint16_t)
     -> libc::c_int {
        if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut uint16_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut uint16_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "339:1"]
    pub unsafe extern "C" fn msgpack_pack_uint32(mut x: *mut msgpack_packer,
                                                 mut d: uint32_t)
     -> libc::c_int {
        if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_uint {
            if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_uint {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut uint32_t
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut uint32_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d <
                      ((1 as libc::c_int) << 16 as libc::c_int) as
                          libc::c_uint {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "344:1"]
    pub unsafe extern "C" fn msgpack_pack_uint64(mut x: *mut msgpack_packer,
                                                 mut d: uint64_t)
     -> libc::c_int {
        if (d as libc::c_ulonglong) <
               (1 as libc::c_ulonglong) << 8 as libc::c_int {
            if (d as libc::c_ulonglong) <
                   (1 as libc::c_ulonglong) << 7 as libc::c_int {
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   &mut *(&mut d
                                                                                                                              as
                                                                                                                              *mut uint64_t
                                                                                                                              as
                                                                                                                              *mut uint8_t).offset(0
                                                                                                                                                       as
                                                                                                                                                       libc::c_int
                                                                                                                                                       as
                                                                                                                                                       isize)
                                                                                                                       as
                                                                                                                       *mut uint8_t
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   1
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut uint64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 16 as libc::c_int {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val = ntohs(d as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_ulonglong) <
                      (1 as libc::c_ulonglong) << 32 as libc::c_int {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(d as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 9] = [0; 9];
            buf_2[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_1 = __bswap_64(d);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "349:1"]
    pub unsafe extern "C" fn msgpack_pack_int8(mut x: *mut msgpack_packer,
                                               mut d: int8_t) -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            let mut buf: [libc::c_uchar; 2] =
                [0xd0 as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int8_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int8_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "354:1"]
    pub unsafe extern "C" fn msgpack_pack_int16(mut x: *mut msgpack_packer,
                                                mut d: int16_t)
     -> libc::c_int {
        if (d as libc::c_int) < -((1 as libc::c_int) << 5 as libc::c_int) {
            if (d as libc::c_int) < -((1 as libc::c_int) << 7 as libc::c_int)
               {
                let mut buf: [libc::c_uchar; 3] = [0; 3];
                buf[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val = ntohs(d as uint16_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_0: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int16_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_int) < (1 as libc::c_int) << 7 as libc::c_int
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int16_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_int) < (1 as libc::c_int) << 8 as libc::c_int
         {
            let mut buf_1: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int16_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_2: [libc::c_uchar; 3] = [0; 3];
            buf_2[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohs(d as uint16_t);
            memcpy(&mut *buf_2.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "359:1"]
    pub unsafe extern "C" fn msgpack_pack_int32(mut x: *mut msgpack_packer,
                                                mut d: int32_t)
     -> libc::c_int {
        if d < -((1 as libc::c_int) << 5 as libc::c_int) {
            if d < -((1 as libc::c_int) << 15 as libc::c_int) {
                let mut buf: [libc::c_uchar; 5] = [0; 5];
                buf[0 as libc::c_int as usize] =
                    0xd2 as libc::c_int as libc::c_uchar;
                let mut val = ntohl(d as uint32_t);
                memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                         isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val as *mut uint32_t as *const libc::c_void,
                       4 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   5
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else if d < -((1 as libc::c_int) << 7 as libc::c_int) {
                let mut buf_0: [libc::c_uchar; 3] = [0; 3];
                buf_0[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_0 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_0 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_1: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int32_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < (1 as libc::c_int) << 7 as libc::c_int {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int32_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 8 as libc::c_int {
            let mut buf_2: [libc::c_uchar; 2] =
                [0xcc as libc::c_int as libc::c_uchar,
                 *(&mut d as *mut int32_t as
                       *mut uint8_t).offset(0 as libc::c_int as isize)];
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_2.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if d < (1 as libc::c_int) << 16 as libc::c_int {
            let mut buf_3: [libc::c_uchar; 3] = [0; 3];
            buf_3[0 as libc::c_int as usize] =
                0xcd as libc::c_int as libc::c_uchar;
            let mut val_1 = ntohs(d as uint16_t);
            memcpy(&mut *buf_3.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_1 as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_3.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_4: [libc::c_uchar; 5] = [0; 5];
            buf_4[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_2 = ntohl(d as uint32_t);
            memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_2 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_4.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "364:1"]
    pub unsafe extern "C" fn msgpack_pack_int64(mut x: *mut msgpack_packer,
                                                mut d: int64_t)
     -> libc::c_int {
        if (d as libc::c_longlong) <
               -((1 as libc::c_longlong) << 5 as libc::c_int) {
            if (d as libc::c_longlong) <
                   -((1 as libc::c_longlong) << 15 as libc::c_int) {
                if (d as libc::c_longlong) <
                       -((1 as libc::c_longlong) << 31 as libc::c_int) {
                    let mut buf: [libc::c_uchar; 9] = [0; 9];
                    buf[0 as libc::c_int as usize] =
                        0xd3 as libc::c_int as libc::c_uchar;
                    let mut val = __bswap_64(d as __uint64_t);
                    memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as
                                                             isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint64_t as *const libc::c_void,
                           8 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       9
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_0: [libc::c_uchar; 5] = [0; 5];
                    buf_0[0 as libc::c_int as usize] =
                        0xd2 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(d as int32_t as uint32_t);
                    memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_0.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       5
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            } else if d <
                          -((1 as libc::c_int) << 7 as libc::c_int) as
                              libc::c_long {
                let mut buf_1: [libc::c_uchar; 3] = [0; 3];
                buf_1[0 as libc::c_int as usize] =
                    0xd1 as libc::c_int as libc::c_uchar;
                let mut val_1 = ntohs(d as int16_t as uint16_t);
                memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_1 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_2: [libc::c_uchar; 2] =
                    [0xd0 as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if d < ((1 as libc::c_int) << 7 as libc::c_int) as libc::c_long
         {
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut int64_t
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 16 as libc::c_int {
            if d < ((1 as libc::c_int) << 8 as libc::c_int) as libc::c_long {
                let mut buf_3: [libc::c_uchar; 2] =
                    [0xcc as libc::c_int as libc::c_uchar,
                     *(&mut d as *mut int64_t as
                           *mut uint8_t).offset(0 as libc::c_int as isize)];
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            } else {
                let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                buf_4[0 as libc::c_int as usize] =
                    0xcd as libc::c_int as libc::c_uchar;
                let mut val_2 = ntohs(d as uint16_t);
                memcpy(&mut *buf_4.as_mut_ptr().offset(1 as libc::c_int as
                                                           isize) as
                           *mut libc::c_uchar as *mut libc::c_void,
                       &mut val_2 as *mut uint16_t as *const libc::c_void,
                       2 as libc::c_int as libc::c_ulong);
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_4.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   3
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
        } else if (d as libc::c_longlong) <
                      (1 as libc::c_longlong) << 32 as libc::c_int {
            let mut buf_5: [libc::c_uchar; 5] = [0; 5];
            buf_5[0 as libc::c_int as usize] =
                0xce as libc::c_int as libc::c_uchar;
            let mut val_3 = ntohl(d as uint32_t);
            memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_3 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_5.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_6: [libc::c_uchar; 9] = [0; 9];
            buf_6[0 as libc::c_int as usize] =
                0xcf as libc::c_int as libc::c_uchar;
            let mut val_4 = __bswap_64(d as __uint64_t);
            memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_4 as *mut uint64_t as *const libc::c_void,
                   8 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_6.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               9
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "271:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint8(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: uint8_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 2] =
            [0xcc as libc::c_int as libc::c_uchar,
             *(&mut d as *mut uint8_t).offset(0 as libc::c_int as isize)];
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           2
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "277:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint16(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint16_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 3] = [0; 3];
        buf[0 as libc::c_int as usize] = 0xcd as libc::c_int as libc::c_uchar;
        let mut val = ntohs(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint16_t as *const libc::c_void,
               2 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           3
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "284:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint32(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint32_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        buf[0 as libc::c_int as usize] = 0xce as libc::c_int as libc::c_uchar;
        let mut val = ntohl(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "291:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_uint64(mut x:
                                                         *mut msgpack_packer,
                                                     mut d: uint64_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        buf[0 as libc::c_int as usize] = 0xcf as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(d);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "298:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int8(mut x: *mut msgpack_packer,
                                                   mut d: int8_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 2] =
            [0xd0 as libc::c_int as libc::c_uchar,
             *(&mut d as *mut int8_t as
                   *mut uint8_t).offset(0 as libc::c_int as isize)];
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           2
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "304:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int16(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int16_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 3] = [0; 3];
        buf[0 as libc::c_int as usize] = 0xd1 as libc::c_int as libc::c_uchar;
        let mut val = ntohs(d as uint16_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint16_t as *const libc::c_void,
               2 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           3
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "311:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int32(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int32_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        buf[0 as libc::c_int as usize] = 0xd2 as libc::c_int as libc::c_uchar;
        let mut val = ntohl(d as uint32_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "318:1"]
    pub unsafe extern "C" fn msgpack_pack_fix_int64(mut x:
                                                        *mut msgpack_packer,
                                                    mut d: int64_t)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        buf[0 as libc::c_int as usize] = 0xd3 as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(d as __uint64_t);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "651:1"]
    pub unsafe extern "C" fn msgpack_pack_float(mut x: *mut msgpack_packer,
                                                mut d: libc::c_float)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 5] = [0; 5];
        let mut mem = C2RustUnnamed_30{f: 0.,};
        mem.f = d;
        buf[0 as libc::c_int as usize] = 0xca as libc::c_int as libc::c_uchar;
        let mut val = ntohl(mem.i);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint32_t as *const libc::c_void,
               4 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           5
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "660:1"]
    pub unsafe extern "C" fn msgpack_pack_double(mut x: *mut msgpack_packer,
                                                 mut d: libc::c_double)
     -> libc::c_int {
        let mut buf: [libc::c_uchar; 9] = [0; 9];
        let mut mem = C2RustUnnamed_31{f: 0.,};
        mem.f = d;
        buf[0 as libc::c_int as usize] = 0xcb as libc::c_int as libc::c_uchar;
        let mut val = __bswap_64(mem.i);
        memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                   *mut libc::c_uchar as *mut libc::c_void,
               &mut val as *mut uint64_t as *const libc::c_void,
               8 as libc::c_int as libc::c_ulong);
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           buf.as_mut_ptr()
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           9
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "681:1"]
    pub unsafe extern "C" fn msgpack_pack_nil(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc0 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "692:1"]
    pub unsafe extern "C" fn msgpack_pack_true(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc3 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "698:1"]
    pub unsafe extern "C" fn msgpack_pack_false(mut x: *mut msgpack_packer)
     -> libc::c_int {
        pub static mut d: libc::c_uchar =
            0xc2 as libc::c_int as libc::c_uchar;
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           &d
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           1
                                                                                                               as
                                                                                                               libc::c_int
                                                                                                               as
                                                                                                               size_t);
    }
    #[inline]
    #[c2rust::src_loc = "709:1"]
    pub unsafe extern "C" fn msgpack_pack_array(mut x: *mut msgpack_packer,
                                                mut n: size_t)
     -> libc::c_int {
        if n < 16 as libc::c_int as libc::c_ulong {
            let mut d =
                (0x90 as libc::c_int | n as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut d
                                                                                                                   as
                                                                                                                   *mut libc::c_uchar
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if n < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xdc as libc::c_int as libc::c_uchar;
            let mut val = ntohs(n as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdd as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(n as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "730:1"]
    pub unsafe extern "C" fn msgpack_pack_map(mut x: *mut msgpack_packer,
                                              mut n: size_t) -> libc::c_int {
        if n < 16 as libc::c_int as libc::c_ulong {
            let mut d =
                (0x80 as libc::c_int | n as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if n < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xde as libc::c_int as libc::c_uchar;
            let mut val = ntohs(n as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdf as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(n as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "751:1"]
    pub unsafe extern "C" fn msgpack_pack_str(mut x: *mut msgpack_packer,
                                              mut l: size_t) -> libc::c_int {
        if l < 32 as libc::c_int as libc::c_ulong {
            let mut d =
                (0xa0 as libc::c_int | l as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 256 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 2] = [0; 2];
            buf[0 as libc::c_int as usize] =
                0xd9 as libc::c_int as libc::c_uchar;
            buf[1 as libc::c_int as usize] = l as uint8_t;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xda as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xdb as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "771:1"]
    pub unsafe extern "C" fn msgpack_pack_str_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "780:1"]
    pub unsafe extern "C" fn msgpack_pack_v4raw(mut x: *mut msgpack_packer,
                                                mut l: size_t)
     -> libc::c_int {
        if l < 32 as libc::c_int as libc::c_ulong {
            let mut d =
                (0xa0 as libc::c_int | l as uint8_t as libc::c_int) as
                    libc::c_uchar;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               &mut *(&mut d
                                                                                                                          as
                                                                                                                          *mut libc::c_uchar
                                                                                                                          as
                                                                                                                          *mut uint8_t).offset(0
                                                                                                                                                   as
                                                                                                                                                   libc::c_int
                                                                                                                                                   as
                                                                                                                                                   isize)
                                                                                                                   as
                                                                                                                   *mut uint8_t
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               1
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 3] = [0; 3];
            buf[0 as libc::c_int as usize] =
                0xda as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf.as_mut_ptr().offset(1 as libc::c_int as isize) as
                       *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_0: [libc::c_uchar; 5] = [0; 5];
            buf_0[0 as libc::c_int as usize] =
                0xdb as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "796:1"]
    pub unsafe extern "C" fn msgpack_pack_v4raw_body(mut x:
                                                         *mut msgpack_packer,
                                                     mut b:
                                                         *const libc::c_void,
                                                     mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "805:1"]
    pub unsafe extern "C" fn msgpack_pack_bin(mut x: *mut msgpack_packer,
                                              mut l: size_t) -> libc::c_int {
        if l < 256 as libc::c_int as libc::c_ulong {
            let mut buf: [libc::c_uchar; 2] = [0; 2];
            buf[0 as libc::c_int as usize] =
                0xc4 as libc::c_int as libc::c_uchar;
            buf[1 as libc::c_int as usize] = l as uint8_t;
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               2
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else if l < 65536 as libc::c_int as libc::c_ulong {
            let mut buf_0: [libc::c_uchar; 3] = [0; 3];
            buf_0[0 as libc::c_int as usize] =
                0xc5 as libc::c_int as libc::c_uchar;
            let mut val = ntohs(l as uint16_t);
            memcpy(&mut *buf_0.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val as *mut uint16_t as *const libc::c_void,
                   2 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_0.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               3
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        } else {
            let mut buf_1: [libc::c_uchar; 5] = [0; 5];
            buf_1[0 as libc::c_int as usize] =
                0xc6 as libc::c_int as libc::c_uchar;
            let mut val_0 = ntohl(l as uint32_t);
            memcpy(&mut *buf_1.as_mut_ptr().offset(1 as libc::c_int as isize)
                       as *mut libc::c_uchar as *mut libc::c_void,
                   &mut val_0 as *mut uint32_t as *const libc::c_void,
                   4 as libc::c_int as libc::c_ulong);
            return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                               buf_1.as_mut_ptr()
                                                                                                                   as
                                                                                                                   *const libc::c_char,
                                                                                                               5
                                                                                                                   as
                                                                                                                   libc::c_int
                                                                                                                   as
                                                                                                                   size_t)
        };
    }
    #[inline]
    #[c2rust::src_loc = "822:1"]
    pub unsafe extern "C" fn msgpack_pack_bin_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    #[inline]
    #[c2rust::src_loc = "831:1"]
    pub unsafe extern "C" fn msgpack_pack_ext(mut x: *mut msgpack_packer,
                                              mut l: size_t,
                                              mut type_0: int8_t)
     -> libc::c_int {
        match l {
            1 => {
                let mut buf: [libc::c_uchar; 2] = [0; 2];
                buf[0 as libc::c_int as usize] =
                    0xd4 as libc::c_int as libc::c_uchar;
                buf[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            2 => {
                let mut buf_0: [libc::c_uchar; 2] = [0; 2];
                buf_0[0 as libc::c_int as usize] =
                    0xd5 as libc::c_int as libc::c_uchar;
                buf_0[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_0.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            4 => {
                let mut buf_1: [libc::c_uchar; 2] = [0; 2];
                buf_1[0 as libc::c_int as usize] =
                    0xd6 as libc::c_int as libc::c_uchar;
                buf_1[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_1.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            8 => {
                let mut buf_2: [libc::c_uchar; 2] = [0; 2];
                buf_2[0 as libc::c_int as usize] =
                    0xd7 as libc::c_int as libc::c_uchar;
                buf_2[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_2.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            16 => {
                let mut buf_3: [libc::c_uchar; 2] = [0; 2];
                buf_3[0 as libc::c_int as usize] =
                    0xd8 as libc::c_int as libc::c_uchar;
                buf_3[1 as libc::c_int as usize] = type_0 as libc::c_uchar;
                return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                   buf_3.as_mut_ptr()
                                                                                                                       as
                                                                                                                       *const libc::c_char,
                                                                                                                   2
                                                                                                                       as
                                                                                                                       libc::c_int
                                                                                                                       as
                                                                                                                       size_t)
            }
            _ => {
                if l < 256 as libc::c_int as libc::c_ulong {
                    let mut buf_4: [libc::c_uchar; 3] = [0; 3];
                    buf_4[0 as libc::c_int as usize] =
                        0xc7 as libc::c_int as libc::c_uchar;
                    buf_4[1 as libc::c_int as usize] = l as libc::c_uchar;
                    buf_4[2 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_4.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       3
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else if l < 65536 as libc::c_int as libc::c_ulong {
                    let mut buf_5: [libc::c_uchar; 4] = [0; 4];
                    buf_5[0 as libc::c_int as usize] =
                        0xc8 as libc::c_int as libc::c_uchar;
                    let mut val = ntohs(l as uint16_t);
                    memcpy(&mut *buf_5.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val as *mut uint16_t as *const libc::c_void,
                           2 as libc::c_int as libc::c_ulong);
                    buf_5[3 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_5.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       4
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                } else {
                    let mut buf_6: [libc::c_uchar; 6] = [0; 6];
                    buf_6[0 as libc::c_int as usize] =
                        0xc9 as libc::c_int as libc::c_uchar;
                    let mut val_0 = ntohl(l as uint32_t);
                    memcpy(&mut *buf_6.as_mut_ptr().offset(1 as libc::c_int as
                                                               isize) as
                               *mut libc::c_uchar as *mut libc::c_void,
                           &mut val_0 as *mut uint32_t as *const libc::c_void,
                           4 as libc::c_int as libc::c_ulong);
                    buf_6[5 as libc::c_int as usize] =
                        type_0 as libc::c_uchar;
                    return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                                       buf_6.as_mut_ptr()
                                                                                                                           as
                                                                                                                           *const libc::c_char,
                                                                                                                       6
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           size_t)
                }
            }
        };
    }
    #[inline]
    #[c2rust::src_loc = "888:1"]
    pub unsafe extern "C" fn msgpack_pack_ext_body(mut x: *mut msgpack_packer,
                                                   mut b: *const libc::c_void,
                                                   mut l: size_t)
     -> libc::c_int {
        return Some((*x).callback.expect("non-null function pointer")).expect("non-null function pointer")((*x).data,
                                                                                                           b
                                                                                                               as
                                                                                                               *const libc::c_uchar
                                                                                                               as
                                                                                                               *const libc::c_char,
                                                                                                           l);
    }
    use super::stdint_uintn_h::{uint32_t, uint64_t, uint8_t, uint16_t};
    use super::pack_h::msgpack_packer;
    use super::stddef_h::size_t;
    use super::in_h::{ntohs, ntohl};
    use super::stdint_intn_h::{int16_t, int32_t, int8_t, int64_t};
    use super::string_h::memcpy;
    use super::byteswap_h::__bswap_64;
    use super::types_h::__uint64_t;
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/unpack.h:49"]
pub mod unpack_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "28:16"]
    pub struct msgpack_unpacked {
        pub zone: *mut msgpack_zone,
        pub data: msgpack_object,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "56:16"]
    pub struct msgpack_unpacker {
        pub buffer: *mut libc::c_char,
        pub used: size_t,
        pub free: size_t,
        pub off: size_t,
        pub parsed: size_t,
        pub z: *mut msgpack_zone,
        pub initial_buffer_size: size_t,
        pub ctx: *mut libc::c_void,
    }
    #[inline]
    #[c2rust::src_loc = "219:1"]
    pub unsafe extern "C" fn msgpack_unpacker_reserve_buffer(mut mpac:
                                                                 *mut msgpack_unpacker,
                                                             mut size: size_t)
     -> bool {
        if (*mpac).free >= size { return true_0 != 0 }
        return msgpack_unpacker_expand_buffer(mpac, size);
    }
    #[inline]
    #[c2rust::src_loc = "225:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer(mut mpac:
                                                         *mut msgpack_unpacker)
     -> *mut libc::c_char {
        return (*mpac).buffer.offset((*mpac).used as isize);
    }
    #[inline]
    #[c2rust::src_loc = "230:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer_capacity(mut mpac:
                                                                  *const msgpack_unpacker)
     -> size_t {
        return (*mpac).free;
    }
    #[inline]
    #[c2rust::src_loc = "235:1"]
    pub unsafe extern "C" fn msgpack_unpacker_buffer_consumed(mut mpac:
                                                                  *mut msgpack_unpacker,
                                                              mut size:
                                                                  size_t) {
        (*mpac).used =
            ((*mpac).used as libc::c_ulong).wrapping_add(size) as size_t as
                size_t;
        (*mpac).free =
            ((*mpac).free as libc::c_ulong).wrapping_sub(size) as size_t as
                size_t;
    }
    #[inline]
    #[c2rust::src_loc = "252:1"]
    pub unsafe extern "C" fn msgpack_unpacked_init(mut result:
                                                       *mut msgpack_unpacked) {
        memset(result as *mut libc::c_void, 0 as libc::c_int,
               ::std::mem::size_of::<msgpack_unpacked>() as libc::c_ulong);
    }
    #[inline]
    #[c2rust::src_loc = "257:1"]
    pub unsafe extern "C" fn msgpack_unpacked_destroy(mut result:
                                                          *mut msgpack_unpacked) {
        if !(*result).zone.is_null() {
            msgpack_zone_free((*result).zone);
            (*result).zone = NULL_1 as *mut msgpack_zone;
            memset(&mut (*result).data as *mut msgpack_object as
                       *mut libc::c_void, 0 as libc::c_int,
                   ::std::mem::size_of::<msgpack_object>() as libc::c_ulong);
        };
    }
    #[inline]
    #[c2rust::src_loc = "266:1"]
    pub unsafe extern "C" fn msgpack_unpacked_release_zone(mut result:
                                                               *mut msgpack_unpacked)
     -> *mut msgpack_zone {
        if !(*result).zone.is_null() {
            let mut z = (*result).zone;
            (*result).zone = NULL_1 as *mut msgpack_zone;
            return z
        }
        return NULL_1 as *mut msgpack_zone;
    }
    #[inline]
    #[c2rust::src_loc = "241:1"]
    pub unsafe extern "C" fn msgpack_unpacker_message_size(mut mpac:
                                                               *const msgpack_unpacker)
     -> size_t {
        return (*mpac).parsed.wrapping_sub((*mpac).off).wrapping_add((*mpac).used);
    }
    #[inline]
    #[c2rust::src_loc = "246:1"]
    pub unsafe extern "C" fn msgpack_unpacker_parsed_size(mut mpac:
                                                              *const msgpack_unpacker)
     -> size_t {
        return (*mpac).parsed;
    }
    use super::zone_h::{msgpack_zone, msgpack_zone_free};
    use super::object_h::msgpack_object;
    use super::stddef_h::{size_t, NULL_1};
    use super::stdbool_h::true_0;
    use super::string_h::memset;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "217:1"]
        pub fn msgpack_unpacker_expand_buffer(mpac: *mut msgpack_unpacker,
                                              size: size_t) -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/sbuffer.h:49"]
pub mod sbuffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "27:16"]
    pub struct msgpack_sbuffer {
        pub size: size_t,
        pub data: *mut libc::c_char,
        pub alloc: size_t,
    }
    #[inline]
    #[c2rust::src_loc = "33:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_init(mut sbuf:
                                                      *mut msgpack_sbuffer) {
        memset(sbuf as *mut libc::c_void, 0 as libc::c_int,
               ::std::mem::size_of::<msgpack_sbuffer>() as libc::c_ulong);
    }
    #[inline]
    #[c2rust::src_loc = "38:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_destroy(mut sbuf:
                                                         *mut msgpack_sbuffer) {
        free((*sbuf).data as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "43:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_new() -> *mut msgpack_sbuffer {
        return calloc(1 as libc::c_int as libc::c_ulong,
                      ::std::mem::size_of::<msgpack_sbuffer>() as
                          libc::c_ulong) as *mut msgpack_sbuffer;
    }
    #[inline]
    #[c2rust::src_loc = "48:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_free(mut sbuf:
                                                      *mut msgpack_sbuffer) {
        if sbuf.is_null() { return }
        msgpack_sbuffer_destroy(sbuf);
        free(sbuf as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "59:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_write(mut data:
                                                       *mut libc::c_void,
                                                   mut buf:
                                                       *const libc::c_char,
                                                   mut len: size_t)
     -> libc::c_int {
        let mut sbuf = data as *mut msgpack_sbuffer;
        if (*sbuf).alloc.wrapping_sub((*sbuf).size) < len {
            let mut tmp = 0 as *mut libc::c_void;
            let mut nsize =
                if (*sbuf).alloc != 0 {
                    (*sbuf).alloc.wrapping_mul(2 as libc::c_int as
                                                   libc::c_ulong)
                } else { MSGPACK_SBUFFER_INIT_SIZE as libc::c_ulong };
            while nsize < (*sbuf).size.wrapping_add(len) {
                let mut tmp_nsize =
                    nsize.wrapping_mul(2 as libc::c_int as libc::c_ulong);
                if tmp_nsize <= nsize {
                    nsize = (*sbuf).size.wrapping_add(len);
                    break ;
                } else { nsize = tmp_nsize }
            }
            tmp = realloc((*sbuf).data as *mut libc::c_void, nsize);
            if tmp.is_null() { return -(1 as libc::c_int) }
            (*sbuf).data = tmp as *mut libc::c_char;
            (*sbuf).alloc = nsize
        }
        memcpy((*sbuf).data.offset((*sbuf).size as isize) as
                   *mut libc::c_void, buf as *const libc::c_void, len);
        (*sbuf).size =
            ((*sbuf).size as libc::c_ulong).wrapping_add(len) as size_t as
                size_t;
        return 0 as libc::c_int;
    }
    #[c2rust::src_loc = "56:9"]
    pub const MSGPACK_SBUFFER_INIT_SIZE: libc::c_int = 8192 as libc::c_int;
    #[inline]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_release(mut sbuf:
                                                         *mut msgpack_sbuffer)
     -> *mut libc::c_char {
        let mut tmp = (*sbuf).data;
        (*sbuf).size = 0 as libc::c_int as size_t;
        (*sbuf).data = NULL_1 as *mut libc::c_char;
        (*sbuf).alloc = 0 as libc::c_int as size_t;
        return tmp;
    }
    #[inline]
    #[c2rust::src_loc = "98:1"]
    pub unsafe extern "C" fn msgpack_sbuffer_clear(mut sbuf:
                                                       *mut msgpack_sbuffer) {
        (*sbuf).size = 0 as libc::c_int as size_t;
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::string_h::{memset, memcpy};
    use super::stdlib_h::{free, calloc, realloc};
}
#[c2rust::header_src =
  "/home/vole/neovim/.deps/usr/include/msgpack/vrefbuffer.h:49"]
pub mod vrefbuffer_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "39:16"]
    pub struct msgpack_vrefbuffer_inner_buffer {
        pub free: size_t,
        pub ptr: *mut libc::c_char,
        pub head: *mut msgpack_vrefbuffer_chunk,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "45:16"]
    pub struct msgpack_vrefbuffer {
        pub tail: *mut iovec,
        pub end: *mut iovec,
        pub array: *mut iovec,
        pub chunk_size: size_t,
        pub ref_size: size_t,
        pub inner_buffer: msgpack_vrefbuffer_inner_buffer,
    }
    #[inline]
    #[c2rust::src_loc = "96:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_new(mut ref_size: size_t,
                                                    mut chunk_size: size_t)
     -> *mut msgpack_vrefbuffer {
        let mut vbuf =
            malloc(::std::mem::size_of::<msgpack_vrefbuffer>() as
                       libc::c_ulong) as *mut msgpack_vrefbuffer;
        if vbuf.is_null() { return NULL_1 as *mut msgpack_vrefbuffer }
        if !msgpack_vrefbuffer_init(vbuf, ref_size, chunk_size) {
            free(vbuf as *mut libc::c_void);
            return NULL_1 as *mut msgpack_vrefbuffer
        }
        return vbuf;
    }
    #[inline]
    #[c2rust::src_loc = "107:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_free(mut vbuf:
                                                         *mut msgpack_vrefbuffer) {
        if vbuf.is_null() { return }
        msgpack_vrefbuffer_destroy(vbuf);
        free(vbuf as *mut libc::c_void);
    }
    #[inline]
    #[c2rust::src_loc = "114:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_write(mut data:
                                                          *mut libc::c_void,
                                                      mut buf:
                                                          *const libc::c_char,
                                                      mut len: size_t)
     -> libc::c_int {
        let mut vbuf = data as *mut msgpack_vrefbuffer;
        if len < (*vbuf).ref_size {
            return msgpack_vrefbuffer_append_copy(vbuf, buf, len)
        } else { return msgpack_vrefbuffer_append_ref(vbuf, buf, len) };
    }
    #[inline]
    #[c2rust::src_loc = "125:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_vec(mut vref:
                                                        *const msgpack_vrefbuffer)
     -> *const iovec {
        return (*vref).array;
    }
    #[inline]
    #[c2rust::src_loc = "130:1"]
    pub unsafe extern "C" fn msgpack_vrefbuffer_veclen(mut vref:
                                                           *const msgpack_vrefbuffer)
     -> size_t {
        return (*vref).tail.wrapping_offset_from((*vref).array) as
                   libc::c_long as size_t;
    }
    use super::stddef_h::{size_t, NULL_1};
    use super::struct_iovec_h::iovec;
    use super::stdlib_h::{malloc, free};
    extern "C" {
        #[c2rust::src_loc = "36:8"]
        pub type msgpack_vrefbuffer_chunk;
        #[no_mangle]
        #[c2rust::src_loc = "80:1"]
        pub fn msgpack_vrefbuffer_append_copy(vbuf: *mut msgpack_vrefbuffer,
                                              buf: *const libc::c_char,
                                              len: size_t) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "84:1"]
        pub fn msgpack_vrefbuffer_append_ref(vbuf: *mut msgpack_vrefbuffer,
                                             buf: *const libc::c_char,
                                             len: size_t) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "69:1"]
        pub fn msgpack_vrefbuffer_destroy(vbuf: *mut msgpack_vrefbuffer);
        #[no_mangle]
        #[c2rust::src_loc = "66:1"]
        pub fn msgpack_vrefbuffer_init(vbuf: *mut msgpack_vrefbuffer,
                                       ref_size: size_t, chunk_size: size_t)
         -> bool;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/channel.h:49"]
pub mod channel_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "60:8"]
    pub struct Channel {
        pub id: uint64_t,
        pub refcount: size_t,
        pub events: *mut MultiQueue,
        pub streamtype: ChannelStreamType,
        pub stream: C2RustUnnamed_33,
        pub is_rpc: bool,
        pub rpc: RpcState,
        pub term: *mut Terminal,
        pub on_data: CallbackReader,
        pub on_stderr: CallbackReader,
        pub on_exit: Callback,
        pub exit_status: libc::c_int,
        pub callback_busy: bool,
        pub callback_scheduled: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "41:9"]
    pub struct CallbackReader {
        pub cb: Callback,
        pub self_0: *mut dict_T,
        pub buffer: garray_T,
        pub eof: bool,
        pub buffered: bool,
        pub type_0: *const libc::c_char,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "66:3"]
    pub union C2RustUnnamed_33 {
        pub proc_0: Process,
        pub uv: LibuvProcess,
        pub pty: PtyProcess,
        pub socket: Stream,
        pub stdio: StdioPair,
        pub err: StderrState,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "37:9"]
    pub struct StderrState {
        pub closed: bool,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "32:9"]
    pub struct StdioPair {
        pub in_0: Stream,
        pub out: Stream,
    }
    #[c2rust::src_loc = "15:9"]
    pub type ChannelStreamType = libc::c_uint;
    #[c2rust::src_loc = "20:3"]
    pub const kChannelStreamInternal: ChannelStreamType = 4;
    #[c2rust::src_loc = "19:3"]
    pub const kChannelStreamStderr: ChannelStreamType = 3;
    #[c2rust::src_loc = "18:3"]
    pub const kChannelStreamStdio: ChannelStreamType = 2;
    #[c2rust::src_loc = "17:3"]
    pub const kChannelStreamSocket: ChannelStreamType = 1;
    #[c2rust::src_loc = "16:3"]
    pub const kChannelStreamProc: ChannelStreamType = 0;
    #[inline]
    #[c2rust::src_loc = "55:1"]
    pub unsafe extern "C" fn callback_reader_set(mut reader: CallbackReader)
     -> bool {
        return reader.cb.type_0 as libc::c_uint !=
                   kCallbackNone as libc::c_int as libc::c_uint ||
                   !reader.self_0.is_null();
    }
    // / @returns Channel with the id or NULL if not found
    #[inline]
    #[c2rust::src_loc = "95:1"]
    pub unsafe extern "C" fn find_channel(mut id: uint64_t) -> *mut Channel {
        return map_uint64_t_ptr_t_get(channels, id) as *mut Channel;
    }
    #[inline]
    #[c2rust::src_loc = "100:1"]
    pub unsafe extern "C" fn channel_instream(mut chan: *mut Channel)
     -> *mut Stream {
        match (*chan).streamtype as libc::c_uint {
            0 => { return &mut (*chan).stream.proc_0.in_0 }
            1 => { return &mut (*chan).stream.socket }
            2 => { return &mut (*chan).stream.stdio.out }
            4 | 3 => { abort(); }
            _ => { }
        }
        abort();
    }
    #[inline]
    #[c2rust::src_loc = "120:1"]
    pub unsafe extern "C" fn channel_outstream(mut chan: *mut Channel)
     -> *mut Stream {
        match (*chan).streamtype as libc::c_uint {
            0 => { return &mut (*chan).stream.proc_0.out }
            1 => { return &mut (*chan).stream.socket }
            2 => { return &mut (*chan).stream.stdio.in_0 }
            4 | 3 => { abort(); }
            _ => { }
        }
        abort();
    }
    use super::stdint_uintn_h::uint64_t;
    use super::stddef_h::size_t;
    use super::multiqueue_h::MultiQueue;
    use super::channel_defs_h::RpcState;
    use super::terminal_h::Terminal;
    use super::typval_h::{Callback, dict_T, C2RustUnnamed_1, CallbackType,
                          kCallbackNone};
    use super::garray_h::garray_T;
    use super::process_h::Process;
    use super::libuv_process_h::LibuvProcess;
    use super::pty_process_unix_h::PtyProcess;
    use super::stream_h::Stream;
    use super::nvim_types_h::char_u;
    use super::map_h::{Map_uint64_t_ptr_t, map_uint64_t_ptr_t_get};
    use super::stdlib_h::abort;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "88:24"]
        pub static mut channels: *mut Map_uint64_t_ptr_t;
    }
    // NVIM_CHANNEL_H
}
#[c2rust::header_src =
  "/home/vole/neovim/src/nvim/msgpack_rpc/channel_defs.h:49"]
pub mod channel_defs_h {
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "29:9"]
    pub struct RpcState {
        pub subscribed_events: *mut Map_cstr_t_ptr_t,
        pub closed: bool,
        pub unpacker: *mut msgpack_unpacker,
        pub next_request_id: uint32_t,
        pub call_stack: C2RustUnnamed_32,
        pub info: Dictionary,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "34:3"]
    pub struct C2RustUnnamed_32 {
        pub size: size_t,
        pub capacity: size_t,
        pub items: *mut *mut ChannelCallFrame,
    }
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "15:9"]
    pub struct ChannelCallFrame {
        pub request_id: uint32_t,
        pub returned: bool,
        pub errored: bool,
        pub result: Object,
    }
    use super::map_h::Map_cstr_t_ptr_t;
    use super::unpack_h::msgpack_unpacker;
    use super::stdint_uintn_h::uint32_t;
    use super::defs_h::{Dictionary, Object};
    use super::stddef_h::size_t;
    // NVIM_MSGPACK_RPC_CHANNEL_DEFS_H
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/fileio.h:49"]
pub mod fileio_h {
    // / Structure used to read from/write to file
    #[derive(Copy, Clone)]
    #[repr(C)]
    #[c2rust::src_loc = "11:9"]
    pub struct FileDescriptor {
        pub fd: libc::c_int,
        pub _error: libc::c_int,
        pub rv: *mut RBuffer,
        pub wr: bool,
        pub eof: bool,
        pub non_blocking: bool,
    }
    // / Check whether end of file was encountered
// /
// / @param[in]  fp  File to check.
// /
// / @return true if it was, false if it was not or read operation was never
// /         performed.
    #[inline]
    #[c2rust::src_loc = "49:1"]
    pub unsafe extern "C" fn file_eof(fp: *const FileDescriptor) -> bool {
        return (*fp).eof as libc::c_int != 0 &&
                   rbuffer_size((*fp).rv) ==
                       0 as libc::c_int as libc::c_ulong;
    }
    // / Return the file descriptor associated with the FileDescriptor structure
// /
// / @param[in]  fp  File to check.
// /
// / @return File descriptor.
    #[inline]
    #[c2rust::src_loc = "62:1"]
    pub unsafe extern "C" fn file_fd(fp: *const FileDescriptor)
     -> libc::c_int {
        return (*fp).fd;
    }
    use super::rbuffer_h::{RBuffer, rbuffer_size};
    // NVIM_OS_FILEIO_H
}
#[c2rust::header_src = "/usr/include/assert.h:39"]
pub mod assert_h {
    #[c2rust::src_loc = "129:12"]
    pub const __ASSERT_FUNCTION: [libc::c_char; 58] =
        unsafe {
            *::std::mem::transmute::<&[u8; 58],
                                     &[libc::c_char; 58]>(b"void tv_list_set_lock(list_T *const, const VarLockStatus)\x00")
        };
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "69:1"]
        pub fn __assert_fail(__assertion: *const libc::c_char,
                             __file: *const libc::c_char,
                             __line: libc::c_uint,
                             __function: *const libc::c_char) -> !;
    }
}
#[c2rust::header_src = "/usr/include/errno.h:40"]
pub mod errno_h {
    #[c2rust::src_loc = "38:10"]
    pub const errno: libc::c_int = *__errno_location();
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "37:1"]
        pub fn __errno_location() -> *mut libc::c_int;
    }
}
#[c2rust::header_src = "/usr/include/asm-generic/errno-base.h:40"]
pub mod errno_base_h {
    #[c2rust::src_loc = "26:9"]
    pub const EINVAL: libc::c_int = 22 as libc::c_int;
    #[c2rust::src_loc = "6:9"]
    pub const ENOENT: libc::c_int = 2 as libc::c_int;
}
#[c2rust::header_src = "/usr/include/string.h:42"]
pub mod string_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "42:14"]
        pub fn memcpy(_: *mut libc::c_void, _: *const libc::c_void,
                      _: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "46:14"]
        pub fn memmove(_: *mut libc::c_void, _: *const libc::c_void,
                       _: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "60:14"]
        pub fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "90:14"]
        pub fn memchr(_: *const libc::c_void, _: libc::c_int,
                      _: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "121:14"]
        pub fn strcpy(_: *mut libc::c_char, _: *const libc::c_char)
         -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "136:12"]
        pub fn strcmp(_: *const libc::c_char, _: *const libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "139:12"]
        pub fn strncmp(_: *const libc::c_char, _: *const libc::c_char,
                       _: libc::c_ulong) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "384:15"]
        pub fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    }
}
#[c2rust::header_src = "/usr/include/strings.h:42"]
pub mod strings_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "120:12"]
        pub fn strncasecmp(_: *const libc::c_char, _: *const libc::c_char,
                           _: libc::c_ulong) -> libc::c_int;
    }
}
#[c2rust::header_src =
  "/usr/lib/llvm-6.0/lib/clang/6.0.1/include/stdbool.h:43"]
pub mod stdbool_h {
    #[c2rust::src_loc = "32:9"]
    pub const true_0: libc::c_int = 1 as libc::c_int;
    #[c2rust::src_loc = "33:9"]
    pub const false_0: libc::c_int = 0 as libc::c_int;
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/fcntl-linux.h:44"]
pub mod fcntl_linux_h {
    #[c2rust::src_loc = "43:9"]
    pub const O_RDONLY: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "45:9"]
    pub const O_RDWR: libc::c_int = 0o2 as libc::c_int;
}
#[c2rust::header_src = "/usr/include/stdlib.h:46"]
pub mod stdlib_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "539:14"]
        pub fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "541:14"]
        pub fn calloc(_: libc::c_ulong, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "549:14"]
        pub fn realloc(_: *mut libc::c_void, _: libc::c_ulong)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "563:1"]
        pub fn free(__ptr: *mut libc::c_void);
        #[no_mangle]
        #[c2rust::src_loc = "588:13"]
        pub fn abort() -> !;
    }
}
#[c2rust::header_src = "/usr/include/x86_64-linux-gnu/bits/byteswap.h:46"]
pub mod byteswap_h {
    #[inline]
    #[c2rust::src_loc = "48:1"]
    pub unsafe extern "C" fn __bswap_32(mut __bsx: __uint32_t) -> __uint32_t {
        return (__bsx & 0xff000000 as libc::c_uint) >> 24 as libc::c_int |
                   (__bsx & 0xff0000 as libc::c_uint) >> 8 as libc::c_int |
                   (__bsx & 0xff00 as libc::c_uint) << 8 as libc::c_int |
                   (__bsx & 0xff as libc::c_uint) << 24 as libc::c_int;
    }
    #[inline]
    #[c2rust::src_loc = "69:15"]
    pub unsafe extern "C" fn __bswap_64(mut __bsx: __uint64_t) -> __uint64_t {
        return ((__bsx as libc::c_ulonglong &
                     0xff00000000000000 as libc::c_ulonglong) >>
                    56 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff000000000000 as libc::c_ulonglong) >>
                        40 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff0000000000 as libc::c_ulonglong) >>
                        24 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff00000000 as libc::c_ulonglong) >>
                        8 as libc::c_int |
                    (__bsx as libc::c_ulonglong &
                         0xff000000 as libc::c_ulonglong) << 8 as libc::c_int
                    |
                    (__bsx as libc::c_ulonglong &
                         0xff0000 as libc::c_ulonglong) << 24 as libc::c_int |
                    (__bsx as libc::c_ulonglong & 0xff00 as libc::c_ulonglong)
                        << 40 as libc::c_int |
                    (__bsx as libc::c_ulonglong & 0xff as libc::c_ulonglong)
                        << 56 as libc::c_int) as __uint64_t;
    }
    #[inline]
    #[c2rust::src_loc = "33:1"]
    pub unsafe extern "C" fn __bswap_16(mut __bsx: __uint16_t) -> __uint16_t {
        return (__bsx as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int
                    |
                    (__bsx as libc::c_int & 0xff as libc::c_int) <<
                        8 as libc::c_int) as __uint16_t;
    }
    use super::types_h::{__uint32_t, __uint64_t, __uint16_t};
}
#[c2rust::header_src =
  "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h:46"]
pub mod uintn_identity_h {
    #[inline]
    #[c2rust::src_loc = "32:1"]
    pub unsafe extern "C" fn __uint16_identity(mut __x: __uint16_t)
     -> __uint16_t {
        return __x;
    }
    #[inline]
    #[c2rust::src_loc = "38:1"]
    pub unsafe extern "C" fn __uint32_identity(mut __x: __uint32_t)
     -> __uint32_t {
        return __x;
    }
    #[inline]
    #[c2rust::src_loc = "44:1"]
    pub unsafe extern "C" fn __uint64_identity(mut __x: __uint64_t)
     -> __uint64_t {
        return __x;
    }
    use super::types_h::{__uint16_t, __uint32_t, __uint64_t};
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/ascii.h:46"]
pub mod ascii_h {
    // Definitions of various common control characters.
    #[c2rust::src_loc = "19:9"]
    pub const NUL: libc::c_int = '\u{0}' as i32;
    /* CR is used by Mac OS X */
    // Control Sequence Introducer
    /* Device Control String */
    /* String Terminator */
    /* '?' -> DEL, '@' -> ^@, etc. */
    /* @ */
    /* CTRL- [ Left Square Bracket == ESC*/
    /* \ BackSLash */
    /* ] Right Square Bracket */
    /* ^ */
    /*
 * Character that separates dir names in a path.
 */
    // / Checks if `c` is a space or tab character.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "117:1"]
    pub unsafe extern "C" fn ascii_iswhite(mut c: libc::c_int) -> bool {
        return c == ' ' as i32 || c == '\t' as i32;
    }
    // / Check whether character is a decimal digit.
// /
// / Library isdigit() function is officially locale-dependent and, for
// / example, returns true for superscript 1 (¹) in locales where encoding
// / contains it in lower 8 bits. Also avoids crashes in case c is below
// / 0 or above 255: library functions are officially defined as accepting
// / only EOF and unsigned char values (otherwise it is undefined behaviour)
// / what may be used for some optimizations (e.g. simple `return
// / isdigit_table[c];`).
    #[inline(always)]
    #[c2rust::src_loc = "131:1"]
    pub unsafe extern "C" fn ascii_isdigit(mut c: libc::c_int) -> bool {
        return c >= '0' as i32 && c <= '9' as i32;
    }
    // / Checks if `c` is a hexadecimal digit, that is, one of 0-9, a-f, A-F.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "139:1"]
    pub unsafe extern "C" fn ascii_isxdigit(mut c: libc::c_int) -> bool {
        return c >= '0' as i32 && c <= '9' as i32 ||
                   c >= 'a' as i32 && c <= 'f' as i32 ||
                   c >= 'A' as i32 && c <= 'F' as i32;
    }
    // / Checks if `c` is an “identifier” character
// /
// / That is, whether it is alphanumeric character or underscore.
    #[inline(always)]
    #[c2rust::src_loc = "149:1"]
    pub unsafe extern "C" fn ascii_isident(mut c: libc::c_int) -> bool {
        return c as libc::c_uint >= 'A' as i32 as libc::c_uint &&
                   c as libc::c_uint <= 'Z' as i32 as libc::c_uint ||
                   c as libc::c_uint >= 'a' as i32 as libc::c_uint &&
                       c as libc::c_uint <= 'z' as i32 as libc::c_uint ||
                   ascii_isdigit(c) as libc::c_int != 0 || c == '_' as i32;
    }
    // / Checks if `c` is a binary digit, that is, 0-1.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "157:1"]
    pub unsafe extern "C" fn ascii_isbdigit(mut c: libc::c_int) -> bool {
        return c == '0' as i32 || c == '1' as i32;
    }
    // / Checks if `c` is a white-space character, that is,
// / one of \f, \n, \r, \t, \v.
// /
// / @see {ascii_isdigit}
    #[inline(always)]
    #[c2rust::src_loc = "166:1"]
    pub unsafe extern "C" fn ascii_isspace(mut c: libc::c_int) -> bool {
        return c >= 9 as libc::c_int && c <= 13 as libc::c_int ||
                   c == ' ' as i32;
    }
    /* NVIM_ASCII_H */
}
#[c2rust::header_src = "/usr/include/linux/limits.h:46"]
pub mod limits_h {
    #[c2rust::src_loc = "13:9"]
    pub const PATH_MAX: libc::c_int = 4096 as libc::c_int;
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/os/os_defs.h:46"]
pub mod os_defs_h {
    // Use the system path length if it makes sense.
    #[c2rust::src_loc = "20:10"]
    pub const MAXPATHL: libc::c_int = PATH_MAX;
    use super::limits_h::PATH_MAX;
    // NVIM_OS_OS_DEFS_H
    // / Converts system error code to libuv error code.
    // / Converts libuv error (negative int) to error description string.
    // Note: Some systems need both string.h and strings.h (Savage).  However,
// some systems can't handle both, only use string.h in that case.
    // Command-processing buffer. Use large buffers for all platforms.
}
#[c2rust::header_src = "/usr/include/unistd.h:46"]
pub mod unistd_h {
    use super::types_h::__off_t;
    use super::stddef_h::size_t;
    use super::stdio_h::ssize_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "334:1"]
        pub fn lseek(__fd: libc::c_int, __offset: __off_t,
                     __whence: libc::c_int) -> __off_t;
        #[no_mangle]
        #[c2rust::src_loc = "353:1"]
        pub fn close(__fd: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "808:1"]
        pub fn readlink(__path: *const libc::c_char, __buf: *mut libc::c_char,
                        __len: size_t) -> ssize_t;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/mbyte.h.generated.h:47"]
pub mod mbyte_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "47:1"]
        pub fn mb_adjust_cursor();
        #[no_mangle]
        #[c2rust::src_loc = "40:1"]
        pub fn mb_stricmp(s1: *const libc::c_char, s2: *const libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "37:1"]
        pub fn mb_utflen(s: *const char_u, len: size_t,
                         codepoints: *mut size_t, codeunits: *mut size_t);
        #[no_mangle]
        #[c2rust::src_loc = "23:1"]
        pub fn utfc_ptr2len(p: *const char_u) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "42:1"]
        pub fn utf_head_off(base: *const char_u, p: *const char_u)
         -> libc::c_int;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mbyte.h:47"]
pub mod mbyte_h {
    // For indirect
    // for char_u
    /*
 * Return byte length of character that starts with byte "b".
 * Returns 1 for a single-byte character.
 * MB_BYTE2LEN_CHECK() can be used to count a special key as one byte.
 * Don't call MB_BYTE2LEN(b) with b < 0 or b > 255!
 */
    // max length of an unicode char
    /* properties used in enc_canon_table[] (first three mutually exclusive) */
    /* Unicode: Big endian */
    /* Unicode: Little endian */
    /* Unicode: UCS-2 */
    /* Unicode: UCS-4 */
    /* Unicode: UTF-16 */
    /* Latin1 */
    /* Latin9 */
    /* Mac Roman (not Macro Man! :-) */
    // TODO(bfredl): eventually we should keep only one of the namings
    // / Flags for vimconv_T
    // / Structure used for string conversions
    // /< Zero or more ConvFlags.
    // /< Maximal expansion factor.
    // /< Value for CONV_ICONV.
    // /< What to do with invalid characters: if true, fail,
                 // /< otherwise use '?'.
    // / Compare strings
// /
// / @param[in]  ic  True if case is to be ignored.
// /
// / @return 0 if s1 == s2, <0 if s1 < s2, >0 if s1 > s2.
    #[inline]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn mb_strcmp_ic(mut ic: bool,
                                          mut s1: *const libc::c_char,
                                          mut s2: *const libc::c_char)
     -> libc::c_int {
        return if ic as libc::c_int != 0 {
                   mb_stricmp(s1, s2)
               } else { strcmp(s1, s2) };
    }
    #[c2rust::src_loc = "42:9"]
    pub const mb_ptr2len:
              unsafe extern "C" fn(_: *const char_u) -> libc::c_int =
        utfc_ptr2len;
    use super::mbyte_h_generated_h::{mb_stricmp, utfc_ptr2len};
    use super::string_h::strcmp;
    use super::nvim_types_h::char_u;
    // NVIM_MBYTE_H
}
#[c2rust::header_src = "/usr/include/time.h:47"]
pub mod include_time_h {
    use super::time_t_h::time_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "142:1"]
        pub fn ctime(__timer: *const time_t) -> *mut libc::c_char;
    }
}
#[c2rust::header_src = "/usr/include/libintl.h:47"]
pub mod libintl_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "39:1"]
        pub fn gettext(__msgid: *const libc::c_char) -> *mut libc::c_char;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/message.h.generated.h:47"]
pub mod message_h_generated_h {
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn msg(s: *mut char_u) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn verb_msg(s: *mut libc::c_char) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "14:1"]
        pub fn smsg(s: *mut libc::c_char, _: ...) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "20:1"]
        pub fn emsg(s: *const char_u) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "22:1"]
        pub fn emsgf(fmt: *const libc::c_char, _: ...) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "24:1"]
        pub fn iemsg(s: *const libc::c_char);
        #[no_mangle]
        #[c2rust::src_loc = "25:1"]
        pub fn iemsgf(s: *const libc::c_char, _: ...);
        #[no_mangle]
        #[c2rust::src_loc = "34:1"]
        pub fn set_keep_msg(s: *mut char_u, attr: libc::c_int);
        #[no_mangle]
        #[c2rust::src_loc = "36:1"]
        pub fn msg_start();
        #[no_mangle]
        #[c2rust::src_loc = "38:1"]
        pub fn msg_putchar(c: libc::c_int);
        #[no_mangle]
        #[c2rust::src_loc = "40:1"]
        pub fn msg_outnum(n: libc::c_long);
        #[no_mangle]
        #[c2rust::src_loc = "41:1"]
        pub fn msg_home_replace(fname: *mut char_u);
        #[no_mangle]
        #[c2rust::src_loc = "43:1"]
        pub fn msg_outtrans(str: *mut char_u) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "44:1"]
        pub fn msg_outtrans_attr(str: *const char_u, attr: libc::c_int)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "54:1"]
        pub fn msg_puts(s: *const libc::c_char);
        #[no_mangle]
        #[c2rust::src_loc = "58:1"]
        pub fn msg_puts_attr(s: *const libc::c_char, attr: libc::c_int);
        #[no_mangle]
        #[c2rust::src_loc = "67:1"]
        pub fn msg_reset_scroll();
        #[no_mangle]
        #[c2rust::src_loc = "80:1"]
        pub fn msg_end() -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "98:1"]
        pub fn do_dialog(type_0: libc::c_int, title: *mut char_u,
                         message: *mut char_u, buttons: *mut char_u,
                         dfltbutton: libc::c_int, textfield: *mut char_u,
                         ex_cmd: libc::c_int) -> libc::c_int;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/eval/typval.h.generated.h:47"]
pub mod typval_h_generated_h {
    use super::typval_h::{dict_T, typval_T, dictitem_T, varnumber_T};
    use super::stddef_h::{ptrdiff_t, size_t};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "43:1"]
        pub fn tv_dict_watcher_notify(dict: *mut dict_T,
                                      key: *const libc::c_char,
                                      newtv: *mut typval_T,
                                      oldtv: *mut typval_T);
        #[no_mangle]
        #[c2rust::src_loc = "54:1"]
        pub fn tv_dict_find(d: *const dict_T, key: *const libc::c_char,
                            len: ptrdiff_t) -> *mut dictitem_T;
        #[no_mangle]
        #[c2rust::src_loc = "63:1"]
        pub fn tv_dict_add_nr(d: *mut dict_T, key: *const libc::c_char,
                              key_len: size_t, nr: varnumber_T)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "65:1"]
        pub fn tv_dict_add_str(d: *mut dict_T, key: *const libc::c_char,
                               key_len: size_t, val: *const libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "66:1"]
        pub fn tv_dict_add_str_len(d: *mut dict_T, key: *const libc::c_char,
                                   key_len: size_t, val: *mut libc::c_char,
                                   len: libc::c_int) -> libc::c_int;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/strings.h:47"]
pub mod nvim_strings_h {
    // / Append string to string and return pointer to the next byte
// /
// / Unlike strcat, this one does *not* add NUL byte and returns pointer to the
// / past of the added string.
// /
// / @param[out]  dst  String to append to.
// / @param[in]  src  String to append.
// /
// / @return pointer to the byte just past the appended byte.
    #[inline]
    #[c2rust::src_loc = "20:1"]
    pub unsafe extern "C" fn strappend(dst: *mut libc::c_char,
                                       src: *const libc::c_char)
     -> *mut libc::c_char {
        let src_len = strlen(src);
        return (memmove(dst as *mut libc::c_void, src as *const libc::c_void,
                        src_len) as
                    *mut libc::c_char).offset(src_len as isize);
    }
    use super::string_h::{strlen, memmove};
    use super::stddef_h::size_t;
    // NVIM_STRINGS_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/strings.h.generated.h:47"]
pub mod strings_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "4:1"]
        pub fn vim_strsave(string: *const char_u) -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn vim_strnsave(string: *const char_u, len: size_t)
         -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "15:1"]
        pub fn vim_strchr(string: *const char_u, c: libc::c_int)
         -> *mut char_u;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/memory.h.generated.h:47"]
pub mod memory_h_generated_h {
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn xmalloc(size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn xfree(ptr: *mut libc::c_void);
        #[no_mangle]
        #[c2rust::src_loc = "9:1"]
        pub fn xcalloc(count: size_t, size: size_t) -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn xrealloc(ptr: *mut libc::c_void, size: size_t)
         -> *mut libc::c_void;
        #[no_mangle]
        #[c2rust::src_loc = "19:1"]
        pub fn xstpcpy(dst: *mut libc::c_char, src: *const libc::c_char)
         -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "21:1"]
        pub fn xstrlcpy(dst: *mut libc::c_char, src: *const libc::c_char,
                        dsize: size_t) -> size_t;
        #[no_mangle]
        #[c2rust::src_loc = "22:1"]
        pub fn xstrlcat(dst: *mut libc::c_char, src: *const libc::c_char,
                        dsize: size_t) -> size_t;
        #[no_mangle]
        #[c2rust::src_loc = "23:1"]
        pub fn xstrdup(str: *const libc::c_char) -> *mut libc::c_char;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/lib/kvec.h:47"]
pub mod kvec_h {
    // The MIT License
//
// Copyright (c) 2008, by Attractive Chaos <attractor@live.co.uk>
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
    // An example:
//
//     #include "kvec.h"
//     int main() {
//       kvec_t(int) array = KV_INITIAL_VALUE;
//       kv_push(array, 10); // append
//       kv_a(array, 20) = 5; // dynamic
//       kv_A(array, 20) = 4; // static
//       kv_destroy(array);
//       return 0;
//     }
    // / Drop last n items from kvec without resizing
// /
// / Previously spelled as `(void)kv_pop(v)`, repeated n times.
// /
// / @param[out]  v  Kvec to drop items from.
// / @param[in]  n  Number of elements to drop.
    // / Type of a vector with a few first members allocated on stack
// /
// / Is compatible with #kv_A, #kv_pop, #kv_size, #kv_max, #kv_last.
// / Is not compatible with #kv_resize, #kv_resize_full, #kv_copy, #kv_push,
// / #kv_pushp, #kv_a, #kv_destroy.
// /
// / @param[in]  type  Type of vector elements.
// / @param[in]  init_size  Number of the elements in the initial array.
    // / Initialize vector with preallocated array
// /
// / @param[out]  v  Vector to initialize.
    // / Move data to a new destination and free source
    #[inline]
    #[c2rust::src_loc = "139:1"]
    pub unsafe extern "C" fn _memcpy_free(dest: *mut libc::c_void,
                                          src: *mut libc::c_void,
                                          size: size_t) -> *mut libc::c_void {
        memcpy(dest, src, size);
        let mut ptr_ =
            &src as *const *mut libc::c_void as *mut *mut libc::c_void;
        xfree(*ptr_);
        *ptr_ = NULL_0 as *mut libc::c_void;
        return dest;
    }
    use super::stddef_h::{size_t, NULL_0};
    use super::string_h::memcpy;
    use super::memory_h_generated_h::xfree;
    // NVIM_LIB_KVEC_H
    // / Free array of elements of a vector with preallocated array if needed
// /
// / @param[out]  v  Vector to free.
    // / Push value to a vector with preallocated array
// /
// / @param[out]  v  Vector to push to.
// / @param[in]  x  Value to push.
    // / Get location where to store new element to a vector with preallocated array
// /
// / @param[in,out]  v  Vector to push to.
// /
// / @return Pointer to the place where new value should be stored.
    /* 2^x initial array size. */
    /* hard to fix this here and is not very necessary if users will use */
    /* capacity is not guaranteed to have size that is a power of 2, it is */
    /* not to bother with checking whether (v).capacity is 0. But now */
    /* Thus when vector is full capacity may not be zero and it is safe */
    /* ARRAY_SIZE((v).init_array) is the minimal capacity of this vector. */
    // / Resize vector with preallocated array when it is full
// /
// / @param[out]  v  Vector to resize.
    // / Resize vector with preallocated array
// /
// / @note May not resize to an array smaller then init_array: if requested,
// /       init_array will be used.
// /
// / @param[out]  v  Vector to resize.
// / @param[in]  s  New size.
    // -V:kvi_push:512
}
#[c2rust::header_src = "/usr/include/netinet/in.h:47"]
pub mod in_h {
    use super::stdint_uintn_h::{uint32_t, uint16_t};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "374:1"]
        pub fn ntohl(__netlong: uint32_t) -> uint32_t;
        #[no_mangle]
        #[c2rust::src_loc = "375:1"]
        pub fn ntohs(__netshort: uint16_t) -> uint16_t;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/log.h:47"]
pub mod log_h {
    #[c2rust::src_loc = "11:9"]
    pub const WARN_LOG_LEVEL: libc::c_int = 2 as libc::c_int;
    // NVIM_LOG_H
}
#[c2rust::header_src = "/home/vole/neovim/build/include/log.h.generated.h:47"]
pub mod log_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn logmsg(log_level: libc::c_int, context: *const libc::c_char,
                      func_name: *const libc::c_char, line_num: libc::c_int,
                      eol: bool, fmt: *const libc::c_char, _: ...) -> bool;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/vim.h:47"]
pub mod vim_h {
    #[c2rust::src_loc = "171:9"]
    pub const MIN_SWAP_PAGE_SIZE: libc::c_int = 1048 as libc::c_int;
    #[c2rust::src_loc = "39:9"]
    pub const MSG_HIST: libc::c_int = 0x1000 as libc::c_int;
    #[c2rust::src_loc = "94:9"]
    pub const NOTDONE: libc::c_int = 2 as libc::c_int;
    #[c2rust::src_loc = "93:9"]
    pub const FAIL: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "91:10"]
    pub const OK: libc::c_int = 1 as libc::c_int;
    #[c2rust::src_loc = "179:10"]
    pub const FALSE: libc::c_int = 0 as libc::c_int;
    #[c2rust::src_loc = "180:10"]
    pub const TRUE: libc::c_int = 1 as libc::c_int;
    // NVIM_VIM_H
    // Replacement for nchar used by nv_replace().
    // BSD is supposed to cover FreeBSD and similar systems.
    // Lowest number used for window ID. Cannot have this many windows per tab.
    // only use "after" directories
    // skip "after" directories
    // do not use 'runtimepath'
    // also use "opt" directory in 'packpath'
    // also use "start" directory in 'packpath'
    // give an error message when none found
    // find directories instead of files
    // all matches, not just the first one
    // Used for flags in do_in_path()
    // Ex command defines
    // buffer and windows
    // This has to go after the include of proto.h, as proto/gui.pro declares
// functions of these names. The declarations would break if the defines had
// been seen at that stage.  But it must be before globals.h, where error_ga
// is declared.
    // / Maximum number of bytes in a multi-byte character.  It can be one 32-bit
// / character of up to 6 bytes, or one 16-bit character of up to three bytes
// / plus six following composing characters of three bytes each.
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/message.h:47"]
pub mod message_h {
    #[c2rust::src_loc = "17:9"]
    pub const VIM_WARNING: libc::c_int = 2 as libc::c_int;
    // NVIM_MESSAGE_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/screen.h.generated.h:49"]
pub mod screen_h_generated_h {
    use super::buffer_defs_h::buf_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "60:1"]
        pub fn get_trans_bufname(buf: *mut buf_T);
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn redraw_curbuf_later(type_0: libc::c_int);
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/buffer.h.generated.h:49"]
pub mod buffer_h_generated_h {
    use super::ex_cmds_defs_h::exarg_T;
    use super::buffer_defs_h::buf_T;
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "4:1"]
        pub fn open_buffer(read_stdin: libc::c_int, eap: *mut exarg_T,
                           flags: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "38:1"]
        pub fn setfname(buf: *mut buf_T, ffname: *mut char_u,
                        sfname: *mut char_u, message: bool) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "67:1"]
        pub fn buf_spname(buf: *mut buf_T) -> *mut char_u;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/buffer.h:49"]
pub mod buffer_h {
    // for linenr_T
    // for exarg_T
    // Values for buflist_getfile()
    // set pcmark before jumping
    // jumping to alternate file (not buf num)
    // respect 'switchbuf' settings when jumping
    // Return values of getfile()
    // normal error
    // "not written" error
    // success, same file
    // success, opened another file
    // Values for buflist_new() flags
    // May re-use curbuf for new buffer
    // Put new buffer in buffer list
    // Allocating dummy buffer
    // create a new buffer
    // Don't copy options to existing buffer
    // Values for action argument for do_buffer()
    // go to specified buffer
    // split window and go to specified buffer
    // unload specified buffer(s)
    // delete specified buffer(s) from buflist
    // delete specified buffer(s) really
    // Values for start argument for do_buffer()
    // "count" buffer from current buffer
    // "count" buffer from first buffer
    // "count" buffer from last buffer
    // "count" mod. buffer from current buffer
    // flags for buf_freeall()
    // buffer is going to be deleted
    // buffer is going to be wiped out
    // do not free undo information
    // / Set b:changedtick, also checking b: for consistency in debug build
// /
// / @param[out]  buf  Buffer to set changedtick in.
// / @param[in]  changedtick  New value.
    // For some reason formatc does not like the below.
    // / Get b:changedtick value
// /
// / Faster then querying b:.
// /
// / @param[in]  buf  Buffer to get b:changedtick from.
    // / Increment b:changedtick value
// /
// / Also checks b: for consistency in case of debug build.
// /
// / @param[in,out]  buf  Buffer to increment value in.
    #[inline(always)]
    #[c2rust::src_loc = "123:1"]
    pub unsafe extern "C" fn buf_inc_changedtick(buf: *mut buf_T) {
        buf_set_changedtick(buf,
                            buf_get_changedtick(buf) +
                                1 as libc::c_int as libc::c_long);
    }
    #[inline(always)]
    #[c2rust::src_loc = "110:1"]
    pub unsafe extern "C" fn buf_get_changedtick(buf: *const buf_T)
     -> varnumber_T {
        return (*buf).changedtick_di.di_tv.vval.v_number;
    }
    #[inline(always)]
    #[c2rust::src_loc = "74:1"]
    pub unsafe extern "C" fn buf_set_changedtick(buf: *mut buf_T,
                                                 changedtick: varnumber_T) {
        let mut old_val = (*buf).changedtick_di.di_tv;
        let changedtick_di =
            tv_dict_find((*buf).b_vars,
                         b"changedtick\x00" as *const u8 as
                             *const libc::c_char,
                         (::std::mem::size_of::<[libc::c_char; 12]>() as
                              libc::c_ulong).wrapping_sub(1 as libc::c_int as
                                                              libc::c_ulong)
                             as ptrdiff_t);
        if !changedtick_di.is_null() {
        } else {
            __assert_fail(b"changedtick_di != NULL\x00" as *const u8 as
                              *const libc::c_char,
                          b"../src/nvim/buffer.h\x00" as *const u8 as
                              *const libc::c_char,
                          82 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 58],
                                                    &[libc::c_char; 58]>(b"void buf_set_changedtick(buf_T *const, const varnumber_T)\x00")).as_ptr());
        }
        if (*changedtick_di).di_tv.v_type as libc::c_uint ==
               VAR_NUMBER as libc::c_int as libc::c_uint {
        } else {
            __assert_fail(b"changedtick_di->di_tv.v_type == VAR_NUMBER\x00" as
                              *const u8 as *const libc::c_char,
                          b"../src/nvim/buffer.h\x00" as *const u8 as
                              *const libc::c_char,
                          83 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 58],
                                                    &[libc::c_char; 58]>(b"void buf_set_changedtick(buf_T *const, const varnumber_T)\x00")).as_ptr());
        }
        if (*changedtick_di).di_tv.v_lock as libc::c_uint ==
               VAR_FIXED as libc::c_int as libc::c_uint {
        } else {
            __assert_fail(b"changedtick_di->di_tv.v_lock == VAR_FIXED\x00" as
                              *const u8 as *const libc::c_char,
                          b"../src/nvim/buffer.h\x00" as *const u8 as
                              *const libc::c_char,
                          84 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 58],
                                                    &[libc::c_char; 58]>(b"void buf_set_changedtick(buf_T *const, const varnumber_T)\x00")).as_ptr());
        }
        if (*changedtick_di).di_flags as libc::c_int ==
               DI_FLAGS_RO as libc::c_int | DI_FLAGS_FIX as libc::c_int {
        } else {
            __assert_fail(b"changedtick_di->di_flags == (DI_FLAGS_RO|DI_FLAGS_FIX)\x00"
                              as *const u8 as *const libc::c_char,
                          b"../src/nvim/buffer.h\x00" as *const u8 as
                              *const libc::c_char,
                          87 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 58],
                                                    &[libc::c_char; 58]>(b"void buf_set_changedtick(buf_T *const, const varnumber_T)\x00")).as_ptr());
        }
        if changedtick_di ==
               &mut (*buf).changedtick_di as *mut ChangedtickDictItem as
                   *mut dictitem_T {
        } else {
            __assert_fail(b"changedtick_di == (dictitem_T *)&buf->changedtick_di\x00"
                              as *const u8 as *const libc::c_char,
                          b"../src/nvim/buffer.h\x00" as *const u8 as
                              *const libc::c_char,
                          89 as libc::c_int as libc::c_uint,
                          (*::std::mem::transmute::<&[u8; 58],
                                                    &[libc::c_char; 58]>(b"void buf_set_changedtick(buf_T *const, const varnumber_T)\x00")).as_ptr());
        }
        (*buf).changedtick_di.di_tv.vval.v_number = changedtick;
        if tv_dict_is_watched((*buf).b_vars) {
            tv_dict_watcher_notify((*buf).b_vars,
                                   (*buf).changedtick_di.di_key.as_mut_ptr()
                                       as *mut libc::c_char,
                                   &mut (*buf).changedtick_di.di_tv,
                                   &mut old_val);
        };
    }
    use super::buffer_defs_h::{buf_T, ChangedtickDictItem};
    use super::typval_h::{varnumber_T, typval_T, dictitem_T, VarType,
                          VAR_NUMBER, VarLockStatus, VAR_FIXED, DI_FLAGS_RO,
                          DI_FLAGS_FIX, tv_dict_is_watched};
    use super::typval_h_generated_h::{tv_dict_find, tv_dict_watcher_notify};
    use super::stddef_h::ptrdiff_t;
    use super::assert_h::__assert_fail;
    use super::stdint_uintn_h::uint8_t;
    // NVIM_BUFFER_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/main.h.generated.h:49"]
pub mod main_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "9:1"]
        pub fn getout(exitval: libc::c_int) -> !;
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/screen.h:49"]
pub mod screen_h {
    /*
 * flags for update_screen()
 * The higher the value, the higher the priority
 */
    /* buffer not changed, or changes marked
                                       with b_mod_* */
    /* redisplay inverted part that changed */
    /* redisplay whole inverted part */
    /* display first w_upd_rows screen lines */
    /* like NOT_VALID but may scroll */
    #[c2rust::src_loc = "21:9"]
    pub const NOT_VALID: libc::c_int = 40 as libc::c_int;
    // NVIM_SCREEN_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/eval.h.generated.h:49"]
pub mod eval_h_generated_h {
    use super::eval_h::{VimVarIndex, VV_COUNT};
    use super::stddef_h::ptrdiff_t;
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "126:1"]
        pub fn set_vim_var_string(idx: VimVarIndex, val: *const libc::c_char,
                                  len: ptrdiff_t);
        #[no_mangle]
        #[c2rust::src_loc = "119:1"]
        pub fn get_vim_var_str(idx: libc::c_int) -> *mut char_u;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/change.h.generated.h:50"]
pub mod change_h_generated_h {
    use super::buffer_defs_h::buf_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "6:1"]
        pub fn changed_internal();
        #[no_mangle]
        #[c2rust::src_loc = "14:1"]
        pub fn unchanged(buf: *mut buf_T, ff: libc::c_int,
                         always_inc_changedtick: bool);
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/cursor.h.generated.h:51"]
pub mod cursor_h_generated_h {
    use super::pos_h::colnr_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn coladvance(wcol: colnr_T) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "16:1"]
        pub fn check_cursor();
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/getchar.h.generated.h:53"]
pub mod getchar_h_generated_h {
    use super::getchar_h::{flush_buffers_T, FLUSH_MINIMAL};
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn flush_buffers(flush_typeahead: flush_buffers_T);
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/fs.h.generated.h:54"]
pub mod fs_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::fs_defs_h::FileInfo;
    use super::stdint_intn_h::int32_t;
    use super::stdint_uintn_h::uint64_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn os_isdir(name: *const char_u) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "40:1"]
        pub fn os_fileinfo(path: *const libc::c_char,
                           file_info: *mut FileInfo) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "39:1"]
        pub fn os_remove(path: *const libc::c_char) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "27:1"]
        pub fn os_path_exists(path: *const char_u) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "33:1"]
        pub fn os_mkdir_recurse(dir: *const libc::c_char, mode: int32_t,
                                failed_dir: *mut *mut libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "13:1"]
        pub fn os_open(path: *const libc::c_char, flags: libc::c_int,
                       mode: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "15:1"]
        pub fn os_set_cloexec(fd: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "46:1"]
        pub fn os_fileinfo_size(file_info: *const FileInfo) -> uint64_t;
        #[no_mangle]
        #[c2rust::src_loc = "41:1"]
        pub fn os_fileinfo_link(path: *const libc::c_char,
                                file_info: *mut FileInfo) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "45:1"]
        pub fn os_fileinfo_inode(file_info: *const FileInfo) -> uint64_t;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/users.h.generated.h:54"]
pub mod users_h_generated_h {
    use super::unix_h::uv_uid_t;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "6:1"]
        pub fn os_get_uname(uid: uv_uid_t, s: *mut libc::c_char, len: size_t)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn os_get_user_name(s: *mut libc::c_char, len: size_t)
         -> libc::c_int;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/fileio.h.generated.h:54"]
pub mod fileio_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::buffer_defs_h::buf_T;
    use super::fs_defs_h::FileInfo;
    use super::auevents_enum_generated_h::{event_T, EVENT_BUFADD};
    use super::stddef_h::size_t;
    use super::pos_h::linenr_T;
    use super::ex_cmds_defs_h::exarg_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "22:1"]
        pub fn vim_rename(from: *const char_u, to: *const char_u)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "26:1"]
        pub fn buf_store_file_info(buf: *mut buf_T, file_info: *mut FileInfo);
        #[no_mangle]
        #[c2rust::src_loc = "29:1"]
        pub fn vim_deltempdir();
        #[no_mangle]
        #[c2rust::src_loc = "31:1"]
        pub fn vim_tempname() -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "13:1"]
        pub fn modname(fname: *const libc::c_char, ext: *const libc::c_char,
                       prepend_dot: bool) -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "52:1"]
        pub fn has_autocmd(event: event_T, sfname: *mut char_u,
                           buf: *mut buf_T) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "44:1"]
        pub fn apply_autocmds(event: event_T, fname: *mut char_u,
                              fname_io: *mut char_u, force: bool,
                              buf: *mut buf_T) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "60:1"]
        pub fn read_eintr(fd: libc::c_int, buf: *mut libc::c_void,
                          bufsize: size_t) -> libc::c_long;
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn readfile(fname: *mut char_u, sfname: *mut char_u,
                        from: linenr_T, lines_to_skip: linenr_T,
                        lines_to_read: linenr_T, eap: *mut exarg_T,
                        flags: libc::c_int) -> libc::c_int;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/env.h.generated.h:54"]
pub mod env_h_generated_h {
    use super::buffer_defs_h::buf_T;
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    use super::stdint_intn_h::int64_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "26:1"]
        pub fn home_replace(buf: *const buf_T, src: *const char_u,
                            dst: *mut char_u, dstlen: size_t, one: bool)
         -> size_t;
        #[no_mangle]
        #[c2rust::src_loc = "20:1"]
        pub fn expand_env(src: *mut char_u, dst: *mut char_u,
                          dstlen: libc::c_int);
        #[no_mangle]
        #[c2rust::src_loc = "15:1"]
        pub fn os_get_pid() -> int64_t;
        #[no_mangle]
        #[c2rust::src_loc = "16:1"]
        pub fn os_get_hostname(hostname: *mut libc::c_char, size: size_t);
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/fileio.h:54"]
pub mod nvim_fileio_h {
    #[c2rust::src_loc = "8:9"]
    pub const READ_NEW: libc::c_int = 0x1 as libc::c_int;
    // NVIM_FILEIO_H
    // Events for autocommands
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/mark.h.generated.h:57"]
pub mod mark_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "9:1"]
        pub fn setpcmark();
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/mark.h:57"]
pub mod mark_h {
    // for exarg_T
    // / Set fmark using given value
    // / Free and set fmark using given value
    // / Clear given fmark
    // / Set given extended mark (regular mark + file name)
    // / Free and set given extended mark (regular mark + file name)
    // / Convert mark name to the offset
    #[inline]
    #[c2rust::src_loc = "55:1"]
    pub unsafe extern "C" fn mark_global_index(name: libc::c_char)
     -> libc::c_int {
        return if name as libc::c_uint >= 'A' as i32 as libc::c_uint &&
                      name as libc::c_uint <= 'Z' as i32 as libc::c_uint {
                   (name as libc::c_int) - 'A' as i32
               } else if ascii_isdigit(name as libc::c_int) as libc::c_int !=
                             0 {
                   (NMARKS) + (name as libc::c_int - '0' as i32)
               } else { -(1 as libc::c_int) };
    }
    // / Convert local mark name to the offset
    #[inline]
    #[c2rust::src_loc = "66:1"]
    pub unsafe extern "C" fn mark_local_index(name: libc::c_char)
     -> libc::c_int {
        return if name as libc::c_uint >= 'a' as i32 as libc::c_uint &&
                      name as libc::c_uint <= 'z' as i32 as libc::c_uint {
                   (name as libc::c_int) - 'a' as i32
               } else if name as libc::c_int == '\"' as i32 {
                   NMARKS
               } else if name as libc::c_int == '^' as i32 {
                   (NMARKS) + 1 as libc::c_int
               } else if name as libc::c_int == '.' as i32 {
                   (NMARKS) + 2 as libc::c_int
               } else { -(1 as libc::c_int) };
    }
    // / Return true if position a is before (less than) position b.
    #[inline(always)]
    #[c2rust::src_loc = "89:1"]
    pub unsafe extern "C" fn lt(mut a: pos_T, mut b: pos_T) -> bool {
        if a.lnum != b.lnum {
            return a.lnum < b.lnum
        } else if a.col != b.col {
            return a.col < b.col
        } else { return a.coladd < b.coladd };
    }
    // / Return true if position a and b are equal.
    #[inline(always)]
    #[c2rust::src_loc = "101:1"]
    pub unsafe extern "C" fn equalpos(mut a: pos_T, mut b: pos_T) -> bool {
        return a.lnum == b.lnum && a.col == b.col && a.coladd == b.coladd;
    }
    // / Return true if position a is less than or equal to b.
    #[inline(always)]
    #[c2rust::src_loc = "107:1"]
    pub unsafe extern "C" fn ltoreq(mut a: pos_T, mut b: pos_T) -> bool {
        return lt(a, b) as libc::c_int != 0 ||
                   equalpos(a, b) as libc::c_int != 0;
    }
    // / Clear the pos_T structure pointed to by a.
    #[inline(always)]
    #[c2rust::src_loc = "113:1"]
    pub unsafe extern "C" fn clearpos(mut a: *mut pos_T) {
        (*a).lnum = 0 as libc::c_int as linenr_T;
        (*a).col = 0 as libc::c_int;
        (*a).coladd = 0 as libc::c_int;
    }
    use super::ascii_h::ascii_isdigit;
    use super::mark_defs_h::NMARKS;
    use super::pos_h::{pos_T, linenr_T, colnr_T};
    // NVIM_MARK_H
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/memfile.h.generated.h:59"]
pub mod memfile_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::memfile_defs_h::{memfile_T, blocknr_T, bhdr_T};
    use super::buffer_defs_h::buf_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "4:1"]
        pub fn mf_open(fname: *mut char_u, flags: libc::c_int)
         -> *mut memfile_T;
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn mf_open_file(mfp: *mut memfile_T, fname: *mut char_u)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "6:1"]
        pub fn mf_close(mfp: *mut memfile_T, del_file: bool);
        #[no_mangle]
        #[c2rust::src_loc = "7:1"]
        pub fn mf_close_file(buf: *mut buf_T, getlines: bool);
        #[no_mangle]
        #[c2rust::src_loc = "8:1"]
        pub fn mf_new_page_size(mfp: *mut memfile_T, new_size: libc::c_uint);
        #[no_mangle]
        #[c2rust::src_loc = "20:1"]
        pub fn mf_need_trans(mfp: *mut memfile_T) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn mf_get(mfp: *mut memfile_T, nr: blocknr_T,
                      page_count: libc::c_uint) -> *mut bhdr_T;
        #[no_mangle]
        #[c2rust::src_loc = "11:1"]
        pub fn mf_put(mfp: *mut memfile_T, hp: *mut bhdr_T, dirty: bool,
                      infile: bool);
        #[no_mangle]
        #[c2rust::src_loc = "16:1"]
        pub fn mf_trans_del(mfp: *mut memfile_T, old_nr: blocknr_T)
         -> blocknr_T;
        #[no_mangle]
        #[c2rust::src_loc = "17:1"]
        pub fn mf_free_fnames(mfp: *mut memfile_T);
        #[no_mangle]
        #[c2rust::src_loc = "18:1"]
        pub fn mf_set_fnames(mfp: *mut memfile_T, fname: *mut char_u);
        #[no_mangle]
        #[c2rust::src_loc = "9:1"]
        pub fn mf_new(mfp: *mut memfile_T, negative: bool,
                      page_count: libc::c_uint) -> *mut bhdr_T;
        #[no_mangle]
        #[c2rust::src_loc = "12:1"]
        pub fn mf_free(mfp: *mut memfile_T, hp: *mut bhdr_T);
        #[no_mangle]
        #[c2rust::src_loc = "13:1"]
        pub fn mf_sync(mfp: *mut memfile_T, flags: libc::c_int)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "14:1"]
        pub fn mf_set_dirty(mfp: *mut memfile_T);
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/memfile.h:59"]
pub mod memfile_h {
    // / flags for mf_sync()
    // / also sync blocks with negative numbers
    #[c2rust::src_loc = "9:9"]
    pub const MFS_STOP: libc::c_int = 2 as libc::c_int;
    #[c2rust::src_loc = "8:9"]
    pub const MFS_ALL: libc::c_int = 1 as libc::c_int;
    // / stop syncing when a character is available
    #[c2rust::src_loc = "10:9"]
    pub const MFS_FLUSH: libc::c_int = 4 as libc::c_int;
    // / flushed file to disk
    #[c2rust::src_loc = "11:9"]
    pub const MFS_ZERO: libc::c_int = 8 as libc::c_int;
    // NVIM_MEMFILE_H
    // / only write block 0
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/misc1.h.generated.h:62"]
pub mod misc1_h_generated_h {
    use super::nvim_types_h::char_u;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "20:1"]
        pub fn get_number(colon: libc::c_int, mouse_used: *mut libc::c_int)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "28:1"]
        pub fn line_breakcheck();
        #[no_mangle]
        #[c2rust::src_loc = "32:1"]
        pub fn FreeWild(count: libc::c_int, files: *mut *mut char_u);
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/option.h.generated.h:63"]
pub mod option_h_generated_h {
    use super::buffer_defs_h::buf_T;
    use super::nvim_types_h::char_u;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "30:1"]
        pub fn set_option_value(name: *const libc::c_char,
                                number: libc::c_long,
                                string: *const libc::c_char,
                                opt_flags: libc::c_int) -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "64:1"]
        pub fn get_fileformat(buf: *mut buf_T) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "67:1"]
        pub fn set_fileformat(eol_style: libc::c_int, opt_flags: libc::c_int);
        #[no_mangle]
        #[c2rust::src_loc = "69:1"]
        pub fn copy_option_part(option: *mut *mut char_u, buf: *mut char_u,
                                maxlen: size_t, sep_chars: *mut libc::c_char)
         -> size_t;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/path.h.generated.h:65"]
pub mod path_h_generated_h {
    use super::nvim_types_h::char_u;
    use super::path_h::FileComparison;
    use super::stddef_h::size_t;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "4:1"]
        pub fn path_full_compare(s1: *mut char_u, s2: *mut char_u,
                                 checkname: bool, expandenv: bool)
         -> FileComparison;
        #[no_mangle]
        #[c2rust::src_loc = "5:1"]
        pub fn path_tail(fname: *const char_u) -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn vim_ispathsep(c: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "13:1"]
        pub fn shorten_dir(str: *mut char_u) -> *mut char_u;
        #[no_mangle]
        #[c2rust::src_loc = "15:1"]
        pub fn path_fnamecmp(fname1: *const libc::c_char,
                             fname2: *const libc::c_char) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "17:1"]
        pub fn concat_fnames(fname1: *const libc::c_char,
                             fname2: *const libc::c_char, sep: bool)
         -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "32:1"]
        pub fn vim_FullName(fname: *const libc::c_char,
                            buf: *mut libc::c_char, len: size_t, force: bool)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "33:1"]
        pub fn fix_fname(fname: *const libc::c_char) -> *mut libc::c_char;
        #[no_mangle]
        #[c2rust::src_loc = "35:1"]
        pub fn after_pathsep(b: *const libc::c_char, p: *const libc::c_char)
         -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "36:1"]
        pub fn same_directory(f1: *mut char_u, f2: *mut char_u) -> bool;
        #[no_mangle]
        #[c2rust::src_loc = "41:1"]
        pub fn expand_wildcards(num_pat: libc::c_int, pat: *mut *mut char_u,
                                num_files: *mut libc::c_int,
                                files: *mut *mut *mut char_u,
                                flags: libc::c_int) -> libc::c_int;
        #[no_mangle]
        #[c2rust::src_loc = "45:1"]
        pub fn path_is_absolute(fname: *const char_u) -> libc::c_int;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/spell.h.generated.h:68"]
pub mod spell_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "17:1"]
        pub fn spell_delete_wordlist();
    }
}
#[c2rust::header_src = "/home/vole/neovim/build/include/ui.h.generated.h:70"]
pub mod ui_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "26:1"]
        pub fn ui_flush();
    }
}
#[c2rust::header_src = "/home/vole/neovim/src/nvim/version.h:71"]
pub mod version_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "7:14"]
        pub static mut Version: *mut libc::c_char;
    }
    // NVIM_VERSION_H
    // swap file compatibility (max. length is 6 chars)
    // used for the runtime directory name
    //
// Vim version number, name, etc. Patchlevel is defined in version.c.
//
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/undo.h.generated.h:72"]
pub mod undo_h_generated_h {
    use super::buffer_defs_h::buf_T;
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "30:1"]
        pub fn bufIsChanged(buf: *mut buf_T) -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/process.h.generated.h:75"]
pub mod process_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "6:1"]
        pub fn os_proc_running(pid: libc::c_int) -> bool;
    }
}
#[c2rust::header_src =
  "/home/vole/neovim/build/include/os/input.h.generated.h:76"]
pub mod input_h_generated_h {
    extern "C" {
        #[no_mangle]
        #[c2rust::src_loc = "10:1"]
        pub fn os_char_avail() -> bool;
    }
}
pub use self::internal::{__builtin_va_list, __va_list_tag};
pub use self::types_h::{__int8_t, __uint8_t, __int16_t, __uint16_t, __int32_t,
                        __uint32_t, __int64_t, __uint64_t, __uid_t, __gid_t,
                        __off_t, __time_t, __ssize_t};
pub use self::stdint_intn_h::{int8_t, int16_t, int32_t, int64_t};
pub use self::stdint_uintn_h::{uint8_t, uint16_t, uint32_t, uint64_t};
pub use self::stddef_h::{size_t, ptrdiff_t, NULL_0, NULL, NULL_1};
pub use self::struct_iovec_h::iovec;
pub use self::fcntl_h::off_t;
pub use self::stdarg_h::va_list;
pub use self::stdio_h::{ssize_t, SEEK_END};
pub use self::sys_types_h::{gid_t, uid_t};
pub use self::time_t_h::time_t;
pub use self::pthreadtypes_arch_h::__pthread_rwlock_arch_t;
pub use self::thread_shared_types_h::{__pthread_internal_list,
                                      __pthread_list_t, __pthread_mutex_s};
pub use self::pthreadtypes_h::{pthread_mutex_t, pthread_rwlock_t};
pub use self::nvim_types_h::{char_u, handle_T, LuaRef};
pub use self::typval_h::{sctx_T, scid_T, varnumber_T, float_T, listvar_S,
                         VarLockStatus, VAR_FIXED, VAR_LOCKED, VAR_UNLOCKED,
                         list_T, listitem_T, listitem_S, typval_T,
                         typval_vval_union, partial_T, partial_S, dict_T,
                         dictvar_S, ScopeType, VAR_DEF_SCOPE, VAR_SCOPE,
                         VAR_NO_SCOPE, ufunc_T, ufunc, funccall_T,
                         SpecialVarValue, kSpecialVarNull, kSpecialVarTrue,
                         kSpecialVarFalse, VarType, VAR_PARTIAL, VAR_SPECIAL,
                         VAR_FLOAT, VAR_DICT, VAR_LIST, VAR_FUNC, VAR_STRING,
                         VAR_NUMBER, VAR_UNKNOWN, listwatch_T, listwatch_S,
                         CallbackType, kCallbackPartial, kCallbackFuncref,
                         kCallbackNone, Callback, C2RustUnnamed_1,
                         dict_watcher, DictWatcher, ScopeDictDictItem,
                         dictitem_T, C2RustUnnamed_2, DI_FLAGS_ALLOC,
                         DI_FLAGS_LOCK, DI_FLAGS_FIX, DI_FLAGS_RO_SBX,
                         DI_FLAGS_RO, tv_list_ref, tv_list_set_ret,
                         tv_list_locked, tv_list_set_lock, tv_list_set_copyid,
                         tv_list_len, tv_list_copyid, tv_list_latest_copy,
                         tv_list_uidx, tv_list_has_watchers, tv_list_first,
                         tv_list_last, tv_dict_set_ret, tv_dict_len,
                         tv_dict_is_watched, tv_init, tv_get_float_chk,
                         tv_dict_watcher_node_data, tv_is_func, funccall_S};
pub use self::pos_h::{linenr_T, colnr_T, C2RustUnnamed, MAXLNUM,
                      C2RustUnnamed_0, MAXCOL, pos_T, lpos_T};
pub use self::hashtab_h::{hash_T, hashitem_S, hashitem_T, hashtable_S,
                          hashtab_T};
pub use self::garray_h::{growarray, garray_T, ga_append_via_ptr, ga_grow};
pub use self::queue_h::{_queue, QUEUE, QUEUE_EMPTY, QUEUE_INIT, QUEUE_ADD,
                        QUEUE_INSERT_HEAD, QUEUE_INSERT_TAIL, QUEUE_REMOVE};
pub use self::profile_h::proftime_T;
pub use self::grid_defs_h::{schar_T, sattr_T, ScreenGrid};
pub use self::buffer_defs_h::{file_buffer, C2RustUnnamed_3,
                              BufUpdateCallbacks, C2RustUnnamed_4, synblock_T,
                              buf_T, win_T, window_S, qf_info_T, FloatConfig,
                              WinStyle, kWinStyleMinimal, kWinStyleUnused,
                              FloatRelative, kFloatRelativeCursor,
                              kFloatRelativeWindow, kFloatRelativeEditor,
                              FloatAnchor, taggy_T, taggy, matchitem_T,
                              matchitem, match_T, posmatch_T, posmatch,
                              llpos_T, winopt_T, alist_T, arglist, wline_T,
                              w_line, pos_save_T, C2RustUnnamed_5,
                              C2RustUnnamed_6, frame_T, frame_S, disptick_T,
                              syn_time_T, mapblock_T, mapblock, wininfo_T,
                              wininfo_S, ChangedtickDictItem, win_hl_attr,
                              BF_PRESERVED, BF_DUMMY, BF_RECOVERED,
                              qf_info_S};
pub use self::map_h::{Map_uint64_t_ExtmarkNs, kh_uint64_t_ExtmarkNs_map_t,
                      ExtmarkNs, Map_uint64_t_uint64_t,
                      kh_uint64_t_uint64_t_map_t, Map_uint64_t_ExtmarkItem,
                      kh_uint64_t_ExtmarkItem_map_t, Map_uint64_t_ptr_t,
                      kh_uint64_t_ptr_t_map_t, kh_cstr_t_ptr_t_map_t,
                      Map_cstr_t_ptr_t, map_uint64_t_ptr_t_get};
pub use self::khash_h::{khint32_t, khint_t, __ac_X31_hash_string,
                        __ac_Wang_hash};
pub use self::extmark_defs_h::{ExtmarkItem, VirtText, VirtTextChunk,
                               extmark_undo_vec_t, ExtmarkUndoObject,
                               undo_object};
pub use self::marktree_h::{MarkTree, mtnode_t, mtnode_s, mtkey_t, mtpos_t};
pub use self::map_defs_h::{ptr_t, cstr_t};
pub use self::terminal_h::{Terminal, terminal};
pub use self::sign_defs_h::{signlist_T, signlist, signgroup_T, signgroup_S};
pub use self::regexp_defs_h::{regprog_T, regprog, regengine_T, regengine,
                              regmmatch_T, regmatch_T, reg_extmatch_T,
                              reg_extmatch};
pub use self::defs_h::{Window, Boolean, Integer, Float, String_0, object,
                       C2RustUnnamed_14, Dictionary, KeyValuePair,
                       key_value_pair, Object, Array, ObjectType,
                       kObjectTypeTabpage, kObjectTypeWindow,
                       kObjectTypeBuffer, kObjectTypeLuaRef,
                       kObjectTypeDictionary, kObjectTypeArray,
                       kObjectTypeString, kObjectTypeFloat,
                       kObjectTypeInteger, kObjectTypeBoolean, kObjectTypeNil,
                       is_internal_call};
pub use self::mark_defs_h::{fmark_T, filemark, xfmark_T, xfilemark, NMARKS};
pub use self::time_h::Timestamp;
pub use self::option_defs_h::{LastSet, C2RustUnnamed_13, SHM_SEARCHCOUNT,
                              SHM_FILEINFO, SHM_RECORDING, SHM_COMPLETIONMENU,
                              SHM_INTRO, SHM_ATTENTION, SHM_SEARCH,
                              SHM_OVERALL, SHM_OVER, SHM_TRUNCALL, SHM_TRUNC,
                              SHM_WRITE, SHM_ABBREVIATIONS, SHM_WRI, SHM_NEW,
                              SHM_LINES, SHM_TEXT, SHM_LAST, SHM_FILE,
                              SHM_MOD, SHM_RO, EOL_DOS, p_dir, p_shm, p_uc,
                              p_verbose};
pub use self::syntax_defs_h::{synstate_T, syn_state, C2RustUnnamed_7,
                              bufstate_T, buf_state};
pub use self::undo_defs_h::{u_header_T, u_header, visualinfo_T, u_entry_T,
                            u_entry, C2RustUnnamed_8, C2RustUnnamed_9,
                            C2RustUnnamed_10, C2RustUnnamed_11};
pub use self::fs_defs_h::{FileID, FileInfo};
pub use self::memline_defs_h::{memline_T, memline, chunksize_T, ml_chunksize,
                               infoptr_T, info_pointer, ML_CHNK_UPDLINE,
                               ML_CHNK_ADDLINE, ML_LOCKED_DIRTY,
                               ML_LOCKED_POS, ML_CHNK_DELLINE, ML_LINE_DIRTY,
                               ML_EMPTY};
pub use self::memfile_defs_h::{bhdr_T, bhdr, mf_hashitem_T, mf_hashitem,
                               blocknr_T, memfile_T, memfile, mf_hashtab_T,
                               mf_hashtab, BH_DIRTY};
pub use self::highlight_defs_h::{C2RustUnnamed_12, HLF_COUNT, HLF_MSG,
                                 HLF_NFLOAT, HLF_MSGSEP, HLF_INACTIVE, HLF_0,
                                 HLF_QFL, HLF_MC, HLF_CUL, HLF_CUC, HLF_TPF,
                                 HLF_TPS, HLF_TP, HLF_PST, HLF_PSB, HLF_PSI,
                                 HLF_PNI, HLF_SPL, HLF_SPR, HLF_SPC, HLF_SPB,
                                 HLF_CONCEAL, HLF_SC, HLF_TXD, HLF_DED,
                                 HLF_CHD, HLF_ADD, HLF_FC, HLF_FL, HLF_WM,
                                 HLF_W, HLF_VNC, HLF_V, HLF_T, HLF_C, HLF_SNC,
                                 HLF_S, HLF_R, HLF_CLN, HLF_N, HLF_CM, HLF_M,
                                 HLF_L, HLF_I, HLF_E, HLF_D, HLF_AT,
                                 HLF_TERMNC, HLF_TERM, HLF_EOB, HLF_8,
                                 highlight_attr};
pub use self::uv_h::{uv_loop_s, uv_signal_t, uv_signal_s, C2RustUnnamed_15,
                     uv_signal_cb, uv_handle_t, uv_handle_s, C2RustUnnamed_16,
                     uv_close_cb, uv_handle_type, UV_HANDLE_TYPE_MAX, UV_FILE,
                     UV_SIGNAL, UV_UDP, UV_TTY, UV_TIMER, UV_TCP, UV_STREAM,
                     UV_PROCESS, UV_PREPARE, UV_POLL, UV_NAMED_PIPE, UV_IDLE,
                     UV_HANDLE, UV_FS_POLL, UV_FS_EVENT, UV_CHECK, UV_ASYNC,
                     UV_UNKNOWN_HANDLE, uv_loop_t, C2RustUnnamed_17,
                     C2RustUnnamed_18, uv_async_t, uv_async_s, uv_async_cb,
                     C2RustUnnamed_19, C2RustUnnamed_20, uv_req_type,
                     UV_REQ_TYPE_MAX, UV_GETNAMEINFO, UV_GETADDRINFO, UV_WORK,
                     UV_FS, UV_UDP_SEND, UV_SHUTDOWN, UV_WRITE, UV_CONNECT,
                     UV_REQ, UV_UNKNOWN_REQ, uv_stream_s, uv_connection_cb,
                     uv_stream_t, uv_shutdown_t, uv_shutdown_s,
                     uv_shutdown_cb, uv_connect_t, uv_connect_s,
                     uv_connect_cb, uv_read_cb, uv_alloc_cb, C2RustUnnamed_21,
                     uv_tcp_s, C2RustUnnamed_22, uv_tcp_t, uv_pipe_s,
                     C2RustUnnamed_23, uv_pipe_t, uv_timer_s, uv_timer_cb,
                     uv_timer_t, C2RustUnnamed_24, uv_idle_s, uv_idle_cb,
                     uv_idle_t, C2RustUnnamed_25, uv_process_s, uv_exit_cb,
                     uv_process_t, C2RustUnnamed_26, uv_stat_t, uv_timespec_t,
                     uv_stdio_flags, UV_OVERLAPPED_PIPE, UV_WRITABLE_PIPE,
                     UV_READABLE_PIPE, UV_INHERIT_STREAM, UV_INHERIT_FD,
                     UV_CREATE_PIPE, UV_IGNORE, uv_stdio_container_s,
                     C2RustUnnamed_27, uv_stdio_container_t,
                     uv_process_options_s, uv_process_options_t, uv_strerror};
pub use self::unix_h::{uv__io_t, uv__io_s, uv__io_cb, uv_rwlock_t, uv_mutex_t,
                       uv_buf_t, uv_file, uv_gid_t, uv_uid_t};
pub use self::ex_cmds_enum_generated_h::{CMD_index, CMD_USER_BUF, CMD_USER,
                                         CMD_SIZE, CMD_tilde, CMD_Next,
                                         CMD_at, CMD_rshift, CMD_equal,
                                         CMD_lshift, CMD_and, CMD_pound,
                                         CMD_bang, CMD_z, CMD_yank,
                                         CMD_xunmenu, CMD_xunmap,
                                         CMD_xnoremenu, CMD_xnoremap,
                                         CMD_xmenu, CMD_xmapclear, CMD_xmap,
                                         CMD_xall, CMD_xit, CMD_wviminfo,
                                         CMD_wundo, CMD_wshada, CMD_wqall,
                                         CMD_wq, CMD_wprevious, CMD_wnext,
                                         CMD_winpos, CMD_windo, CMD_wincmd,
                                         CMD_winsize, CMD_while, CMD_wall,
                                         CMD_wNext, CMD_write, CMD_vunmenu,
                                         CMD_vunmap, CMD_vsplit,
                                         CMD_vnoremenu, CMD_vnew,
                                         CMD_vnoremap, CMD_vmenu,
                                         CMD_vmapclear, CMD_vmap, CMD_viusage,
                                         CMD_vimgrepadd, CMD_vimgrep,
                                         CMD_view, CMD_visual, CMD_vertical,
                                         CMD_verbose, CMD_version,
                                         CMD_vglobal, CMD_update,
                                         CMD_unsilent, CMD_unmenu, CMD_unmap,
                                         CMD_unlockvar, CMD_unlet, CMD_unhide,
                                         CMD_unabbreviate, CMD_undolist,
                                         CMD_undojoin, CMD_undo, CMD_tunmap,
                                         CMD_tunmenu, CMD_tselect, CMD_try,
                                         CMD_trewind, CMD_tprevious,
                                         CMD_topleft, CMD_tnoremap, CMD_tnext,
                                         CMD_tmapclear, CMD_tmap, CMD_tmenu,
                                         CMD_tlast, CMD_tjump, CMD_throw,
                                         CMD_tfirst, CMD_terminal,
                                         CMD_tclfile, CMD_tcldo, CMD_tcl,
                                         CMD_tabs, CMD_tabrewind, CMD_tabNext,
                                         CMD_tabprevious, CMD_tabonly,
                                         CMD_tabnew, CMD_tabnext, CMD_tablast,
                                         CMD_tabmove, CMD_tabfirst,
                                         CMD_tabfind, CMD_tabedit, CMD_tabdo,
                                         CMD_tabclose, CMD_tab, CMD_tags,
                                         CMD_tag, CMD_tNext, CMD_tchdir,
                                         CMD_tcd, CMD_t, CMD_syncbind,
                                         CMD_syntime, CMD_syntax,
                                         CMD_swapname, CMD_sview, CMD_suspend,
                                         CMD_sunmenu, CMD_sunmap, CMD_sunhide,
                                         CMD_stselect, CMD_stjump,
                                         CMD_stopinsert, CMD_startreplace,
                                         CMD_startgreplace, CMD_startinsert,
                                         CMD_stag, CMD_stop, CMD_srewind,
                                         CMD_sprevious, CMD_spellwrong,
                                         CMD_spellundo, CMD_spellrepall,
                                         CMD_spellinfo, CMD_spelldump,
                                         CMD_spellgood, CMD_split, CMD_sort,
                                         CMD_source, CMD_snoremenu,
                                         CMD_snoremap, CMD_snomagic,
                                         CMD_snext, CMD_smenu, CMD_smapclear,
                                         CMD_smap, CMD_smagic, CMD_slast,
                                         CMD_sleep, CMD_silent, CMD_sign,
                                         CMD_simalt, CMD_sfirst, CMD_sfind,
                                         CMD_setlocal, CMD_setglobal,
                                         CMD_setfiletype, CMD_set,
                                         CMD_scscope, CMD_scriptencoding,
                                         CMD_scriptnames, CMD_sbrewind,
                                         CMD_sbprevious, CMD_sbnext,
                                         CMD_sbmodified, CMD_sblast,
                                         CMD_sbfirst, CMD_sball, CMD_sbNext,
                                         CMD_sbuffer, CMD_saveas, CMD_sandbox,
                                         CMD_sall, CMD_sargument, CMD_sNext,
                                         CMD_substitute, CMD_rviminfo,
                                         CMD_rubyfile, CMD_rubydo, CMD_ruby,
                                         CMD_rundo, CMD_runtime, CMD_rshada,
                                         CMD_rightbelow, CMD_right,
                                         CMD_rewind, CMD_return, CMD_retab,
                                         CMD_resize, CMD_registers,
                                         CMD_redrawtabline, CMD_redrawstatus,
                                         CMD_redraw, CMD_redir, CMD_redo,
                                         CMD_recover, CMD_read, CMD_qall,
                                         CMD_quitall, CMD_quit, CMD_pyxfile,
                                         CMD_pythonx, CMD_pyxdo, CMD_pyx,
                                         CMD_py3file, CMD_python3, CMD_py3do,
                                         CMD_py3, CMD_pyfile, CMD_pydo,
                                         CMD_python, CMD_pwd, CMD_put,
                                         CMD_ptselect, CMD_ptrewind,
                                         CMD_ptprevious, CMD_ptnext,
                                         CMD_ptlast, CMD_ptjump, CMD_ptfirst,
                                         CMD_ptNext, CMD_ptag, CMD_psearch,
                                         CMD_profdel, CMD_profile,
                                         CMD_previous, CMD_preserve, CMD_ppop,
                                         CMD_popup, CMD_pop, CMD_pedit,
                                         CMD_perldo, CMD_perl, CMD_pclose,
                                         CMD_packloadall, CMD_packadd,
                                         CMD_print, CMD_ownsyntax,
                                         CMD_ounmenu, CMD_ounmap, CMD_options,
                                         CMD_onoremenu, CMD_onoremap,
                                         CMD_only, CMD_omenu, CMD_omapclear,
                                         CMD_omap, CMD_oldfiles, CMD_nunmenu,
                                         CMD_nunmap, CMD_number, CMD_normal,
                                         CMD_noswapfile, CMD_noremenu,
                                         CMD_noreabbrev, CMD_nohlsearch,
                                         CMD_noautocmd, CMD_noremap,
                                         CMD_nnoremenu, CMD_nnoremap,
                                         CMD_nmenu, CMD_nmapclear, CMD_nmap,
                                         CMD_new, CMD_next, CMD_mzfile,
                                         CMD_mzscheme, CMD_mode, CMD_mkview,
                                         CMD_mkvimrc, CMD_mkspell,
                                         CMD_mksession, CMD_mkexrc,
                                         CMD_messages, CMD_menutranslate,
                                         CMD_menu, CMD_match, CMD_marks,
                                         CMD_mapclear, CMD_map, CMD_make,
                                         CMD_mark, CMD_move, CMD_ls,
                                         CMD_lwindow, CMD_lvimgrepadd,
                                         CMD_lvimgrep, CMD_luafile, CMD_luado,
                                         CMD_lua, CMD_lunmap, CMD_ltag,
                                         CMD_lrewind, CMD_lpfile,
                                         CMD_lprevious, CMD_lopen, CMD_lolder,
                                         CMD_lockvar, CMD_lockmarks,
                                         CMD_loadkeymap, CMD_loadview,
                                         CMD_lnfile, CMD_lnewer, CMD_lnext,
                                         CMD_lnoremap, CMD_lmake,
                                         CMD_lmapclear, CMD_lmap, CMD_llist,
                                         CMD_llast, CMD_ll, CMD_lhistory,
                                         CMD_lhelpgrep, CMD_lgrepadd,
                                         CMD_lgrep, CMD_lgetexpr,
                                         CMD_lgetbuffer, CMD_lgetfile,
                                         CMD_lfirst, CMD_lfdo, CMD_lfile,
                                         CMD_lexpr, CMD_let, CMD_leftabove,
                                         CMD_left, CMD_ldo, CMD_lcscope,
                                         CMD_lclose, CMD_lchdir, CMD_lcd,
                                         CMD_lbottom, CMD_lbelow, CMD_lbuffer,
                                         CMD_later, CMD_laddfile,
                                         CMD_laddbuffer, CMD_laddexpr,
                                         CMD_language, CMD_labove, CMD_last,
                                         CMD_lNfile, CMD_lNext, CMD_list,
                                         CMD_keepalt, CMD_keeppatterns,
                                         CMD_keepjumps, CMD_keepmarks, CMD_k,
                                         CMD_jumps, CMD_join, CMD_iunmenu,
                                         CMD_iunabbrev, CMD_iunmap,
                                         CMD_isplit, CMD_isearch, CMD_intro,
                                         CMD_inoremenu, CMD_inoreabbrev,
                                         CMD_inoremap, CMD_imenu,
                                         CMD_imapclear, CMD_imap, CMD_ilist,
                                         CMD_ijump, CMD_if, CMD_iabclear,
                                         CMD_iabbrev, CMD_insert, CMD_history,
                                         CMD_hide, CMD_highlight,
                                         CMD_hardcopy, CMD_helptags,
                                         CMD_helpgrep, CMD_helpclose,
                                         CMD_help, CMD_gvim, CMD_gui,
                                         CMD_grepadd, CMD_grep, CMD_goto,
                                         CMD_global, CMD_function, CMD_for,
                                         CMD_foldopen, CMD_folddoclosed,
                                         CMD_folddoopen, CMD_foldclose,
                                         CMD_fold, CMD_first, CMD_finish,
                                         CMD_finally, CMD_find, CMD_filter,
                                         CMD_filetype, CMD_files, CMD_file,
                                         CMD_exusage, CMD_exit, CMD_execute,
                                         CMD_ex, CMD_enew, CMD_endwhile,
                                         CMD_endtry, CMD_endfor,
                                         CMD_endfunction, CMD_endif,
                                         CMD_emenu, CMD_elseif, CMD_else,
                                         CMD_echon, CMD_echomsg, CMD_echohl,
                                         CMD_echoerr, CMD_echo, CMD_earlier,
                                         CMD_edit, CMD_dsplit, CMD_dsearch,
                                         CMD_drop, CMD_doautoall,
                                         CMD_doautocmd, CMD_dlist, CMD_djump,
                                         CMD_digraphs, CMD_diffthis,
                                         CMD_diffsplit, CMD_diffput,
                                         CMD_diffpatch, CMD_diffoff,
                                         CMD_diffget, CMD_diffupdate,
                                         CMD_display, CMD_delfunction,
                                         CMD_delcommand, CMD_debuggreedy,
                                         CMD_debug, CMD_delmarks, CMD_delete,
                                         CMD_cwindow, CMD_cunmenu,
                                         CMD_cunabbrev, CMD_cunmap, CMD_cstag,
                                         CMD_cscope, CMD_crewind, CMD_cquit,
                                         CMD_cpfile, CMD_cprevious, CMD_copen,
                                         CMD_const, CMD_confirm, CMD_continue,
                                         CMD_compiler, CMD_comclear,
                                         CMD_command, CMD_colorscheme,
                                         CMD_colder, CMD_copy, CMD_cnoremenu,
                                         CMD_cnoreabbrev, CMD_cnoremap,
                                         CMD_cnfile, CMD_cnewer, CMD_cnext,
                                         CMD_cmenu, CMD_cmapclear, CMD_cmap,
                                         CMD_clearjumps, CMD_close, CMD_clast,
                                         CMD_clist, CMD_chistory,
                                         CMD_checktime, CMD_checkpath,
                                         CMD_checkhealth, CMD_changes,
                                         CMD_chdir, CMD_cgetexpr,
                                         CMD_cgetbuffer, CMD_cgetfile,
                                         CMD_cfirst, CMD_cfdo, CMD_cfile,
                                         CMD_cexpr, CMD_center, CMD_cdo,
                                         CMD_cd, CMD_cclose, CMD_cc,
                                         CMD_cbottom, CMD_cbelow, CMD_cbuffer,
                                         CMD_catch, CMD_call, CMD_caddfile,
                                         CMD_caddexpr, CMD_caddbuffer,
                                         CMD_cabove, CMD_cabclear,
                                         CMD_cabbrev, CMD_cNfile, CMD_cNext,
                                         CMD_change, CMD_bwipeout,
                                         CMD_bunload, CMD_bufdo, CMD_buffers,
                                         CMD_browse, CMD_breaklist,
                                         CMD_breakdel, CMD_breakadd,
                                         CMD_break, CMD_brewind,
                                         CMD_bprevious, CMD_botright,
                                         CMD_bnext, CMD_bmodified, CMD_blast,
                                         CMD_bfirst, CMD_belowright,
                                         CMD_behave, CMD_bdelete, CMD_badd,
                                         CMD_ball, CMD_bNext, CMD_buffer,
                                         CMD_aunmenu, CMD_augroup,
                                         CMD_autocmd, CMD_ascii, CMD_argument,
                                         CMD_arglocal, CMD_argglobal,
                                         CMD_argedit, CMD_argdo,
                                         CMD_argdelete, CMD_argadd, CMD_args,
                                         CMD_anoremenu, CMD_amenu, CMD_all,
                                         CMD_aboveleft, CMD_abclear,
                                         CMD_abbreviate, CMD_append,
                                         cmdidx_T};
pub use self::ex_cmds_defs_h::{exarg, cstack_T, eslist_T, eslist_elem,
                               C2RustUnnamed_28, LineGetter, exarg_T,
                               cmdmod_T};
pub use self::event_defs_h::{argv_callback, message, Event, event_create};
pub use self::multiqueue_h::{MultiQueue, multiqueue};
pub use self::loop_h::{WatcherPtr, __kl1_WatcherPtr, kl1_WatcherPtr,
                       kmp_WatcherPtr_t, kl_WatcherPtr_t, loop_0, Loop,
                       kmp_init_WatcherPtr, kmp_destroy_WatcherPtr,
                       kmp_alloc_WatcherPtr, kmp_free_WatcherPtr,
                       kl_init_WatcherPtr, kl_destroy_WatcherPtr,
                       kl_push_WatcherPtr, kl_shift_at_WatcherPtr};
pub use self::globals_h::{off_T, has_mbyte, vim_lseek, SEA_NONE, SEA_RECOVER,
                          SEA_QUIT, cmdline_row, msg_row, no_wait_return,
                          need_wait_return, need_check_timestamps,
                          did_check_timestamps, curwin, firstbuf, curbuf,
                          allbuf_lock, inhibit_delete_count, cmdmod,
                          msg_silent, swap_exists_action, IObuff, NameBuff,
                          recoverymode, got_int, no_lines_msg};
pub use self::getchar_h::{flush_buffers_T, FLUSH_INPUT, FLUSH_TYPEAHEAD,
                          FLUSH_MINIMAL};
pub use self::eval_h::{VV_SWAPCHOICE, VimVarIndex, VV_LUA, VV_EXITING,
                       VV_ECHOSPACE, VV_TYPE_BOOL, VV_TYPE_FLOAT,
                       VV_TYPE_DICT, VV_TYPE_LIST, VV_TYPE_FUNC,
                       VV_TYPE_STRING, VV_TYPE_NUMBER, VV_TESTING,
                       VV_VIM_DID_ENTER, VV__NULL_DICT, VV__NULL_LIST,
                       VV_NULL, VV_TRUE, VV_FALSE, VV_EVENT, VV_MSGPACK_TYPES,
                       VV_ERRORS, VV_OPTION_TYPE, VV_OPTION_OLD,
                       VV_OPTION_NEW, VV_COMPLETED_ITEM, VV_PROGPATH,
                       VV_WINDOWID, VV_OLDFILES, VV_HLSEARCH,
                       VV_SEARCHFORWARD, VV_OP, VV_MOUSE_COL, VV_MOUSE_LNUM,
                       VV_MOUSE_WINID, VV_MOUSE_WIN, VV_CHAR, VV_SWAPCOMMAND,
                       VV_SWAPNAME, VV_SCROLLSTART, VV_BEVAL_TEXT,
                       VV_BEVAL_COL, VV_BEVAL_LNUM, VV_BEVAL_WINID,
                       VV_BEVAL_WINNR, VV_BEVAL_BUFNR, VV_FCS_CHOICE,
                       VV_FCS_REASON, VV_PROFILING, VV_KEY, VV_VAL,
                       VV_INSERTMODE, VV_CMDBANG, VV_REG, VV_STDERR,
                       VV_THROWPOINT, VV_EXCEPTION, VV_DYING, VV_SEND_SERVER,
                       VV_PROGNAME, VV_FOLDLEVEL, VV_FOLDDASHES, VV_FOLDEND,
                       VV_FOLDSTART, VV_CMDARG, VV_FNAME_DIFF, VV_FNAME_NEW,
                       VV_FNAME_OUT, VV_FNAME_IN, VV_CC_TO, VV_CC_FROM,
                       VV_CTYPE, VV_LC_TIME, VV_LANG, VV_FNAME,
                       VV_TERMRESPONSE, VV_LNUM, VV_VERSION, VV_THIS_SESSION,
                       VV_SHELL_ERROR, VV_STATUSMSG, VV_WARNINGMSG, VV_ERRMSG,
                       VV_PREVCOUNT, VV_COUNT1, VV_COUNT};
pub use self::auevents_enum_generated_h::{event_T, auto_event, NUM_EVENTS,
                                          EVENT_WINNEW, EVENT_WINLEAVE,
                                          EVENT_WINENTER, EVENT_WINCLOSED,
                                          EVENT_VIMSUSPEND, EVENT_VIMRESUME,
                                          EVENT_VIMRESIZED, EVENT_VIMLEAVEPRE,
                                          EVENT_VIMLEAVE, EVENT_VIMENTER,
                                          EVENT_USER, EVENT_UILEAVE,
                                          EVENT_UIENTER, EVENT_TEXTYANKPOST,
                                          EVENT_TEXTCHANGEDP,
                                          EVENT_TEXTCHANGEDI,
                                          EVENT_TEXTCHANGED,
                                          EVENT_TERMRESPONSE, EVENT_TERMOPEN,
                                          EVENT_TERMLEAVE, EVENT_TERMENTER,
                                          EVENT_TERMCLOSE, EVENT_TERMCHANGED,
                                          EVENT_TABNEWENTERED, EVENT_TABNEW,
                                          EVENT_TABLEAVE, EVENT_TABENTER,
                                          EVENT_TABCLOSED, EVENT_SYNTAX,
                                          EVENT_SWAPEXISTS,
                                          EVENT_STDINREADPRE,
                                          EVENT_STDINREADPOST,
                                          EVENT_SPELLFILEMISSING,
                                          EVENT_SOURCEPRE, EVENT_SOURCEPOST,
                                          EVENT_SOURCECMD, EVENT_SIGNAL,
                                          EVENT_SHELLFILTERPOST,
                                          EVENT_SHELLCMDPOST,
                                          EVENT_SESSIONLOADPOST,
                                          EVENT_REMOTEREPLY, EVENT_QUITPRE,
                                          EVENT_QUICKFIXCMDPRE,
                                          EVENT_QUICKFIXCMDPOST,
                                          EVENT_OPTIONSET, EVENT_MENUPOPUP,
                                          EVENT_INSERTLEAVE,
                                          EVENT_INSERTENTER,
                                          EVENT_INSERTCHARPRE,
                                          EVENT_INSERTCHANGE, EVENT_GUIFAILED,
                                          EVENT_GUIENTER, EVENT_FUNCUNDEFINED,
                                          EVENT_FOCUSLOST, EVENT_FOCUSGAINED,
                                          EVENT_FILTERWRITEPRE,
                                          EVENT_FILTERWRITEPOST,
                                          EVENT_FILTERREADPRE,
                                          EVENT_FILTERREADPOST,
                                          EVENT_FILEWRITEPRE,
                                          EVENT_FILEWRITEPOST,
                                          EVENT_FILEWRITECMD, EVENT_FILETYPE,
                                          EVENT_FILEREADPRE,
                                          EVENT_FILEREADPOST,
                                          EVENT_FILEREADCMD,
                                          EVENT_FILECHANGEDSHELLPOST,
                                          EVENT_FILECHANGEDSHELL,
                                          EVENT_FILECHANGEDRO,
                                          EVENT_FILEAPPENDPRE,
                                          EVENT_FILEAPPENDPOST,
                                          EVENT_FILEAPPENDCMD, EVENT_EXITPRE,
                                          EVENT_ENCODINGCHANGED,
                                          EVENT_DIRCHANGED, EVENT_DIFFUPDATED,
                                          EVENT_CURSORMOVEDI,
                                          EVENT_CURSORMOVED,
                                          EVENT_CURSORHOLDI, EVENT_CURSORHOLD,
                                          EVENT_COMPLETEDONEPRE,
                                          EVENT_COMPLETEDONE,
                                          EVENT_COMPLETECHANGED,
                                          EVENT_COLORSCHEMEPRE,
                                          EVENT_COLORSCHEME,
                                          EVENT_CMDLINELEAVE,
                                          EVENT_CMDLINEENTER,
                                          EVENT_CMDLINECHANGED,
                                          EVENT_CMDWINLEAVE,
                                          EVENT_CMDWINENTER,
                                          EVENT_CMDUNDEFINED, EVENT_CHANOPEN,
                                          EVENT_CHANINFO, EVENT_BUFWRITEPRE,
                                          EVENT_BUFWRITEPOST,
                                          EVENT_BUFWRITECMD, EVENT_BUFWIPEOUT,
                                          EVENT_BUFWINLEAVE,
                                          EVENT_BUFWINENTER, EVENT_BUFUNLOAD,
                                          EVENT_BUFREADPRE, EVENT_BUFREADPOST,
                                          EVENT_BUFREADCMD, EVENT_BUFNEWFILE,
                                          EVENT_BUFNEW, EVENT_BUFLEAVE,
                                          EVENT_BUFHIDDEN, EVENT_BUFFILEPRE,
                                          EVENT_BUFFILEPOST, EVENT_BUFENTER,
                                          EVENT_BUFDELETE, EVENT_BUFADD};
pub use self::option_h::{OPT_LOCAL, C2RustUnnamed_34, OPT_NOWIN, OPT_WINONLY,
                         OPT_MODELINE, OPT_GLOBAL, OPT_FREE};
pub use self::path_h::{kEqualFiles, FileComparison, file_comparison,
                       kEqualFileNames, kOneFileMissing, kBothFilesMissing,
                       kDifferentFiles, EW_FILE, EW_KEEPALL, EW_SILENT};
pub use self::rbuffer_h::{rbuffer, rbuffer_callback, RBuffer, rbuffer_size};
pub use self::stream_h::{stream, stream_close_cb, Stream, stream_write_cb,
                         stream_read_cb, C2RustUnnamed_29};
pub use self::process_h::{ProcessType, kProcessTypePty, kProcessTypeUv,
                          process, internal_process_cb, Process,
                          process_exit_cb, process_init, process_is_stopped};
pub use self::ioctl_types_h::winsize;
pub use self::pty_process_unix_h::{pty_process, PtyProcess, pty_process_init};
pub use self::libuv_process_h::{libuv_process, LibuvProcess,
                                libuv_process_init};
pub use self::zone_h::{msgpack_zone_finalizer, msgpack_zone_finalizer_array,
                       msgpack_zone_chunk_list, msgpack_zone,
                       msgpack_zone_malloc, MSGPACK_ZONE_ALIGN,
                       msgpack_zone_malloc_no_align,
                       msgpack_zone_push_finalizer, msgpack_zone_swap,
                       msgpack_zone_chunk, msgpack_zone_free,
                       msgpack_zone_malloc_expand,
                       msgpack_zone_push_finalizer_expand};
pub use self::object_h::{msgpack_object_type, MSGPACK_OBJECT_EXT,
                         MSGPACK_OBJECT_BIN, MSGPACK_OBJECT_MAP,
                         MSGPACK_OBJECT_ARRAY, MSGPACK_OBJECT_STR,
                         MSGPACK_OBJECT_FLOAT, MSGPACK_OBJECT_FLOAT64,
                         MSGPACK_OBJECT_FLOAT32,
                         MSGPACK_OBJECT_NEGATIVE_INTEGER,
                         MSGPACK_OBJECT_POSITIVE_INTEGER,
                         MSGPACK_OBJECT_BOOLEAN, MSGPACK_OBJECT_NIL,
                         msgpack_object, msgpack_object_union,
                         msgpack_object_ext, msgpack_object_bin,
                         msgpack_object_str, msgpack_object_map,
                         msgpack_object_kv, msgpack_object_array};
pub use self::pack_h::{msgpack_packer_write, msgpack_packer,
                       msgpack_packer_init, msgpack_packer_new,
                       msgpack_packer_free};
pub use self::pack_template_h::{C2RustUnnamed_30, C2RustUnnamed_31,
                                msgpack_pack_char, msgpack_pack_signed_char,
                                msgpack_pack_short, msgpack_pack_int,
                                msgpack_pack_long, msgpack_pack_long_long,
                                msgpack_pack_unsigned_char,
                                msgpack_pack_unsigned_short,
                                msgpack_pack_unsigned_int,
                                msgpack_pack_unsigned_long,
                                msgpack_pack_unsigned_long_long,
                                msgpack_pack_uint8, msgpack_pack_uint16,
                                msgpack_pack_uint32, msgpack_pack_uint64,
                                msgpack_pack_int8, msgpack_pack_int16,
                                msgpack_pack_int32, msgpack_pack_int64,
                                msgpack_pack_fix_uint8,
                                msgpack_pack_fix_uint16,
                                msgpack_pack_fix_uint32,
                                msgpack_pack_fix_uint64,
                                msgpack_pack_fix_int8, msgpack_pack_fix_int16,
                                msgpack_pack_fix_int32,
                                msgpack_pack_fix_int64, msgpack_pack_float,
                                msgpack_pack_double, msgpack_pack_nil,
                                msgpack_pack_true, msgpack_pack_false,
                                msgpack_pack_array, msgpack_pack_map,
                                msgpack_pack_str, msgpack_pack_str_body,
                                msgpack_pack_v4raw, msgpack_pack_v4raw_body,
                                msgpack_pack_bin, msgpack_pack_bin_body,
                                msgpack_pack_ext, msgpack_pack_ext_body};
pub use self::unpack_h::{msgpack_unpacked, msgpack_unpacker,
                         msgpack_unpacker_reserve_buffer,
                         msgpack_unpacker_buffer,
                         msgpack_unpacker_buffer_capacity,
                         msgpack_unpacker_buffer_consumed,
                         msgpack_unpacked_init, msgpack_unpacked_destroy,
                         msgpack_unpacked_release_zone,
                         msgpack_unpacker_message_size,
                         msgpack_unpacker_parsed_size,
                         msgpack_unpacker_expand_buffer};
pub use self::sbuffer_h::{msgpack_sbuffer, msgpack_sbuffer_init,
                          msgpack_sbuffer_destroy, msgpack_sbuffer_new,
                          msgpack_sbuffer_free, msgpack_sbuffer_write,
                          MSGPACK_SBUFFER_INIT_SIZE, msgpack_sbuffer_release,
                          msgpack_sbuffer_clear};
pub use self::vrefbuffer_h::{msgpack_vrefbuffer_inner_buffer,
                             msgpack_vrefbuffer, msgpack_vrefbuffer_new,
                             msgpack_vrefbuffer_free,
                             msgpack_vrefbuffer_write, msgpack_vrefbuffer_vec,
                             msgpack_vrefbuffer_veclen,
                             msgpack_vrefbuffer_chunk,
                             msgpack_vrefbuffer_append_copy,
                             msgpack_vrefbuffer_append_ref,
                             msgpack_vrefbuffer_destroy,
                             msgpack_vrefbuffer_init};
pub use self::channel_h::{Channel, CallbackReader, C2RustUnnamed_33,
                          StderrState, StdioPair, ChannelStreamType,
                          kChannelStreamInternal, kChannelStreamStderr,
                          kChannelStreamStdio, kChannelStreamSocket,
                          kChannelStreamProc, callback_reader_set,
                          find_channel, channel_instream, channel_outstream,
                          channels};
pub use self::channel_defs_h::{RpcState, C2RustUnnamed_32, ChannelCallFrame};
pub use self::fileio_h::{FileDescriptor, file_eof, file_fd};
pub use self::assert_h::{__ASSERT_FUNCTION, __assert_fail};
pub use self::errno_h::{errno, __errno_location};
pub use self::errno_base_h::{EINVAL, ENOENT};
use self::string_h::{memcpy, memmove, memset, memchr, strcpy, strcmp, strncmp,
                     strlen};
use self::strings_h::strncasecmp;
pub use self::stdbool_h::{true_0, false_0};
pub use self::fcntl_linux_h::{O_RDONLY, O_RDWR};
use self::stdlib_h::{malloc, calloc, realloc, free, abort};
pub use self::byteswap_h::{__bswap_32, __bswap_64, __bswap_16};
pub use self::uintn_identity_h::{__uint16_identity, __uint32_identity,
                                 __uint64_identity};
pub use self::ascii_h::{NUL, ascii_iswhite, ascii_isdigit, ascii_isxdigit,
                        ascii_isident, ascii_isbdigit, ascii_isspace};
pub use self::limits_h::PATH_MAX;
pub use self::os_defs_h::MAXPATHL;
use self::unistd_h::{lseek, close, readlink};
use self::mbyte_h_generated_h::{mb_adjust_cursor, mb_stricmp, mb_utflen,
                                utfc_ptr2len, utf_head_off};
pub use self::mbyte_h::{mb_strcmp_ic, mb_ptr2len};
use self::include_time_h::ctime;
use self::libintl_h::gettext;
use self::message_h_generated_h::{msg, verb_msg, smsg, emsg, emsgf, iemsg,
                                  iemsgf, set_keep_msg, msg_start,
                                  msg_putchar, msg_outnum, msg_home_replace,
                                  msg_outtrans, msg_outtrans_attr, msg_puts,
                                  msg_puts_attr, msg_reset_scroll, msg_end,
                                  do_dialog};
use self::typval_h_generated_h::{tv_dict_watcher_notify, tv_dict_find,
                                 tv_dict_add_nr, tv_dict_add_str,
                                 tv_dict_add_str_len};
pub use self::nvim_strings_h::strappend;
use self::strings_h_generated_h::{vim_strsave, vim_strnsave, vim_strchr};
use self::memory_h_generated_h::{xmalloc, xfree, xcalloc, xrealloc, xstpcpy,
                                 xstrlcpy, xstrlcat, xstrdup};
pub use self::kvec_h::_memcpy_free;
use self::in_h::{ntohl, ntohs};
pub use self::log_h::WARN_LOG_LEVEL;
use self::log_h_generated_h::logmsg;
pub use self::vim_h::{MIN_SWAP_PAGE_SIZE, MSG_HIST, NOTDONE, FAIL, OK, FALSE,
                      TRUE};
pub use self::message_h::VIM_WARNING;
use self::screen_h_generated_h::{get_trans_bufname, redraw_curbuf_later};
use self::buffer_h_generated_h::{open_buffer, setfname, buf_spname};
pub use self::buffer_h::{buf_inc_changedtick, buf_get_changedtick,
                         buf_set_changedtick};
use self::main_h_generated_h::getout;
pub use self::screen_h::NOT_VALID;
use self::eval_h_generated_h::{set_vim_var_string, get_vim_var_str};
use self::change_h_generated_h::{changed_internal, unchanged};
use self::cursor_h_generated_h::{coladvance, check_cursor};
use self::getchar_h_generated_h::flush_buffers;
use self::fs_h_generated_h::{os_isdir, os_fileinfo, os_remove, os_path_exists,
                             os_mkdir_recurse, os_open, os_set_cloexec,
                             os_fileinfo_size, os_fileinfo_link,
                             os_fileinfo_inode};
use self::users_h_generated_h::{os_get_uname, os_get_user_name};
use self::fileio_h_generated_h::{vim_rename, buf_store_file_info,
                                 vim_deltempdir, vim_tempname, modname,
                                 has_autocmd, apply_autocmds, read_eintr,
                                 readfile};
use self::env_h_generated_h::{home_replace, expand_env, os_get_pid,
                              os_get_hostname};
pub use self::nvim_fileio_h::READ_NEW;
use self::mark_h_generated_h::setpcmark;
pub use self::mark_h::{mark_global_index, mark_local_index, lt, equalpos,
                       ltoreq, clearpos};
use self::memfile_h_generated_h::{mf_open, mf_open_file, mf_close,
                                  mf_close_file, mf_new_page_size,
                                  mf_need_trans, mf_get, mf_put, mf_trans_del,
                                  mf_free_fnames, mf_set_fnames, mf_new,
                                  mf_free, mf_sync, mf_set_dirty};
pub use self::memfile_h::{MFS_STOP, MFS_ALL, MFS_FLUSH, MFS_ZERO};
use self::misc1_h_generated_h::{get_number, line_breakcheck, FreeWild};
use self::option_h_generated_h::{set_option_value, get_fileformat,
                                 set_fileformat, copy_option_part};
use self::path_h_generated_h::{path_full_compare, path_tail, vim_ispathsep,
                               shorten_dir, path_fnamecmp, concat_fnames,
                               vim_FullName, fix_fname, after_pathsep,
                               same_directory, expand_wildcards,
                               path_is_absolute};
use self::spell_h_generated_h::spell_delete_wordlist;
use self::ui_h_generated_h::ui_flush;
use self::version_h::Version;
use self::undo_h_generated_h::bufIsChanged;
use self::process_h_generated_h::os_proc_running;
use self::input_h_generated_h::os_char_avail;
/* contents of a pointer block */
#[c2rust::src_loc = "84:1"]
pub type DATA_BL = data_block;
/* list of pointers to blocks (actually longer)
                                 * followed by empty space until end of page */
/*
 * A data block is a leaf in the tree.
 *
 * The text of the lines is at the end of the block. The text of the first line
 * in the block is put at the end, the text of the second line in front of it,
 * etc. Thus the order of the lines is the opposite of the line number.
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "120:8"]
pub struct data_block {
    pub db_id: uint16_t,
    pub db_free: libc::c_uint,
    pub db_txt_start: libc::c_uint,
    pub db_txt_end: libc::c_uint,
    pub db_line_count: linenr_T,
    pub db_index: [libc::c_uint; 1],
}
/* contents of a data block */
#[c2rust::src_loc = "85:1"]
pub type PTR_EN = pointer_entry;
/* block 0 id 1 */
/*
 * pointer to a block, used in a pointer block
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "95:8"]
pub struct pointer_entry {
    pub pe_bnum: blocknr_T,
    pub pe_line_count: linenr_T,
    pub pe_old_lnum: linenr_T,
    pub pe_page_count: libc::c_int,
}
/* contents of the first block */
#[c2rust::src_loc = "83:1"]
pub type PTR_BL = pointer_block;
/* number of pages in block pe_bnum */
/*
 * A pointer block contains a list of branches in the tree.
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "105:8"]
pub struct pointer_block {
    pub pb_id: uint16_t,
    pub pb_count: uint16_t,
    pub pb_count_max: uint16_t,
    pub pb_pointer: [PTR_EN; 1],
}
// This is an open source non-commercial project. Dear PVS-Studio, please check
// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com
// for debugging
// #define CHECK(c, s) do { if (c) EMSG(s); } while (0)
/*
 * memline.c: Contains the functions for appending, deleting and changing the
 * text lines. The memfile functions are used to store the information in
 * blocks of memory, backed up by a file. The structure of the information is
 * a tree.  The root of the tree is a pointer block. The leaves of the tree
 * are data blocks. In between may be several layers of pointer blocks,
 * forming branches.
 *
 * Three types of blocks are used:
 * - Block nr 0 contains information for recovery
 * - Pointer blocks contain list of pointers to other blocks.
 * - Data blocks contain the actual text.
 *
 * Block nr 0 contains the block0 structure (see below).
 *
 * Block nr 1 is the first pointer block. It is the root of the tree.
 * Other pointer blocks are branches.
 *
 *  If a line is too big to fit in a single page, the block containing that
 *  line is made big enough to hold the line. It may span several pages.
 *  Otherwise all blocks are one page.
 *
 *  A data block that was filled when starting to edit a file and was not
 *  changed since then, can have a negative block number. This means that it
 *  has not yet been assigned a place in the file. When recovering, the lines
 *  in this data block can be read from the original file. When the block is
 *  changed (lines appended/deleted/changed) or when it is flushed it gets a
 *  positive number. Use mf_trans_del() to get the new number, before calling
 *  mf_get().
 */
/* it's in os/unix_defs.h for Unix */
#[c2rust::src_loc = "82:1"]
pub type ZERO_BL = block0;
/*
 * Block zero holds all info about the swap file.
 *
 * NOTE: DEFINITION OF BLOCK 0 SHOULD NOT CHANGE! It would make all existing
 * swap files unusable!
 *
 * If size of block0 changes anyway, adjust MIN_SWAP_PAGE_SIZE in vim.h!!
 *
 * This block is built up of single bytes, to make it portable across
 * different machines. b0_magic_* is used to check the byte order and size of
 * variables, because the rest of the swap file is not portable.
 */
#[derive(Copy, Clone)]
#[repr(C)]
#[c2rust::src_loc = "173:8"]
pub struct block0 {
    pub b0_id: [char_u; 2],
    pub b0_version: [char_u; 10],
    pub b0_page_size: [char_u; 4],
    pub b0_mtime: [char_u; 4],
    pub b0_ino: [char_u; 4],
    pub b0_pid: [char_u; 4],
    pub b0_uname: [char_u; 40],
    pub b0_hname: [char_u; 40],
    pub b0_fname: [char_u; 900],
    pub b0_magic_long: libc::c_long,
    pub b0_magic_int: libc::c_int,
    pub b0_magic_short: libc::c_short,
    pub b0_magic_char: char_u,
}
#[c2rust::src_loc = "236:9"]
pub type upd_block0_T = libc::c_uint;
#[c2rust::src_loc = "238:5"]
pub const UB_SAME_DIR: upd_block0_T = 1;
#[c2rust::src_loc = "237:3"]
pub const UB_FNAME: upd_block0_T = 0;
/* block/line-count pair */
#[c2rust::src_loc = "87:9"]
pub const DATA_ID: libc::c_int =
    (('d' as i32) << 8 as libc::c_int) + 'a' as i32;
/* data block id */
#[c2rust::src_loc = "88:9"]
pub const PTR_ID: libc::c_int =
    (('p' as i32) << 8 as libc::c_int) + 't' as i32;
/* pointer block id */
#[c2rust::src_loc = "89:9"]
pub const BLOCK0_ID0: libc::c_int = 'b' as i32;
/* block 0 id 0 */
#[c2rust::src_loc = "90:9"]
pub const BLOCK0_ID1: libc::c_int = '0' as i32;
#[c2rust::src_loc = "143:9"]
pub const INDEX_SIZE: libc::c_ulong =
    ::std::mem::size_of::<libc::c_uint>() as libc::c_ulong;
/* size of data block header */
#[c2rust::src_loc = "146:9"]
pub const B0_FNAME_SIZE_ORG: libc::c_int = 900 as libc::c_int;
/* what it was in older versions */
#[c2rust::src_loc = "147:9"]
pub const B0_FNAME_SIZE_NOCRYPT: libc::c_int = 898 as libc::c_int;
/* 2 bytes used for other things */
#[c2rust::src_loc = "148:9"]
pub const B0_FNAME_SIZE_CRYPT: libc::c_int = 890 as libc::c_int;
/* 10 bytes used for other things */
#[c2rust::src_loc = "149:9"]
pub const B0_UNAME_SIZE: libc::c_int = 40 as libc::c_int;
#[c2rust::src_loc = "150:9"]
pub const B0_HNAME_SIZE: libc::c_int = 40 as libc::c_int;
/*
 * Restrict the numbers to 32 bits, otherwise most compilers will complain.
 * This won't detect a 64 bit machine that only swaps a byte in the top 32
 * bits, but that is crazy anyway.
 */
#[c2rust::src_loc = "156:9"]
pub const B0_MAGIC_LONG: libc::c_long = 0x30313233 as libc::c_long;
#[c2rust::src_loc = "157:9"]
pub const B0_MAGIC_INT: libc::c_long = 0x20212223 as libc::c_long;
#[c2rust::src_loc = "158:9"]
pub const B0_MAGIC_SHORT: libc::c_long = 0x10111213 as libc::c_long;
#[c2rust::src_loc = "159:9"]
pub const B0_MAGIC_CHAR: libc::c_int = 0x55 as libc::c_int;
/* check for last char */
/*
 * Note: b0_dirty and b0_flags are put at the end of the file name.  For very
 * long file names in older versions of Vim they are invalid.
 * The 'fileencoding' comes before b0_flags, with a NUL in front.  But only
 * when there is room, for very long file names it's omitted.
 */
#[c2rust::src_loc = "195:9"]
pub const B0_DIRTY: libc::c_int = 0x55 as libc::c_int;
/*
 * The b0_flags field is new in Vim 7.0.
 */
/* The lowest two bits contain the fileformat.  Zero means it's not set
 * (compatible with Vim 6.x), otherwise it's EOL_UNIX + 1, EOL_DOS + 1 or
 * EOL_MAC + 1. */
#[c2rust::src_loc = "206:9"]
pub const B0_FF_MASK: libc::c_int = 3 as libc::c_int;
/* Swap file is in directory of edited file.  Used to find the file from
 * different mount points. */
#[c2rust::src_loc = "210:9"]
pub const B0_SAME_DIR: libc::c_int = 4 as libc::c_int;
/* The 'fileencoding' is at the end of b0_fname[], with a NUL in front of it.
 * When empty there is only the NUL. */
#[c2rust::src_loc = "214:9"]
pub const B0_HAS_FENC: libc::c_int = 8 as libc::c_int;
#[c2rust::src_loc = "216:9"]
pub const STACK_INCR: libc::c_int = 5 as libc::c_int;
/* nr of entries added to ml_stack at a time */
/*
 * The line number where the first mark may be is remembered.
 * If it is 0 there are no marks at all.
 * (always used for the current buffer only, no buffer change possible while
 * executing a global command).
 */
#[c2rust::src_loc = "224:17"]
static mut lowest_marked: linenr_T = 0 as libc::c_int as linenr_T;
/*
 * arguments for ml_find_line()
 */
#[c2rust::src_loc = "229:9"]
pub const ML_DELETE: libc::c_int = 0x11 as libc::c_int;
/* delete line */
#[c2rust::src_loc = "230:9"]
pub const ML_INSERT: libc::c_int = 0x12 as libc::c_int;
/* insert line */
#[c2rust::src_loc = "231:9"]
pub const ML_FIND: libc::c_int = 0x13 as libc::c_int;
/* just find the line */
#[c2rust::src_loc = "232:9"]
pub const ML_FLUSH: libc::c_int = 0x2 as libc::c_int;
/*
 * Open a new memline for "buf".
 *
 * Return FAIL for failure, OK otherwise.
 */
#[no_mangle]
#[c2rust::src_loc = "250:1"]
pub unsafe extern "C" fn ml_open(mut buf: *mut buf_T) -> libc::c_int {
    let mut hp = NULL_1 as *mut bhdr_T;
    let mut b0p = 0 as *mut ZERO_BL;
    let mut pp = 0 as *mut PTR_BL;
    let mut dp = 0 as *mut DATA_BL;
    /*
   * init fields in memline struct
   */
    (*buf).b_ml.ml_stack_size = 0 as libc::c_int; /* no stack yet */
    (*buf).b_ml.ml_stack = NULL_1 as *mut infoptr_T; /* no stack yet */
    (*buf).b_ml.ml_stack_top = 0 as libc::c_int; /* nothing in the stack */
    (*buf).b_ml.ml_locked = NULL_1 as *mut bhdr_T; /* no cached block */
    (*buf).b_ml.ml_line_lnum =
        0 as libc::c_int as linenr_T; /* no cached line */
    (*buf).b_ml.ml_chunksize = NULL_1 as *mut chunksize_T;
    if cmdmod.noswapfile { (*buf).b_p_swf = false_0 }
    /*
   * When 'updatecount' is non-zero swap file may be opened later.
   */
    if (*buf).terminal.is_null() && p_uc != 0 && (*buf).b_p_swf != 0 {
        (*buf).b_may_swap = true_0 != 0
    } else { (*buf).b_may_swap = false_0 != 0 }
    // Open the memfile.  No swap file is created yet.
    let mut mfp = mf_open(NULL_1 as *mut char_u, 0 as libc::c_int);
    if !mfp.is_null() {
        (*buf).b_ml.ml_mfp = mfp;
        (*buf).b_ml.ml_flags = ML_EMPTY;
        (*buf).b_ml.ml_line_count = 1 as libc::c_int as linenr_T;
        (*curwin).w_nrwidth_line_count = 0 as libc::c_int as linenr_T;
        /*
   * fill block0 struct and write page 0
   */
        hp = mf_new(mfp, false_0 != 0, 1 as libc::c_int as libc::c_uint);
        if (*hp).bh_hashitem.mhi_key != 0 as libc::c_int as libc::c_long {
            iemsg(gettext(b"E298: Didn\'t get block nr 0?\x00" as *const u8 as
                              *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char);
        } else {
            b0p = (*hp).bh_data as *mut ZERO_BL;
            (*b0p).b0_id[0 as libc::c_int as usize] = BLOCK0_ID0 as char_u;
            (*b0p).b0_id[1 as libc::c_int as usize] = BLOCK0_ID1 as char_u;
            (*b0p).b0_magic_long = B0_MAGIC_LONG;
            (*b0p).b0_magic_int = B0_MAGIC_INT as libc::c_int;
            (*b0p).b0_magic_short = B0_MAGIC_SHORT as libc::c_short;
            (*b0p).b0_magic_char = B0_MAGIC_CHAR as char_u;
            xstrlcpy(xstpcpy((*b0p).b0_version.as_mut_ptr() as
                                 *mut libc::c_char,
                             b"VIM \x00" as *const u8 as *const libc::c_char),
                     Version, 6 as libc::c_int as size_t);
            long_to_char((*mfp).mf_page_size as libc::c_long,
                         (*b0p).b0_page_size.as_mut_ptr());
            if !(*buf).b_spell {
                (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 1 as libc::c_int) as
                                    usize] =
                    if (*buf).b_changed != 0 {
                        B0_DIRTY
                    } else { 0 as libc::c_int } as char_u;
                (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as
                                    usize] =
                    (get_fileformat(buf) + 1 as libc::c_int) as char_u;
                set_b0_fname(b0p, buf);
                os_get_user_name((*b0p).b0_uname.as_mut_ptr() as
                                     *mut libc::c_char,
                                 B0_UNAME_SIZE as size_t);
                (*b0p).b0_uname[(B0_UNAME_SIZE - 1 as libc::c_int) as usize] =
                    NUL as char_u;
                os_get_hostname((*b0p).b0_hname.as_mut_ptr() as
                                    *mut libc::c_char,
                                B0_HNAME_SIZE as size_t);
                (*b0p).b0_hname[(B0_HNAME_SIZE - 1 as libc::c_int) as usize] =
                    NUL as char_u;
                long_to_char(os_get_pid(), (*b0p).b0_pid.as_mut_ptr());
            }
            /*
   * Always sync block number 0 to disk, so we can check the file name in
   * the swap file in findswapname(). Don't do this for a help files or
   * a spell buffer though.
   * Only works when there's a swapfile, otherwise it's done when the file
   * is created.
   */
            mf_put(mfp, hp, true_0 != 0, false_0 != 0);
            if !(*buf).b_help && !(*buf).b_spell {
                mf_sync(mfp, 0 as libc::c_int);
            }
            /*
   * Fill in root pointer block and write page 1.
   */
            hp = ml_new_ptr(mfp); /* line count after insertion */
            if !hp.is_null() {
                if (*hp).bh_hashitem.mhi_key !=
                       1 as libc::c_int as libc::c_long {
                    iemsg(gettext(b"E298: Didn\'t get block nr 1?\x00" as
                                      *const u8 as *const libc::c_char as
                                      *mut libc::c_char) as
                              *const libc::c_char);
                } else {
                    pp = (*hp).bh_data as *mut PTR_BL;
                    (*pp).pb_count = 1 as libc::c_int as uint16_t;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_bnum
                        = 2 as libc::c_int as blocknr_T;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_page_count
                        = 1 as libc::c_int;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_old_lnum
                        = 1 as libc::c_int as linenr_T;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_line_count
                        = 1 as libc::c_int as linenr_T;
                    mf_put(mfp, hp, true_0 != 0, false_0 != 0);
                    /*
   * Allocate first data block and create an empty line 1.
   */
                    hp =
                        ml_new_data(mfp, false_0 != 0,
                                    1 as libc::c_int); /* at end of block */
                    if (*hp).bh_hashitem.mhi_key !=
                           2 as libc::c_int as libc::c_long {
                        iemsg(gettext(b"E298: Didn\'t get block nr 2?\x00" as
                                          *const u8 as *const libc::c_char as
                                          *mut libc::c_char) as
                                  *const libc::c_char); /* empty line */
                    } else {
                        dp = (*hp).bh_data as *mut DATA_BL;
                        (*dp).db_txt_start =
                            (*dp).db_txt_start.wrapping_sub(1);
                        *(*dp).db_index.as_mut_ptr().offset(0 as libc::c_int
                                                                as isize) =
                            (*dp).db_txt_start;
                        (*dp).db_free =
                            ((*dp).db_free as
                                 libc::c_ulong).wrapping_sub((1 as libc::c_int
                                                                  as
                                                                  libc::c_ulong).wrapping_add(INDEX_SIZE))
                                as libc::c_uint as libc::c_uint;
                        (*dp).db_line_count = 1 as libc::c_int as linenr_T;
                        *(dp as
                              *mut char_u).offset((*dp).db_txt_start as isize)
                            = NUL as char_u;
                        return OK
                    }
                }
            }
        }
    }
    if !mfp.is_null() {
        if !hp.is_null() { mf_put(mfp, hp, false_0 != 0, false_0 != 0); }
        mf_close(mfp, true_0 != 0);
        // will also xfree(mfp->mf_fname)
    }
    (*buf).b_ml.ml_mfp = NULL_1 as *mut memfile_T;
    return FAIL;
}
/*
 * ml_setname() is called when the file name of "buf" has been changed.
 * It may rename the swap file.
 */
#[no_mangle]
#[c2rust::src_loc = "382:1"]
pub unsafe extern "C" fn ml_setname(mut buf: *mut buf_T) {
    let mut success = FALSE;
    let mut mfp = 0 as *mut memfile_T;
    let mut fname = 0 as *mut char_u;
    let mut dirp = 0 as *mut char_u;
    mfp = (*buf).b_ml.ml_mfp;
    if (*mfp).mf_fd < 0 as libc::c_int {
        /* there is no swap file yet */
        /*
     * When 'updatecount' is 0 and 'noswapfile' there is no swap file.
     * For help files we will make a swap file now.
     */
        if p_uc != 0 as libc::c_int as libc::c_long && !cmdmod.noswapfile {
            ml_open_file(buf);
            /* create a swap file */
        }
        return
    }
    /*
   * Try all directories in the 'directory' option.
   */
    dirp = p_dir;
    let mut found_existing_dir = false_0 != 0;
    loop  {
        if *dirp as libc::c_int == NUL {
            /* tried all directories, fail */
            break ;
        } else {
            fname =
                findswapname(buf,
                             &mut dirp as *mut *mut char_u as
                                 *mut *mut libc::c_char,
                             (*mfp).mf_fname as *mut libc::c_char,
                             &mut found_existing_dir) as *mut char_u;
            /* alloc's fname */
            if dirp.is_null() { break ; }
            if !fname.is_null() {
                /* if the file name is the same we don't have to do anything */
                if path_fnamecmp(fname as *const libc::c_char,
                                 (*mfp).mf_fname as *const libc::c_char) ==
                       0 as libc::c_int {
                    xfree(fname as *mut libc::c_void);
                    success = TRUE;
                    break ;
                } else {
                    /* need to close the swap file before renaming */
                    if (*mfp).mf_fd >= 0 as libc::c_int {
                        close((*mfp).mf_fd);
                        (*mfp).mf_fd = -(1 as libc::c_int)
                    }
                    /* try to rename the swap file */
                    if vim_rename((*mfp).mf_fname, fname) == 0 as libc::c_int
                       {
                        success = TRUE;
                        mf_free_fnames(mfp);
                        mf_set_fnames(mfp, fname);
                        ml_upd_block0(buf, UB_SAME_DIR);
                        break ;
                    } else { xfree(fname as *mut libc::c_void); }
                }
            }
        }
        /* this fname didn't work, try another */
    }
    if (*mfp).mf_fd == -(1 as libc::c_int) {
        /* need to (re)open the swap file */
        (*mfp).mf_fd =
            os_open((*mfp).mf_fname as *mut libc::c_char, O_RDWR,
                    0 as libc::c_int);
        if (*mfp).mf_fd < 0 as libc::c_int {
            /* could not (re)open the swap file, what can we do???? */
            emsg(gettext(b"E301: Oops, lost the swap file!!!\x00" as *const u8
                             as *const libc::c_char as *mut libc::c_char) as
                     *mut char_u);
            return
        }
        os_set_cloexec((*mfp).mf_fd);
    }
    if success == 0 {
        emsg(gettext(b"E302: Could not rename swap file\x00" as *const u8 as
                         *const libc::c_char as *mut libc::c_char) as
                 *mut char_u);
    };
}
/*
 * Open a file for the memfile for all buffers that are not readonly or have
 * been modified.
 * Used when 'updatecount' changes from zero to non-zero.
 */
#[no_mangle]
#[c2rust::src_loc = "458:1"]
pub unsafe extern "C" fn ml_open_files() {
    let mut buf = firstbuf;
    while !buf.is_null() {
        if (*buf).b_p_ro == 0 || (*buf).b_changed != 0 { ml_open_file(buf); }
        buf = (*buf).b_next
    };
}
/*
 * Open a swap file for an existing memfile, if there is no swap file yet.
 * If we are unable to find a file name, mf_fname will be NULL
 * and the memfile will be in memory only (no recovery possible).
 */
#[no_mangle]
#[c2rust::src_loc = "472:1"]
pub unsafe extern "C" fn ml_open_file(mut buf: *mut buf_T) {
    let mut mfp = 0 as *mut memfile_T;
    let mut fname = 0 as *mut char_u;
    let mut dirp = 0 as *mut char_u;
    mfp = (*buf).b_ml.ml_mfp;
    if mfp.is_null() || (*mfp).mf_fd >= 0 as libc::c_int ||
           (*buf).b_p_swf == 0 || cmdmod.noswapfile as libc::c_int != 0 ||
           !(*buf).terminal.is_null() {
        return
        /* nothing to do */
    }
    /* For a spell buffer use a temp file name. */
    if (*buf).b_spell {
        fname = vim_tempname(); /* consumes fname! */
        if !fname.is_null() { mf_open_file(mfp, fname); }
        (*buf).b_may_swap = false_0 != 0;
        return
    }
    /*
   * Try all directories in 'directory' option.
   */
    dirp = p_dir;
    let mut found_existing_dir = false_0 != 0;
    while !(*dirp as libc::c_int == NUL) {
        // There is a small chance that between choosing the swap file name
    // and creating it, another Vim creates the file.  In that case the
    // creation will fail and we will use another directory.
        fname =
            findswapname(buf,
                         &mut dirp as *mut *mut char_u as
                             *mut *mut libc::c_char,
                         NULL_1 as *mut libc::c_char, &mut found_existing_dir)
                as *mut char_u; /* out of memory */
        if dirp.is_null() { break ; }
        if fname.is_null() { continue ; }
        if !(mf_open_file(mfp, fname) == OK) { continue ; }
        /* consumes fname! */
        ml_upd_block0(buf, UB_SAME_DIR);
        /* Flush block zero, so others can read it */
        if mf_sync(mfp, MFS_ZERO) == OK {
            /* Mark all blocks that should be in the swapfile as dirty.
         * Needed for when the 'swapfile' option was reset, so that
         * the swap file was deleted, and then on again. */
            mf_set_dirty(mfp);
            break ;
        } else {
            /* Writing block 0 failed: close the file and try another dir */
            mf_close_file(buf, false_0 != 0); // call wait_return later
        }
    }
    if *p_dir as libc::c_int != NUL && (*mfp).mf_fname.is_null() {
        need_wait_return = true_0;
        no_wait_return += 1;
        emsgf(gettext(b"E303: Unable to open swap file for \"%s\", recovery impossible\x00"
                          as *const u8 as *const libc::c_char as
                          *mut libc::c_char) as *const libc::c_char,
              if !buf_spname(buf).is_null() {
                  buf_spname(buf)
              } else { (*buf).b_fname });
        no_wait_return -= 1
    }
    /* don't try to open a swap file again */
    (*buf).b_may_swap = false_0 != 0;
}
// / If still need to create a swap file, and starting to edit a not-readonly
// / file, or reading into an existing buffer, create a swap file now.
// /
// / @param newfile reading file into new buffer
#[no_mangle]
#[c2rust::src_loc = "543:1"]
pub unsafe extern "C" fn check_need_swap(mut newfile: bool) {
    let mut old_msg_silent = msg_silent; // might be reset by an E325 message
    msg_silent =
        0 as
            libc::c_int; // If swap dialog prompts for input, user needs to see it!
    if (*curbuf).b_may_swap as libc::c_int != 0 &&
           ((*curbuf).b_p_ro == 0 || !newfile) {
        ml_open_file(curbuf);
    }
    msg_silent = old_msg_silent;
}
/*
 * Close memline for buffer 'buf'.
 * If 'del_file' is TRUE, delete the swap file
 */
#[no_mangle]
#[c2rust::src_loc = "559:1"]
pub unsafe extern "C" fn ml_close(mut buf: *mut buf_T,
                                  mut del_file: libc::c_int) {
    if (*buf).b_ml.ml_mfp.is_null() {
        /* not open */
        return
    } /* close the .swp file */
    mf_close((*buf).b_ml.ml_mfp, del_file != 0);
    if (*buf).b_ml.ml_line_lnum != 0 as libc::c_int as libc::c_long &&
           (*buf).b_ml.ml_flags & ML_LINE_DIRTY != 0 {
        xfree((*buf).b_ml.ml_line_ptr as *mut libc::c_void);
    }
    xfree((*buf).b_ml.ml_stack as *mut libc::c_void);
    let mut ptr_ =
        &mut (*buf).b_ml.ml_chunksize as *mut *mut chunksize_T as
            *mut *mut libc::c_void;
    xfree(*ptr_);
    *ptr_ = NULL_1 as *mut libc::c_void;
    (*buf).b_ml.ml_mfp = NULL_1 as *mut memfile_T;
    /* Reset the "recovered" flag, give the ATTENTION prompt the next time
   * this buffer is loaded. */
    (*buf).b_flags &= !BF_RECOVERED;
}
/*
 * Close all existing memlines and memfiles.
 * Only used when exiting.
 * When 'del_file' is TRUE, delete the memfiles.
 * But don't delete files that were ":preserve"d when we are POSIX compatible.
 */
#[no_mangle]
#[c2rust::src_loc = "581:1"]
pub unsafe extern "C" fn ml_close_all(mut del_file: libc::c_int) {
    let mut buf = firstbuf; /* delete the internal wordlist */
    while !buf.is_null() {
        ml_close(buf,
                 (del_file != 0 &&
                      (*buf).b_flags & BF_PRESERVED == 0 as libc::c_int) as
                     libc::c_int);
        buf = (*buf).b_next
    }
    spell_delete_wordlist();
    vim_deltempdir();
    /* delete created temp directory */
}
/*
 * Close all memfiles for not modified buffers.
 * Only use just before exiting!
 */
#[no_mangle]
#[c2rust::src_loc = "594:1"]
pub unsafe extern "C" fn ml_close_notmod() {
    let mut buf = firstbuf;
    while !buf.is_null() {
        if !bufIsChanged(buf) {
            ml_close(buf, TRUE);
            /* close all not-modified buffers */
        }
        buf = (*buf).b_next
    };
}
/*
 * Update the timestamp in the .swp file.
 * Used when the file has been written.
 */
#[no_mangle]
#[c2rust::src_loc = "607:1"]
pub unsafe extern "C" fn ml_timestamp(mut buf: *mut buf_T) {
    ml_upd_block0(buf, UB_FNAME);
}
// / Checks whether the IDs in b0 are valid.
#[c2rust::src_loc = "613:1"]
unsafe extern "C" fn ml_check_b0_id(mut b0p: *mut ZERO_BL) -> bool {
    return (*b0p).b0_id[0 as libc::c_int as usize] as libc::c_int ==
               BLOCK0_ID0 &&
               (*b0p).b0_id[1 as libc::c_int as usize] as libc::c_int ==
                   BLOCK0_ID1;
}
// / Checks whether all strings in b0 are valid (i.e. nul-terminated).
#[c2rust::src_loc = "620:1"]
unsafe extern "C" fn ml_check_b0_strings(mut b0p: *mut ZERO_BL) -> bool {
    return !memchr((*b0p).b0_version.as_mut_ptr() as *const libc::c_void, NUL,
                   10 as libc::c_int as libc::c_ulong).is_null() &&
               !memchr((*b0p).b0_uname.as_mut_ptr() as *const libc::c_void,
                       NUL, B0_UNAME_SIZE as libc::c_ulong).is_null() &&
               !memchr((*b0p).b0_hname.as_mut_ptr() as *const libc::c_void,
                       NUL, B0_HNAME_SIZE as libc::c_ulong).is_null() &&
               !memchr((*b0p).b0_fname.as_mut_ptr() as *const libc::c_void,
                       NUL, B0_FNAME_SIZE_CRYPT as libc::c_ulong).is_null();
    // -V512
}
/*
 * Update the timestamp or the B0_SAME_DIR flag of the .swp file.
 */
#[c2rust::src_loc = "632:1"]
unsafe extern "C" fn ml_upd_block0(mut buf: *mut buf_T,
                                   mut what: upd_block0_T) {
    let mut mfp = 0 as *mut memfile_T; // what == UB_SAME_DIR
    let mut hp = 0 as *mut bhdr_T;
    let mut b0p = 0 as *mut ZERO_BL;
    mfp = (*buf).b_ml.ml_mfp;
    if mfp.is_null() ||
           {
               hp =
                   mf_get(mfp, 0 as libc::c_int as blocknr_T,
                          1 as libc::c_int as libc::c_uint);
               hp.is_null()
           } {
        return
    }
    b0p = (*hp).bh_data as *mut ZERO_BL;
    if ml_check_b0_id(b0p) as libc::c_int == FAIL {
        iemsg(gettext(b"E304: ml_upd_block0(): Didn\'t get block 0??\x00" as
                          *const u8 as *const libc::c_char as
                          *mut libc::c_char) as *const libc::c_char);
    } else if what as libc::c_uint == UB_FNAME as libc::c_int as libc::c_uint
     {
        set_b0_fname(b0p, buf);
    } else { set_b0_dir_flag(b0p, buf); }
    mf_put(mfp, hp, true_0 != 0, false_0 != 0);
}
/*
 * Write file name and timestamp into block 0 of a swap file.
 * Also set buf->b_mtime.
 * Don't use NameBuff[]!!!
 */
#[c2rust::src_loc = "659:1"]
unsafe extern "C" fn set_b0_fname(mut b0p: *mut ZERO_BL,
                                  mut buf: *mut buf_T) {
    if (*buf).b_ffname.is_null() {
        (*b0p).b0_fname[0 as libc::c_int as usize] = NUL as char_u
    } else {
        let mut uname: [libc::c_char; 40] = [0; 40];
        /*
     * For a file under the home directory of the current user, we try to
     * replace the home directory path with "~user". This helps when
     * editing the same file on different machines over a network.
     * First replace home dir path with "~/" with home_replace().
     * Then insert the user name to get "~user/".
     */
        home_replace(NULL_1 as *const buf_T, (*buf).b_ffname,
                     (*b0p).b0_fname.as_mut_ptr(),
                     B0_FNAME_SIZE_CRYPT as size_t, TRUE != 0);
        if (*b0p).b0_fname[0 as libc::c_int as usize] as libc::c_int ==
               '~' as i32 {
            /* If there is no user name or it is too long, don't use "~/" */
            let mut retval =
                os_get_user_name(uname.as_mut_ptr(), B0_UNAME_SIZE as size_t);
            let mut ulen = strlen(uname.as_mut_ptr());
            let mut flen =
                strlen((*b0p).b0_fname.as_mut_ptr() as *mut libc::c_char);
            if retval == FAIL ||
                   ulen.wrapping_add(flen) >
                       (B0_FNAME_SIZE_CRYPT - 1 as libc::c_int) as
                           libc::c_ulong {
                xstrlcpy((*b0p).b0_fname.as_mut_ptr() as *mut libc::c_char,
                         (*buf).b_ffname as *mut libc::c_char,
                         890 as libc::c_int as size_t);
            } else {
                memmove((*b0p).b0_fname.as_mut_ptr().offset(ulen as
                                                                isize).offset(1
                                                                                  as
                                                                                  libc::c_int
                                                                                  as
                                                                                  isize)
                            as *mut libc::c_void,
                        (*b0p).b0_fname.as_mut_ptr().offset(1 as libc::c_int
                                                                as isize) as
                            *const libc::c_void, flen);
                memmove((*b0p).b0_fname.as_mut_ptr().offset(1 as libc::c_int
                                                                as isize) as
                            *mut libc::c_void,
                        uname.as_mut_ptr() as *const libc::c_void, ulen);
            }
        }
        let mut file_info =
            FileInfo{stat:
                         uv_stat_t{st_dev: 0,
                                   st_mode: 0,
                                   st_nlink: 0,
                                   st_uid: 0,
                                   st_gid: 0,
                                   st_rdev: 0,
                                   st_ino: 0,
                                   st_size: 0,
                                   st_blksize: 0,
                                   st_blocks: 0,
                                   st_flags: 0,
                                   st_gen: 0,
                                   st_atim:
                                       uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                                   st_mtim:
                                       uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                                   st_ctim:
                                       uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                                   st_birthtim:
                                       uv_timespec_t{tv_sec: 0,
                                                     tv_nsec: 0,},},};
        if os_fileinfo((*buf).b_ffname as *mut libc::c_char, &mut file_info) {
            long_to_char(file_info.stat.st_mtim.tv_sec,
                         (*b0p).b0_mtime.as_mut_ptr());
            long_to_char(os_fileinfo_inode(&mut file_info) as libc::c_long,
                         (*b0p).b0_ino.as_mut_ptr());
            buf_store_file_info(buf, &mut file_info);
            (*buf).b_mtime_read = (*buf).b_mtime
        } else {
            long_to_char(0 as libc::c_long, (*b0p).b0_mtime.as_mut_ptr());
            long_to_char(0 as libc::c_long, (*b0p).b0_ino.as_mut_ptr());
            (*buf).b_mtime = 0 as libc::c_int as libc::c_long;
            (*buf).b_mtime_read = 0 as libc::c_int as libc::c_long;
            (*buf).b_orig_size = 0 as libc::c_int as uint64_t;
            (*buf).b_orig_mode = 0 as libc::c_int
        }
    }
    /* Also add the 'fileencoding' if there is room. */
    add_b0_fenc(b0p, curbuf);
}
/*
 * Update the B0_SAME_DIR flag of the swap file.  It's set if the file and the
 * swapfile for "buf" are in the same directory.
 * This is fail safe: if we are not sure the directories are equal the flag is
 * not set.
 */
#[c2rust::src_loc = "713:1"]
unsafe extern "C" fn set_b0_dir_flag(mut b0p: *mut ZERO_BL,
                                     mut buf: *mut buf_T) {
    if same_directory((*(*buf).b_ml.ml_mfp).mf_fname, (*buf).b_ffname) {
        (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize] =
            ((*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize]
                 as libc::c_int | B0_SAME_DIR) as char_u
    } else {
        (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize] =
            ((*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize]
                 as libc::c_int & !B0_SAME_DIR) as char_u
    };
}
/*
 * When there is room, add the 'fileencoding' to block zero.
 */
#[c2rust::src_loc = "724:1"]
unsafe extern "C" fn add_b0_fenc(mut b0p: *mut ZERO_BL, mut buf: *mut buf_T) {
    let mut n: libc::c_int = 0;
    let mut size = B0_FNAME_SIZE_NOCRYPT;
    n = strlen((*buf).b_p_fenc as *mut libc::c_char) as libc::c_int;
    if strlen((*b0p).b0_fname.as_mut_ptr() as *mut libc::c_char) as
           libc::c_int + n + 1 as libc::c_int > size {
        (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize] =
            ((*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize]
                 as libc::c_int & !B0_HAS_FENC) as char_u
    } else {
        memmove(((*b0p).b0_fname.as_mut_ptr() as
                     *mut libc::c_char).offset(size as
                                                   isize).offset(-(n as
                                                                       isize))
                    as *mut libc::c_void,
                (*buf).b_p_fenc as *mut libc::c_char as *const libc::c_void,
                n as size_t);
        *(*b0p).b0_fname.as_mut_ptr().offset(size as
                                                 isize).offset(-(n as
                                                                     isize)).offset(-(1
                                                                                          as
                                                                                          libc::c_int
                                                                                          as
                                                                                          isize))
            = NUL as char_u;
        (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize] =
            ((*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize]
                 as libc::c_int | B0_HAS_FENC) as char_u
    };
}
// / Try to recover curbuf from the .swp file.
// / @param checkext If true, check the extension and detect whether it is a
// / swap file.
#[no_mangle]
#[c2rust::src_loc = "744:1"]
pub unsafe extern "C" fn ml_recover(mut checkext: bool) {
    let mut org_file_info: FileInfo =
        FileInfo{stat:
                     uv_stat_t{st_dev: 0,
                               st_mode: 0,
                               st_nlink: 0,
                               st_uid: 0,
                               st_gid: 0,
                               st_rdev: 0,
                               st_ino: 0,
                               st_size: 0,
                               st_blksize: 0,
                               st_blocks: 0,
                               st_flags: 0,
                               st_gen: 0,
                               st_atim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_mtim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_ctim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_birthtim:
                                   uv_timespec_t{tv_sec: 0, tv_nsec: 0,},},};
    let mut swp_file_info: FileInfo =
        FileInfo{stat:
                     uv_stat_t{st_dev: 0,
                               st_mode: 0,
                               st_nlink: 0,
                               st_uid: 0,
                               st_gid: 0,
                               st_rdev: 0,
                               st_ino: 0,
                               st_size: 0,
                               st_blksize: 0,
                               st_blocks: 0,
                               st_flags: 0,
                               st_gen: 0,
                               st_atim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_mtim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_ctim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_birthtim:
                                   uv_timespec_t{tv_sec: 0, tv_nsec: 0,},},};
    let mut current_block: u64;
    let mut buf = NULL_1 as *mut buf_T;
    let mut mfp = NULL_1 as *mut memfile_T;
    let mut fname = 0 as *mut char_u;
    let mut fname_used = NULL_1 as *mut char_u;
    let mut hp = NULL_1 as *mut bhdr_T;
    let mut b0p = 0 as *mut ZERO_BL;
    let mut b0_ff: libc::c_int = 0;
    let mut b0_fenc = NULL_1 as *mut char_u;
    let mut pp = 0 as *mut PTR_BL;
    let mut dp = 0 as *mut DATA_BL;
    let mut ip = 0 as *mut infoptr_T;
    let mut bnum: blocknr_T = 0;
    let mut page_count: libc::c_int = 0;
    let mut len: libc::c_int = 0;
    let mut directly: libc::c_int = 0;
    let mut lnum: linenr_T = 0;
    let mut p = 0 as *mut char_u;
    let mut i: libc::c_int = 0;
    let mut error: libc::c_long = 0;
    let mut cannot_open: libc::c_int = 0;
    let mut line_count: linenr_T = 0;
    let mut has_error: bool = false;
    let mut idx: libc::c_int = 0;
    let mut top: libc::c_int = 0;
    let mut txt_start: libc::c_int = 0;
    let mut size: off_T = 0;
    let mut called_from_main: libc::c_int = 0;
    let mut serious_error = TRUE;
    let mut mtime: libc::c_long = 0;
    let mut attr: libc::c_int = 0;
    let mut orig_file_status = NOTDONE;
    recoverymode = TRUE;
    called_from_main =
        ((*curbuf).b_ml.ml_mfp == NULL_1 as *mut memfile_T) as libc::c_int;
    attr = highlight_attr[HLF_E as libc::c_int as usize];
    // If the file name ends in ".s[a-w][a-z]" we assume this is the swap file.
  // Otherwise a search is done to find the swap file(s).
    fname = (*curbuf).b_fname;
    if fname.is_null() {
        /* When there is no file name */
        fname = b"\x00" as *const u8 as *const libc::c_char as *mut char_u
    }
    len = strlen(fname as *mut libc::c_char) as libc::c_int;
    if checkext as libc::c_int != 0 && len >= 4 as libc::c_int &&
           strncasecmp(fname.offset(len as
                                        isize).offset(-(4 as libc::c_int as
                                                            isize)) as
                           *mut libc::c_char,
                       b".s\x00" as *const u8 as *const libc::c_char as
                           *mut libc::c_char, 2 as libc::c_int as size_t) ==
               0 as libc::c_int &&
           !vim_strchr(b"abcdefghijklmnopqrstuvw\x00" as *const u8 as
                           *const libc::c_char as *mut char_u,
                       (if (*fname.offset((len - 2 as libc::c_int) as isize)
                                as libc::c_int) < 'A' as i32 ||
                               *fname.offset((len - 2 as libc::c_int) as
                                                 isize) as libc::c_int >
                                   'Z' as i32 {
                            *fname.offset((len - 2 as libc::c_int) as isize)
                                as libc::c_int
                        } else {
                            (*fname.offset((len - 2 as libc::c_int) as isize)
                                 as libc::c_int) + ('a' as i32 - 'A' as i32)
                        })).is_null() &&
           (*fname.offset((len - 1 as libc::c_int) as isize) as libc::c_uint
                >= 'A' as i32 as libc::c_uint &&
                *fname.offset((len - 1 as libc::c_int) as isize) as
                    libc::c_uint <= 'Z' as i32 as libc::c_uint ||
                *fname.offset((len - 1 as libc::c_int) as isize) as
                    libc::c_uint >= 'a' as i32 as libc::c_uint &&
                    *fname.offset((len - 1 as libc::c_int) as isize) as
                        libc::c_uint <= 'z' as i32 as libc::c_uint) {
        directly = TRUE;
        fname_used = vim_strsave(fname);
        current_block = 6450597802325118133;
        /* make a copy for mf_open() */
    } else {
        directly = FALSE;
        /* count the number of matching swap files */
        len =
            recover_names(fname, FALSE, 0 as libc::c_int,
                          NULL_1 as *mut *mut char_u);
        if len == 0 as libc::c_int {
            /* no swap files found */
            emsgf(gettext(b"E305: No swap file found for %s\x00" as *const u8
                              as *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char, fname);
            current_block = 11577632886650045160;
        } else {
            if len == 1 as libc::c_int {
                /* one swap file found, use it */
                i = 1 as libc::c_int;
                current_block = 3123434771885419771;
            } else {
                /* several swap files found, choose */
                /* list the names of the swap files */
                recover_names(fname, TRUE, 0 as libc::c_int,
                              NULL_1 as *mut *mut char_u);
                msg_putchar('\n' as i32);
                msg_puts(gettext(b"Enter number of swap file to use (0 to quit): \x00"
                                     as *const u8 as *const libc::c_char as
                                     *mut libc::c_char) as
                             *const libc::c_char);
                i = get_number(FALSE, NULL_1 as *mut libc::c_int);
                if i < 1 as libc::c_int || i > len {
                    current_block = 11577632886650045160;
                } else { current_block = 3123434771885419771; }
            }
            match current_block {
                11577632886650045160 => { }
                _ => {
                    /* get the swap file name that will be used */
                    recover_names(fname, FALSE, i,
                                  &mut fname_used); // user chose invalid number.
                    current_block = 6450597802325118133;
                }
            }
        }
    }
    match current_block {
        6450597802325118133 => {
            if !fname_used.is_null() {
                /* When called from main() still need to initialize storage structure */
                if called_from_main != 0 && ml_open(curbuf) == FAIL {
                    getout(1 as libc::c_int);
                }
                /*
   * Allocate a buffer structure for the swap file that is used for recovery.
   * Only the memline in it is really used.
   */
                buf =
                    xmalloc(::std::mem::size_of::<buf_T>() as libc::c_ulong)
                        as *mut buf_T;
                /*
   * init fields in memline struct
   */
                (*buf).b_ml.ml_stack_size =
                    0 as libc::c_int; /* no stack yet */
                (*buf).b_ml.ml_stack =
                    NULL_1 as *mut infoptr_T; /* no stack yet */
                (*buf).b_ml.ml_stack_top =
                    0 as libc::c_int; /* nothing in the stack */
                (*buf).b_ml.ml_line_lnum =
                    0 as libc::c_int as linenr_T; /* no cached line */
                (*buf).b_ml.ml_locked =
                    NULL_1 as *mut bhdr_T; /* no locked block */
                (*buf).b_ml.ml_flags = 0 as libc::c_int;
                /*
   * open the memfile from the old swap file
   */
                p =
                    vim_strsave(fname_used); /* save "fname_used" for the message:
                                    mf_open() will consume "fname_used"! */
                mfp = mf_open(fname_used, O_RDONLY);
                fname_used = p;
                if mfp.is_null() || (*mfp).mf_fd < 0 as libc::c_int {
                    emsgf(gettext(b"E306: Cannot open %s\x00" as *const u8 as
                                      *const libc::c_char as
                                      *mut libc::c_char) as
                              *const libc::c_char, fname_used);
                } else {
                    (*buf).b_ml.ml_mfp = mfp;
                    /*
   * The page size set in mf_open() might be different from the page size
   * used in the swap file, we must get it from block 0.  But to read block
   * 0 we need a page size.  Use the minimal size for block 0 here, it will
   * be set to the real value below.
   */
                    (*mfp).mf_page_size = MIN_SWAP_PAGE_SIZE as libc::c_uint;
                    /*
   * try to read block 0
   */
                    hp =
                        mf_get(mfp, 0 as libc::c_int as blocknr_T,
                               1 as libc::c_int as libc::c_uint);
                    if hp.is_null() {
                        msg_start();
                        msg_puts_attr(gettext(b"Unable to read block 0 from \x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char) as
                                          *const libc::c_char,
                                      attr | 0x1000 as libc::c_int);
                        msg_outtrans_attr((*mfp).mf_fname, attr | MSG_HIST);
                        msg_puts_attr(gettext(b"\nMaybe no changes were made or Vim did not update the swap file.\x00"
                                                  as *const u8 as
                                                  *const libc::c_char as
                                                  *mut libc::c_char) as
                                          *const libc::c_char,
                                      attr | 0x1000 as libc::c_int);
                        msg_end();
                    } else {
                        b0p = (*hp).bh_data as *mut ZERO_BL;
                        if strncmp((*b0p).b0_version.as_mut_ptr() as
                                       *mut libc::c_char,
                                   b"VIM 3.0\x00" as *const u8 as
                                       *const libc::c_char as
                                       *mut libc::c_char,
                                   7 as libc::c_int as size_t) ==
                               0 as libc::c_int {
                            msg_start();
                            msg_outtrans_attr((*mfp).mf_fname, MSG_HIST);
                            msg_puts_attr(gettext(b" cannot be used with this version of Vim.\n\x00"
                                                      as *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *const libc::c_char,
                                          0x1000 as libc::c_int);
                            msg_puts_attr(gettext(b"Use Vim version 3.0.\n\x00"
                                                      as *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *const libc::c_char,
                                          0x1000 as libc::c_int);
                            msg_end();
                        } else if ml_check_b0_id(b0p) as libc::c_int == FAIL {
                            emsgf(gettext(b"E307: %s does not look like a Vim swap file\x00"
                                              as *const u8 as
                                              *const libc::c_char as
                                              *mut libc::c_char) as
                                      *const libc::c_char, (*mfp).mf_fname);
                        } else if b0_magic_wrong(b0p) != 0 {
                            msg_start();
                            msg_outtrans_attr((*mfp).mf_fname,
                                              attr | MSG_HIST);
                            msg_puts_attr(gettext(b" cannot be used on this computer.\n\x00"
                                                      as *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *const libc::c_char,
                                          attr | 0x1000 as libc::c_int);
                            msg_puts_attr(gettext(b"The file was created on \x00"
                                                      as *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *const libc::c_char,
                                          attr | 0x1000 as libc::c_int);
                            /* avoid going past the end of a corrupted hostname */
                            (*b0p).b0_fname[0 as libc::c_int as usize] =
                                NUL as char_u;
                            msg_puts_attr((*b0p).b0_hname.as_mut_ptr() as
                                              *const libc::c_char,
                                          attr | 0x1000 as libc::c_int);
                            msg_puts_attr(gettext(b",\nor the file has been damaged.\x00"
                                                      as *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *const libc::c_char,
                                          attr | 0x1000 as libc::c_int);
                            msg_end();
                        } else {
                            /*
   * If we guessed the wrong page size, we have to recalculate the
   * highest block number in the file.
   */
                            if (*mfp).mf_page_size !=
                                   char_to_long((*b0p).b0_page_size.as_mut_ptr())
                                       as libc::c_uint {
                                let mut previous_page_size =
                                    (*mfp).mf_page_size;
                                mf_new_page_size(mfp,
                                                 char_to_long((*b0p).b0_page_size.as_mut_ptr())
                                                     as libc::c_uint);
                                if (*mfp).mf_page_size < previous_page_size {
                                    msg_start();
                                    msg_outtrans_attr((*mfp).mf_fname,
                                                      attr | MSG_HIST);
                                    msg_puts_attr(gettext(b" has been damaged (page size is smaller than minimum value).\n\x00"
                                                              as *const u8 as
                                                              *const libc::c_char
                                                              as
                                                              *mut libc::c_char)
                                                      as *const libc::c_char,
                                                  attr |
                                                      0x1000 as libc::c_int);
                                    msg_end();
                                    current_block = 11577632886650045160;
                                } else {
                                    size =
                                        lseek((*mfp).mf_fd, 0 as libc::c_long,
                                              SEEK_END);
                                    if size <=
                                           0 as libc::c_int as libc::c_long {
                                        (*mfp).mf_blocknr_max =
                                            0 as libc::c_int as blocknr_T
                                        // no file or empty file
                                    } else {
                                        (*mfp).mf_blocknr_max =
                                            size /
                                                (*mfp).mf_page_size as
                                                    libc::c_long
                                    }
                                    (*mfp).mf_infile_count =
                                        (*mfp).mf_blocknr_max;
                                    /* need to reallocate the memory used to store the data */
                                    p =
                                        xmalloc((*mfp).mf_page_size as size_t)
                                            as *mut char_u;
                                    memmove(p as *mut libc::c_void,
                                            (*hp).bh_data,
                                            previous_page_size as
                                                libc::c_ulong);
                                    xfree((*hp).bh_data);
                                    (*hp).bh_data = p as *mut libc::c_void;
                                    b0p = (*hp).bh_data as *mut ZERO_BL;
                                    current_block = 14141370668937312244;
                                }
                            } else { current_block = 14141370668937312244; }
                            match current_block {
                                11577632886650045160 => { }
                                _ =>
                                /*
   * If .swp file name given directly, use name from swap file for buffer.
   */
                                {
                                    if directly != 0 {
                                        expand_env((*b0p).b0_fname.as_mut_ptr(),
                                                   NameBuff.as_mut_ptr(),
                                                   MAXPATHL);
                                        if setfname(curbuf,
                                                    NameBuff.as_mut_ptr(),
                                                    NULL_1 as *mut char_u,
                                                    true_0 != 0) == FAIL {
                                            current_block =
                                                11577632886650045160;
                                        } else {
                                            current_block =
                                                1658462350791934405;
                                        }
                                    } else {
                                        current_block = 1658462350791934405;
                                    }
                                    match current_block {
                                        11577632886650045160 => { }
                                        _ => {
                                            home_replace(NULL_1 as
                                                             *const buf_T,
                                                         (*mfp).mf_fname,
                                                         NameBuff.as_mut_ptr(),
                                                         MAXPATHL as size_t,
                                                         TRUE != 0);
                                            smsg(gettext(b"Using swap file \"%s\"\x00"
                                                             as *const u8 as
                                                             *const libc::c_char
                                                             as
                                                             *mut libc::c_char),
                                                 NameBuff.as_mut_ptr());
                                            if !buf_spname(curbuf).is_null() {
                                                xstrlcpy(NameBuff.as_mut_ptr()
                                                             as
                                                             *mut libc::c_char,
                                                         buf_spname(curbuf) as
                                                             *mut libc::c_char,
                                                         4096 as libc::c_int
                                                             as size_t);
                                            } else {
                                                home_replace(NULL_1 as
                                                                 *const buf_T,
                                                             (*curbuf).b_ffname,
                                                             NameBuff.as_mut_ptr(),
                                                             MAXPATHL as
                                                                 size_t,
                                                             TRUE != 0);
                                            }
                                            smsg(gettext(b"Original file \"%s\"\x00"
                                                             as *const u8 as
                                                             *const libc::c_char
                                                             as
                                                             *mut libc::c_char),
                                                 NameBuff.as_mut_ptr());
                                            msg_putchar('\n' as i32);
                                            /*
   * check date of swap file and original file
   */
                                            org_file_info =
                                                FileInfo{stat:
                                                             uv_stat_t{st_dev:
                                                                           0,
                                                                       st_mode:
                                                                           0,
                                                                       st_nlink:
                                                                           0,
                                                                       st_uid:
                                                                           0,
                                                                       st_gid:
                                                                           0,
                                                                       st_rdev:
                                                                           0,
                                                                       st_ino:
                                                                           0,
                                                                       st_size:
                                                                           0,
                                                                       st_blksize:
                                                                           0,
                                                                       st_blocks:
                                                                           0,
                                                                       st_flags:
                                                                           0,
                                                                       st_gen:
                                                                           0,
                                                                       st_atim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_mtim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_ctim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_birthtim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},},};
                                            swp_file_info =
                                                FileInfo{stat:
                                                             uv_stat_t{st_dev:
                                                                           0,
                                                                       st_mode:
                                                                           0,
                                                                       st_nlink:
                                                                           0,
                                                                       st_uid:
                                                                           0,
                                                                       st_gid:
                                                                           0,
                                                                       st_rdev:
                                                                           0,
                                                                       st_ino:
                                                                           0,
                                                                       st_size:
                                                                           0,
                                                                       st_blksize:
                                                                           0,
                                                                       st_blocks:
                                                                           0,
                                                                       st_flags:
                                                                           0,
                                                                       st_gen:
                                                                           0,
                                                                       st_atim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_mtim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_ctim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},
                                                                       st_birthtim:
                                                                           uv_timespec_t{tv_sec:
                                                                                             0,
                                                                                         tv_nsec:
                                                                                             0,},},};
                                            mtime =
                                                char_to_long((*b0p).b0_mtime.as_mut_ptr());
                                            if !(*curbuf).b_ffname.is_null()
                                                   &&
                                                   os_fileinfo((*curbuf).b_ffname
                                                                   as
                                                                   *mut libc::c_char,
                                                               &mut org_file_info)
                                                       as libc::c_int != 0 &&
                                                   (os_fileinfo((*mfp).mf_fname
                                                                    as
                                                                    *mut libc::c_char,
                                                                &mut swp_file_info)
                                                        as libc::c_int != 0 &&
                                                        org_file_info.stat.st_mtim.tv_sec
                                                            >
                                                            swp_file_info.stat.st_mtim.tv_sec
                                                        ||
                                                        org_file_info.stat.st_mtim.tv_sec
                                                            != mtime) {
                                                emsg(gettext(b"E308: Warning: Original file may have been changed\x00"
                                                                 as *const u8
                                                                 as
                                                                 *const libc::c_char
                                                                 as
                                                                 *mut libc::c_char)
                                                         as *mut char_u);
                                            }
                                            ui_flush();
                                            /* Get the 'fileformat' and 'fileencoding' from block zero. */
                                            b0_ff =
                                                (*b0p).b0_fname[(B0_FNAME_SIZE_ORG
                                                                     -
                                                                     2 as
                                                                         libc::c_int)
                                                                    as usize]
                                                    as libc::c_int &
                                                    B0_FF_MASK; /* release block 0 */
                                            if (*b0p).b0_fname[(B0_FNAME_SIZE_ORG
                                                                    -
                                                                    2 as
                                                                        libc::c_int)
                                                                   as usize]
                                                   as libc::c_int &
                                                   B0_HAS_FENC != 0 {
                                                let mut fnsize =
                                                    B0_FNAME_SIZE_NOCRYPT;
                                                p =
                                                    (*b0p).b0_fname.as_mut_ptr().offset(fnsize
                                                                                            as
                                                                                            isize);
                                                while p >
                                                          (*b0p).b0_fname.as_mut_ptr()
                                                          &&
                                                          *p.offset(-(1 as
                                                                          libc::c_int)
                                                                        as
                                                                        isize)
                                                              as libc::c_int
                                                              != NUL {
                                                    p = p.offset(-1)
                                                }
                                                b0_fenc =
                                                    vim_strnsave(p,
                                                                 (*b0p).b0_fname.as_mut_ptr().offset(fnsize
                                                                                                         as
                                                                                                         isize).wrapping_offset_from(p)
                                                                     as
                                                                     libc::c_long
                                                                     as
                                                                     libc::c_int
                                                                     as
                                                                     size_t)
                                            }
                                            mf_put(mfp, hp, false_0 != 0,
                                                   false_0 != 0);
                                            hp = NULL_1 as *mut bhdr_T;
                                            /*
   * Now that we are sure that the file is going to be recovered, clear the
   * contents of the current buffer.
   */
                                            while (*curbuf).b_ml.ml_flags &
                                                      ML_EMPTY == 0 {
                                                ml_delete(1 as libc::c_int as
                                                              linenr_T,
                                                          false_0 != 0);
                                            }
                                            /*
   * Try reading the original file to obtain the values of 'fileformat',
   * 'fileencoding', etc.  Ignore errors.  The text itself is not used.
   */
                                            if !(*curbuf).b_ffname.is_null() {
                                                orig_file_status =
                                                    readfile((*curbuf).b_ffname,
                                                             NULL_1 as
                                                                 *mut char_u,
                                                             0 as libc::c_int
                                                                 as linenr_T,
                                                             0 as libc::c_int
                                                                 as linenr_T,
                                                             MAXLNUM as
                                                                 libc::c_int
                                                                 as linenr_T,
                                                             NULL_1 as
                                                                 *mut exarg_T,
                                                             READ_NEW)
                                            }
                                            /* Use the 'fileformat' and 'fileencoding' as stored in the swap file. */
                                            if b0_ff != 0 as libc::c_int {
                                                set_fileformat(b0_ff -
                                                                   1 as
                                                                       libc::c_int,
                                                               OPT_LOCAL as
                                                                   libc::c_int); /* start with block 1 */
                                            } /* which is 1 page */
                                            if !b0_fenc.is_null() {
                                                set_option_value(b"fenc\x00"
                                                                     as
                                                                     *const u8
                                                                     as
                                                                     *const libc::c_char,
                                                                 0 as
                                                                     libc::c_long,
                                                                 b0_fenc as
                                                                     *mut libc::c_char,
                                                                 OPT_LOCAL as
                                                                     libc::c_int); /* append after line 0 in curbuf */
                                                xfree(b0_fenc as
                                                          *mut libc::c_void); /* start with first index in block 1 */
                                            } /* no stack yet */
                                            unchanged(curbuf, true_0,
                                                      true_0 !=
                                                          0); /* release previous block */
                                            bnum =
                                                1 as libc::c_int as blocknr_T;
                                            page_count = 1 as libc::c_int;
                                            lnum =
                                                0 as libc::c_int as linenr_T;
                                            line_count =
                                                0 as libc::c_int as linenr_T;
                                            idx = 0 as libc::c_int;
                                            error =
                                                0 as libc::c_int as
                                                    libc::c_long;
                                            (*buf).b_ml.ml_stack_top =
                                                0 as libc::c_int;
                                            (*buf).b_ml.ml_stack =
                                                NULL_1 as *mut infoptr_T;
                                            (*buf).b_ml.ml_stack_size =
                                                0 as libc::c_int;
                                            if (*curbuf).b_ffname.is_null() {
                                                cannot_open = TRUE
                                            } else { cannot_open = FALSE }
                                            serious_error = FALSE;
                                            loop  {
                                                if !(got_int == 0) {
                                                    current_block =
                                                        4439560405756540239;
                                                    break ;
                                                }
                                                if !hp.is_null() {
                                                    mf_put(mfp, hp,
                                                           false_0 != 0,
                                                           false_0 != 0);
                                                }
                                                /*
     * get block
     */
                                                hp =
                                                    mf_get(mfp, bnum,
                                                           page_count as
                                                               libc::c_uint); // there is a block
                                                if hp.is_null() {
                                                    if bnum ==
                                                           1 as libc::c_int as
                                                               libc::c_long {
                                                        emsgf(gettext(b"E309: Unable to read block 1 from %s\x00"
                                                                          as
                                                                          *const u8
                                                                          as
                                                                          *const libc::c_char
                                                                          as
                                                                          *mut libc::c_char)
                                                                  as
                                                                  *const libc::c_char,
                                                              (*mfp).mf_fname); /* not a pointer block */
                                                        current_block =
                                                            11577632886650045160;
                                                        break ;
                                                    } else {
                                                        error += 1;
                                                        let fresh3 = lnum;
                                                        lnum = lnum + 1;
                                                        ml_append(fresh3,
                                                                  gettext(b"???MANY LINES MISSING\x00"
                                                                              as
                                                                              *const u8
                                                                              as
                                                                              *const libc::c_char
                                                                              as
                                                                              *mut libc::c_char)
                                                                      as
                                                                      *mut char_u,
                                                                  0 as
                                                                      libc::c_int,
                                                                  true_0 !=
                                                                      0);
                                                    }
                                                    current_block =
                                                        13198394165140872611;
                                                } else {
                                                    pp =
                                                        (*hp).bh_data as
                                                            *mut PTR_BL;
                                                    if (*pp).pb_id as
                                                           libc::c_int ==
                                                           PTR_ID {
                                                        /* it is a pointer block */
                                                        /* check line count when using pointer block first time */
                                                        if idx ==
                                                               0 as
                                                                   libc::c_int
                                                               &&
                                                               line_count !=
                                                                   0 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                           {
                                                            i =
                                                                0 as
                                                                    libc::c_int;
                                                            while i <
                                                                      (*pp).pb_count
                                                                          as
                                                                          libc::c_int
                                                                  {
                                                                line_count -=
                                                                    (*(*pp).pb_pointer.as_mut_ptr().offset(i
                                                                                                               as
                                                                                                               isize)).pe_line_count;
                                                                i += 1
                                                            }
                                                            if line_count !=
                                                                   0 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                               {
                                                                error += 1;
                                                                let fresh4 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh4,
                                                                          gettext(b"???LINE COUNT WRONG\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char
                                                                                      as
                                                                                      *mut libc::c_char)
                                                                              as
                                                                              *mut char_u,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                            }
                                                        }
                                                        if (*pp).pb_count as
                                                               libc::c_int ==
                                                               0 as
                                                                   libc::c_int
                                                           {
                                                            let fresh5 = lnum;
                                                            lnum = lnum + 1;
                                                            ml_append(fresh5,
                                                                      gettext(b"???EMPTY BLOCK\x00"
                                                                                  as
                                                                                  *const u8
                                                                                  as
                                                                                  *const libc::c_char
                                                                                  as
                                                                                  *mut libc::c_char)
                                                                          as
                                                                          *mut char_u,
                                                                      0 as
                                                                          libc::c_int,
                                                                      true_0
                                                                          !=
                                                                          0);
                                                            error += 1;
                                                            current_block =
                                                                13198394165140872611;
                                                        } else if idx <
                                                                      (*pp).pb_count
                                                                          as
                                                                          libc::c_int
                                                         {
                                                            // go a block deeper
                                                            if (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                          as
                                                                                                          isize)).pe_bnum
                                                                   <
                                                                   0 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                               {
                                                                /*
             * Data block with negative block number.
             * Try to read lines from the original file.
             * This is slow, but it works.
             */
                                                                if cannot_open
                                                                       == 0 {
                                                                    line_count
                                                                        =
                                                                        (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                                   as
                                                                                                                   isize)).pe_line_count; /* get same block again for next index */
                                                                    if readfile((*curbuf).b_ffname,
                                                                                NULL_1
                                                                                    as
                                                                                    *mut char_u,
                                                                                lnum,
                                                                                (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                                           as
                                                                                                                           isize)).pe_old_lnum
                                                                                    -
                                                                                    1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_long,
                                                                                line_count,
                                                                                NULL_1
                                                                                    as
                                                                                    *mut exarg_T,
                                                                                0
                                                                                    as
                                                                                    libc::c_int)
                                                                           !=
                                                                           OK
                                                                       {
                                                                        cannot_open
                                                                            =
                                                                            true_0
                                                                    } else {
                                                                        lnum
                                                                            +=
                                                                            line_count
                                                                    }
                                                                }
                                                                if cannot_open
                                                                       != 0 {
                                                                    error +=
                                                                        1;
                                                                    let fresh6 =
                                                                        lnum;
                                                                    lnum =
                                                                        lnum +
                                                                            1;
                                                                    ml_append(fresh6,
                                                                              gettext(b"???LINES MISSING\x00"
                                                                                          as
                                                                                          *const u8
                                                                                          as
                                                                                          *const libc::c_char
                                                                                          as
                                                                                          *mut libc::c_char)
                                                                                  as
                                                                                  *mut char_u,
                                                                              0
                                                                                  as
                                                                                  libc::c_int,
                                                                              true_0
                                                                                  !=
                                                                                  0);
                                                                }
                                                                idx += 1
                                                            } else {
                                                                /*
           * going one block deeper in the tree
           */
                                                                top =
                                                                    ml_add_stack(buf); // new entry in stack
                                                                ip =
                                                                    &mut *(*buf).b_ml.ml_stack.offset(top
                                                                                                          as
                                                                                                          isize)
                                                                        as
                                                                        *mut infoptr_T;
                                                                (*ip).ip_bnum
                                                                    = bnum;
                                                                (*ip).ip_index
                                                                    = idx;
                                                                bnum =
                                                                    (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                               as
                                                                                                               isize)).pe_bnum;
                                                                line_count =
                                                                    (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                               as
                                                                                                               isize)).pe_line_count;
                                                                page_count =
                                                                    (*(*pp).pb_pointer.as_mut_ptr().offset(idx
                                                                                                               as
                                                                                                               isize)).pe_page_count;
                                                                idx =
                                                                    0 as
                                                                        libc::c_int
                                                            }
                                                            current_block =
                                                                7034501744547627146;
                                                        } else {
                                                            current_block =
                                                                13198394165140872611;
                                                        }
                                                    } else {
                                                        dp =
                                                            (*hp).bh_data as
                                                                *mut DATA_BL;
                                                        if (*dp).db_id as
                                                               libc::c_int !=
                                                               DATA_ID {
                                                            /* block id wrong */
                                                            if bnum ==
                                                                   1 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                               {
                                                                emsgf(gettext(b"E310: Block 1 ID wrong (%s not a .swp file?)\x00"
                                                                                  as
                                                                                  *const u8
                                                                                  as
                                                                                  *const libc::c_char
                                                                                  as
                                                                                  *mut libc::c_char)
                                                                          as
                                                                          *const libc::c_char,
                                                                      (*mfp).mf_fname);
                                                                current_block
                                                                    =
                                                                    11577632886650045160;
                                                                break ;
                                                            } else {
                                                                error += 1;
                                                                let fresh7 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh7,
                                                                          gettext(b"???BLOCK MISSING\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char
                                                                                      as
                                                                                      *mut libc::c_char)
                                                                              as
                                                                              *mut char_u,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                            }
                                                        } else {
                                                            // it is a data block
          // Append all the lines in this block
                                                            has_error =
                                                                false_0 != 0;
                                                            // check length of block
          // if wrong, use length in pointer block
                                                            if (page_count as
                                                                    libc::c_uint).wrapping_mul((*mfp).mf_page_size)
                                                                   !=
                                                                   (*dp).db_txt_end
                                                               {
                                                                let fresh8 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh8,
                                                                          gettext(b"??? from here until ???END lines may be messed up\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char
                                                                                      as
                                                                                      *mut libc::c_char)
                                                                              as
                                                                              *mut char_u,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                                error += 1;
                                                                has_error =
                                                                    true_0 !=
                                                                        0;
                                                                (*dp).db_txt_end
                                                                    =
                                                                    (page_count
                                                                         as
                                                                         libc::c_uint).wrapping_mul((*mfp).mf_page_size)
                                                            }
                                                            /* make sure there is a NUL at the end of the block */
                                                            *(dp as
                                                                  *mut char_u).offset((*dp).db_txt_end
                                                                                          as
                                                                                          isize).offset(-(1
                                                                                                              as
                                                                                                              libc::c_int
                                                                                                              as
                                                                                                              isize))
                                                                =
                                                                NUL as char_u;
                                                            /*
           * check number of lines in block
           * if wrong, use count in data block
           */
                                                            if line_count !=
                                                                   (*dp).db_line_count
                                                               {
                                                                let fresh9 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh9,
                                                                          gettext(b"??? from here until ???END lines may have been inserted/deleted\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char
                                                                                      as
                                                                                      *mut libc::c_char)
                                                                              as
                                                                              *mut char_u,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                                error += 1;
                                                                has_error =
                                                                    true_0 !=
                                                                        0
                                                            }
                                                            i =
                                                                0 as
                                                                    libc::c_int;
                                                            while (i as
                                                                       libc::c_long)
                                                                      <
                                                                      (*dp).db_line_count
                                                                  {
                                                                txt_start =
                                                                    (*(*dp).db_index.as_mut_ptr().offset(i
                                                                                                             as
                                                                                                             isize)
                                                                         &
                                                                         !((1
                                                                                as
                                                                                libc::c_int
                                                                                as
                                                                                libc::c_uint)
                                                                               <<
                                                                               (::std::mem::size_of::<libc::c_uint>()
                                                                                    as
                                                                                    libc::c_ulong).wrapping_mul(8
                                                                                                                    as
                                                                                                                    libc::c_int
                                                                                                                    as
                                                                                                                    libc::c_ulong).wrapping_sub(1
                                                                                                                                                    as
                                                                                                                                                    libc::c_int
                                                                                                                                                    as
                                                                                                                                                    libc::c_ulong)))
                                                                        as
                                                                        libc::c_int;
                                                                if txt_start
                                                                       <=
                                                                       (::std::mem::size_of::<DATA_BL>()
                                                                            as
                                                                            libc::c_ulong).wrapping_sub(INDEX_SIZE)
                                                                           as
                                                                           libc::c_int
                                                                       ||
                                                                       txt_start
                                                                           >=
                                                                           (*dp).db_txt_end
                                                                               as
                                                                               libc::c_int
                                                                   {
                                                                    p =
                                                                        b"???\x00"
                                                                            as
                                                                            *const u8
                                                                            as
                                                                            *const libc::c_char
                                                                            as
                                                                            *mut char_u;
                                                                    error += 1
                                                                } else {
                                                                    p =
                                                                        (dp as
                                                                             *mut char_u).offset(txt_start
                                                                                                     as
                                                                                                     isize)
                                                                }
                                                                let fresh10 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh10,
                                                                          p,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                                i += 1
                                                            }
                                                            if has_error {
                                                                let fresh11 =
                                                                    lnum;
                                                                lnum =
                                                                    lnum + 1;
                                                                ml_append(fresh11,
                                                                          gettext(b"???END\x00"
                                                                                      as
                                                                                      *const u8
                                                                                      as
                                                                                      *const libc::c_char
                                                                                      as
                                                                                      *mut libc::c_char)
                                                                              as
                                                                              *mut char_u,
                                                                          0 as
                                                                              libc::c_int,
                                                                          true_0
                                                                              !=
                                                                              0);
                                                            }
                                                        }
                                                        current_block =
                                                            13198394165140872611;
                                                    }
                                                }
                                                match current_block {
                                                    13198394165140872611 => {
                                                        if (*buf).b_ml.ml_stack_top
                                                               ==
                                                               0 as
                                                                   libc::c_int
                                                           {
                                                            current_block =
                                                                4439560405756540239;
                                                            break ;
                                                        }
                                                        /*
     * go one block up in the tree
     */
                                                        (*buf).b_ml.ml_stack_top
                                                            -=
                                                            1; /* go to next index */
                                                        ip =
                                                            &mut *(*buf).b_ml.ml_stack.offset((*buf).b_ml.ml_stack_top
                                                                                                  as
                                                                                                  isize)
                                                                as
                                                                *mut infoptr_T;
                                                        bnum = (*ip).ip_bnum;
                                                        idx =
                                                            (*ip).ip_index +
                                                                1 as
                                                                    libc::c_int;
                                                        page_count =
                                                            1 as libc::c_int
                                                    }
                                                    _ => { }
                                                }
                                                line_breakcheck();
                                            }
                                            match current_block {
                                                11577632886650045160 => { }
                                                _ =>
                                                /* finished */
                                                /*
   * Compare the buffer contents with the original file.  When they differ
   * set the 'modified' flag.
   * Lines 1 - lnum are the new contents.
   * Lines lnum + 1 to ml_line_count are the original contents.
   * Line ml_line_count + 1 in the dummy empty line.
   */
                                                {
                                                    if orig_file_status != OK
                                                           ||
                                                           (*curbuf).b_ml.ml_line_count
                                                               !=
                                                               lnum *
                                                                   2 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                                   +
                                                                   1 as
                                                                       libc::c_int
                                                                       as
                                                                       libc::c_long
                                                       {
                                                        /* Recovering an empty file results in two lines and the first line is
     * empty.  Don't set the modified flag then. */
                                                        if !((*curbuf).b_ml.ml_line_count
                                                                 ==
                                                                 2 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_long
                                                                 &&
                                                                 *ml_get(1 as
                                                                             libc::c_int
                                                                             as
                                                                             linenr_T)
                                                                     as
                                                                     libc::c_int
                                                                     == NUL) {
                                                            changed_internal();
                                                            buf_inc_changedtick(curbuf);
                                                        }
                                                    } else {
                                                        idx =
                                                            1 as libc::c_int;
                                                        while idx as
                                                                  libc::c_long
                                                                  <= lnum {
                                                            /* Need to copy one line, fetching the other one may flush it. */
                                                            p =
                                                                vim_strsave(ml_get(idx
                                                                                       as
                                                                                       linenr_T));
                                                            i =
                                                                strcmp(p as
                                                                           *mut libc::c_char,
                                                                       ml_get(idx
                                                                                  as
                                                                                  libc::c_long
                                                                                  +
                                                                                  lnum)
                                                                           as
                                                                           *mut libc::c_char);
                                                            xfree(p as
                                                                      *mut libc::c_void);
                                                            if i !=
                                                                   0 as
                                                                       libc::c_int
                                                               {
                                                                changed_internal();
                                                                buf_inc_changedtick(curbuf);
                                                                break ;
                                                            } else {
                                                                idx += 1
                                                            }
                                                        }
                                                    }
                                                    /*
   * Delete the lines from the original file and the dummy line from the
   * empty buffer.  These will now be after the last line in the buffer.
   */
                                                    while (*curbuf).b_ml.ml_line_count
                                                              > lnum &&
                                                              (*curbuf).b_ml.ml_flags
                                                                  & ML_EMPTY
                                                                  == 0 {
                                                        ml_delete((*curbuf).b_ml.ml_line_count,
                                                                  false_0 !=
                                                                      0);
                                                    }
                                                    (*curbuf).b_flags |=
                                                        BF_RECOVERED;
                                                    recoverymode = FALSE;
                                                    if got_int != 0 {
                                                        emsg(gettext(b"E311: Recovery Interrupted\x00"
                                                                         as
                                                                         *const u8
                                                                         as
                                                                         *const libc::c_char
                                                                         as
                                                                         *mut libc::c_char)
                                                                 as
                                                                 *mut char_u);
                                                    } else if error != 0 {
                                                        no_wait_return += 1;
                                                        msg(b">>>>>>>>>>>>>\x00"
                                                                as *const u8
                                                                as
                                                                *const libc::c_char
                                                                as
                                                                *mut char_u);
                                                        emsg(gettext(b"E312: Errors detected while recovering; look for lines starting with ???\x00"
                                                                         as
                                                                         *const u8
                                                                         as
                                                                         *const libc::c_char
                                                                         as
                                                                         *mut libc::c_char)
                                                                 as
                                                                 *mut char_u);
                                                        no_wait_return -= 1;
                                                        msg(gettext(b"See \":help E312\" for more information.\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const libc::c_char
                                                                        as
                                                                        *mut libc::c_char)
                                                                as
                                                                *mut char_u);
                                                        msg(b">>>>>>>>>>>>>\x00"
                                                                as *const u8
                                                                as
                                                                *const libc::c_char
                                                                as
                                                                *mut char_u);
                                                    } else {
                                                        if (*curbuf).b_changed
                                                               != 0 {
                                                            msg(gettext(b"Recovery completed. You should check if everything is OK.\x00"
                                                                            as
                                                                            *const u8
                                                                            as
                                                                            *const libc::c_char
                                                                            as
                                                                            *mut libc::c_char)
                                                                    as
                                                                    *mut char_u);
                                                            msg_puts(gettext(b"\n(You might want to write out this file under another name\n\x00"
                                                                                 as
                                                                                 *const u8
                                                                                 as
                                                                                 *const libc::c_char
                                                                                 as
                                                                                 *mut libc::c_char)
                                                                         as
                                                                         *const libc::c_char);
                                                            msg_puts(gettext(b"and run diff with the original file to check for changes)\x00"
                                                                                 as
                                                                                 *const u8
                                                                                 as
                                                                                 *const libc::c_char
                                                                                 as
                                                                                 *mut libc::c_char)
                                                                         as
                                                                         *const libc::c_char);
                                                        } else {
                                                            msg(gettext(b"Recovery completed. Buffer contents equals file contents.\x00"
                                                                            as
                                                                            *const u8
                                                                            as
                                                                            *const libc::c_char
                                                                            as
                                                                            *mut libc::c_char)
                                                                    as
                                                                    *mut char_u);
                                                        }
                                                        msg_puts(gettext(b"\nYou may want to delete the .swp file now.\n\n\x00"
                                                                             as
                                                                             *const u8
                                                                             as
                                                                             *const libc::c_char
                                                                             as
                                                                             *mut libc::c_char)
                                                                     as
                                                                     *const libc::c_char);
                                                        cmdline_row = msg_row
                                                    }
                                                    redraw_curbuf_later(NOT_VALID);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        _ => { }
    }
    xfree(fname_used as *mut libc::c_void);
    recoverymode = FALSE;
    if !mfp.is_null() {
        if !hp.is_null() { mf_put(mfp, hp, false_0 != 0, false_0 != 0); }
        mf_close(mfp, false_0 != 0);
        /* will also xfree(mfp->mf_fname) */
    }
    if !buf.is_null() {
        //may be NULL if swap file not found.
        xfree((*buf).b_ml.ml_stack as *mut libc::c_void);
        xfree(buf as *mut libc::c_void);
    }
    if serious_error != 0 && called_from_main != 0 {
        ml_close(curbuf, TRUE);
    } else {
        apply_autocmds(EVENT_BUFREADPOST, NULL_1 as *mut char_u,
                       (*curbuf).b_fname, FALSE != 0, curbuf);
        apply_autocmds(EVENT_BUFWINENTER, NULL_1 as *mut char_u,
                       (*curbuf).b_fname, FALSE != 0, curbuf);
    };
}
/*
 * Find the names of swap files in current directory and the directory given
 * with the 'directory' option.
 *
 * Used to:
 * - list the swap files for "vim -r"
 * - count the number of swap files when recovering
 * - list the swap files when recovering
 * - find the name of the n'th swap file when recovering
 */
#[no_mangle]
#[c2rust::src_loc = "1264:1"]
pub unsafe extern "C" fn recover_names(mut fname: *mut char_u,
                                       mut list: libc::c_int,
                                       mut nr: libc::c_int,
                                       mut fname_out: *mut *mut char_u)
 -> libc::c_int 
 /* result when "nr" > 0 */
 {
    let mut num_names: libc::c_int = 0;
    let mut names: [*mut char_u; 6] = [0 as *mut char_u; 6];
    let mut tail = 0 as *mut char_u;
    let mut p = 0 as *mut char_u;
    let mut num_files: libc::c_int = 0;
    let mut file_count = 0 as libc::c_int;
    let mut files = 0 as *mut *mut char_u;
    let mut dirp = 0 as *mut char_u;
    let mut dir_name = 0 as *mut char_u;
    let mut fname_res = NULL_1 as *mut char_u;
    let mut fname_buf: [char_u; 4096] = [0; 4096];
    if !fname.is_null() {
        /* Expand symlink in the file name, because the swap file is created
     * with the actual file instead of with the symlink. */
        if resolve_symlink(fname, fname_buf.as_mut_ptr()) == OK {
            fname_res = fname_buf.as_mut_ptr()
        } else { fname_res = fname }
    }
    if list != 0 {
        /* use msg() to start the scrolling properly */
        msg(gettext(b"Swap files found:\x00" as *const u8 as
                        *const libc::c_char as *mut libc::c_char) as
                *mut char_u);
        msg_putchar('\n' as i32);
    }
    // Do the loop for every directory in 'directory'.
  // First allocate some memory to put the directory name in.
    dir_name =
        xmalloc(strlen(p_dir as
                           *mut libc::c_char).wrapping_add(1 as libc::c_int as
                                                               libc::c_ulong))
            as *mut char_u;
    dirp = p_dir;
    while *dirp != 0 {
        // Isolate a directory name from *dirp and put it in dir_name (we know
    // it is large enough, so use 31000 for length).
    // Advance dirp to next directory name.
        copy_option_part(&mut dirp, dir_name, 31000 as libc::c_int as size_t,
                         b",\x00" as *const u8 as *const libc::c_char as
                             *mut libc::c_char); /* check directory dir_name */
        if *dir_name.offset(0 as libc::c_int as isize) as libc::c_int ==
               '.' as i32 &&
               *dir_name.offset(1 as libc::c_int as isize) as libc::c_int ==
                   NUL {
            /* check current dir */
            if fname.is_null() {
                names[0 as libc::c_int as usize] =
                    vim_strsave(b"*.sw?\x00" as *const u8 as
                                    *const libc::c_char as *mut char_u);
                /* For Unix names starting with a dot are special.  MS-Windows
         * supports this too, on some file systems. */
                names[1 as libc::c_int as usize] =
                    vim_strsave(b".*.sw?\x00" as *const u8 as
                                    *const libc::c_char as *mut char_u);
                names[2 as libc::c_int as usize] =
                    vim_strsave(b".sw?\x00" as *const u8 as
                                    *const libc::c_char as *mut char_u);
                num_names = 3 as libc::c_int
            } else {
                num_names =
                    recov_file_names(names.as_mut_ptr(), fname_res, TRUE)
            }
        } else if fname.is_null() {
            names[0 as libc::c_int as usize] =
                concat_fnames(dir_name as *mut libc::c_char,
                              b"*.sw?\x00" as *const u8 as
                                  *const libc::c_char, TRUE != 0) as
                    *mut char_u;
            /* For Unix names starting with a dot are special.  MS-Windows
         * supports this too, on some file systems. */
            names[1 as libc::c_int as usize] =
                concat_fnames(dir_name as *mut libc::c_char,
                              b".*.sw?\x00" as *const u8 as
                                  *const libc::c_char, TRUE != 0) as
                    *mut char_u;
            names[2 as libc::c_int as usize] =
                concat_fnames(dir_name as *mut libc::c_char,
                              b".sw?\x00" as *const u8 as *const libc::c_char,
                              TRUE != 0) as *mut char_u;
            num_names = 3 as libc::c_int
        } else {
            let mut len =
                strlen(dir_name as *mut libc::c_char) as libc::c_int;
            p = dir_name.offset(len as isize);
            if after_pathsep(dir_name as *mut libc::c_char,
                             p as *mut libc::c_char) != 0 &&
                   len > 1 as libc::c_int &&
                   *p.offset(-(1 as libc::c_int) as isize) as libc::c_int ==
                       *p.offset(-(2 as libc::c_int) as isize) as libc::c_int
               {
                // Ends with '//', Use Full path for swap name
                tail =
                    make_percent_swname(dir_name as *mut libc::c_char,
                                        fname_res as *mut libc::c_char) as
                        *mut char_u
            } else {
                tail = path_tail(fname_res);
                tail =
                    concat_fnames(dir_name as *mut libc::c_char,
                                  tail as *mut libc::c_char, TRUE != 0) as
                        *mut char_u
            }
            num_names = recov_file_names(names.as_mut_ptr(), tail, FALSE);
            xfree(tail as *mut libc::c_void);
        }
        if num_names == 0 as libc::c_int {
            num_files = 0 as libc::c_int
        } else if expand_wildcards(num_names, names.as_mut_ptr(),
                                   &mut num_files, &mut files,
                                   EW_KEEPALL | EW_FILE | EW_SILENT) == FAIL {
            num_files = 0 as libc::c_int
        }
        /*
     * When no swap file found, wildcard expansion might have failed (e.g.
     * not able to execute the shell).
     * Try finding a swap file by simply adding ".swp" to the file name.
     */
        if *dirp as libc::c_int == NUL &&
               file_count + num_files == 0 as libc::c_int && !fname.is_null()
           {
            let mut swapname =
                modname(fname_res as *mut libc::c_char,
                        b".swp\x00" as *const u8 as *const libc::c_char,
                        TRUE != 0) as *mut char_u;
            if !swapname.is_null() {
                if os_path_exists(swapname) {
                    files =
                        xmalloc(::std::mem::size_of::<*mut char_u>() as
                                    libc::c_ulong) as *mut *mut char_u;
                    let ref mut fresh12 =
                        *files.offset(0 as libc::c_int as isize);
                    *fresh12 = swapname;
                    swapname = NULL_1 as *mut char_u;
                    num_files = 1 as libc::c_int
                }
                xfree(swapname as *mut libc::c_void);
            }
        }
        /*
     * remove swapfile name of the current buffer, it must be ignored
     */
        if !(*curbuf).b_ml.ml_mfp.is_null() &&
               { p = (*(*curbuf).b_ml.ml_mfp).mf_fname; !p.is_null() } {
            let mut i = 0 as libc::c_int;
            while i < num_files {
                // Do not expand wildcards, on Windows would try to expand
        // "%tmp%" in "%tmp%file"
                if path_full_compare(p, *files.offset(i as isize),
                                     true_0 != 0, false_0 != 0) as
                       libc::c_uint &
                       kEqualFiles as libc::c_int as libc::c_uint != 0 {
                    // Remove the name from files[i].  Move further entries
          // down.  When the array becomes empty free it here, since
          // FreeWild() won't be called below.
                    xfree(*files.offset(i as isize) as *mut libc::c_void);
                    num_files -= 1;
                    if num_files == 0 as libc::c_int {
                        xfree(files as *mut libc::c_void);
                    } else {
                        while i < num_files {
                            let ref mut fresh13 = *files.offset(i as isize);
                            *fresh13 =
                                *files.offset((i + 1 as libc::c_int) as
                                                  isize);
                            i += 1
                        }
                    }
                }
                i += 1
            }
        }
        if nr > 0 as libc::c_int {
            file_count += num_files;
            if nr <= file_count {
                *fname_out =
                    vim_strsave(*files.offset((nr - 1 as libc::c_int +
                                                   num_files - file_count) as
                                                  isize));
                dirp =
                    b"\x00" as *const u8 as *const libc::c_char as *mut char_u
                /* stop searching */
            }
        } else if list != 0 {
            if *dir_name.offset(0 as libc::c_int as isize) as libc::c_int ==
                   '.' as i32 &&
                   *dir_name.offset(1 as libc::c_int as isize) as libc::c_int
                       == NUL {
                if fname.is_null() {
                    msg_puts(gettext(b"   In current directory:\n\x00" as
                                         *const u8 as *const libc::c_char as
                                         *mut libc::c_char) as
                                 *const libc::c_char);
                } else {
                    msg_puts(gettext(b"   Using specified name:\n\x00" as
                                         *const u8 as *const libc::c_char as
                                         *mut libc::c_char) as
                                 *const libc::c_char);
                }
            } else {
                msg_puts(gettext(b"   In directory \x00" as *const u8 as
                                     *const libc::c_char as *mut libc::c_char)
                             as *const libc::c_char);
                msg_home_replace(dir_name);
                msg_puts(b":\n\x00" as *const u8 as *const libc::c_char);
            }
            if num_files != 0 {
                let mut i_0 = 0 as libc::c_int;
                while i_0 < num_files {
                    /* print the swap file name */
                    file_count += 1;
                    msg_outnum(file_count as libc::c_long);
                    msg_puts(b".    \x00" as *const u8 as
                                 *const libc::c_char);
                    msg_puts(path_tail(*files.offset(i_0 as isize)) as
                                 *const libc::c_char);
                    msg_putchar('\n' as i32);
                    swapfile_info(*files.offset(i_0 as isize));
                    i_0 += 1
                }
            } else {
                msg_puts(gettext(b"      -- none --\n\x00" as *const u8 as
                                     *const libc::c_char as *mut libc::c_char)
                             as *const libc::c_char);
            }
            ui_flush();
        } else { file_count += num_files }
        let mut i_1 = 0 as libc::c_int;
        while i_1 < num_names {
            xfree(names[i_1 as usize] as *mut libc::c_void);
            i_1 += 1
        }
        if num_files > 0 as libc::c_int { FreeWild(num_files, files); }
    }
    xfree(dir_name as *mut libc::c_void);
    return file_count;
}
/*
 * Append the full path to name with path separators made into percent
 * signs, to dir. An unnamed buffer is handled as "" (<currentdir>/"")
 */
#[no_mangle]
#[c2rust::src_loc = "1441:1"]
pub unsafe extern "C" fn make_percent_swname(mut dir: *const libc::c_char,
                                             mut name: *mut libc::c_char)
 -> *mut libc::c_char {
    let mut d = NULL_1 as *mut libc::c_char;
    let mut f =
        fix_fname(if !name.is_null() {
                      name
                  } else { b"\x00" as *const u8 as *const libc::c_char });
    if !f.is_null() {
        let mut s = xstrdup(f);
        d = s;
        while *d as libc::c_int != NUL {
            if vim_ispathsep(*d as libc::c_int) != 0 {
                *d = '%' as i32 as libc::c_char
            }
            d = d.offset(utfc_ptr2len(d as *mut char_u) as isize)
        }
        d = concat_fnames(dir, s, TRUE != 0);
        xfree(s as *mut libc::c_void);
        xfree(f as *mut libc::c_void);
    }
    return d;
}
#[c2rust::src_loc = "1460:13"]
static mut process_still_running: bool = false;
// / Return information found in swapfile "fname" in dictionary "d".
// / This is used by the swapinfo() function.
#[no_mangle]
#[c2rust::src_loc = "1464:1"]
pub unsafe extern "C" fn get_b0_dict(mut fname: *const libc::c_char,
                                     mut d: *mut dict_T) {
    let mut fd: libc::c_int = 0;
    let mut b0 =
        block0{b0_id: [0; 2],
               b0_version: [0; 10],
               b0_page_size: [0; 4],
               b0_mtime: [0; 4],
               b0_ino: [0; 4],
               b0_pid: [0; 4],
               b0_uname: [0; 40],
               b0_hname: [0; 40],
               b0_fname: [0; 900],
               b0_magic_long: 0,
               b0_magic_int: 0,
               b0_magic_short: 0,
               b0_magic_char: 0,};
    fd = os_open(fname, O_RDONLY, 0 as libc::c_int);
    if fd >= 0 as libc::c_int {
        if read_eintr(fd, &mut b0 as *mut block0 as *mut libc::c_void,
                      ::std::mem::size_of::<block0>() as libc::c_ulong) as
               libc::c_ulong ==
               ::std::mem::size_of::<block0>() as libc::c_ulong {
            if ml_check_b0_id(&mut b0) as libc::c_int == FAIL {
                tv_dict_add_str(d,
                                b"error\x00" as *const u8 as
                                    *const libc::c_char,
                                (::std::mem::size_of::<[libc::c_char; 6]>() as
                                     libc::c_ulong).wrapping_sub(1 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_ulong),
                                b"Not a swap file\x00" as *const u8 as
                                    *const libc::c_char);
            } else if b0_magic_wrong(&mut b0) != 0 {
                tv_dict_add_str(d,
                                b"error\x00" as *const u8 as
                                    *const libc::c_char,
                                (::std::mem::size_of::<[libc::c_char; 6]>() as
                                     libc::c_ulong).wrapping_sub(1 as
                                                                     libc::c_int
                                                                     as
                                                                     libc::c_ulong),
                                b"Magic number mismatch\x00" as *const u8 as
                                    *const libc::c_char);
            } else {
                // We have swap information.
                tv_dict_add_str_len(d,
                                    b"version\x00" as *const u8 as
                                        *const libc::c_char,
                                    (::std::mem::size_of::<[libc::c_char; 8]>()
                                         as
                                         libc::c_ulong).wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_ulong),
                                    b0.b0_version.as_mut_ptr() as
                                        *mut libc::c_char, 10 as libc::c_int);
                tv_dict_add_str_len(d,
                                    b"user\x00" as *const u8 as
                                        *const libc::c_char,
                                    (::std::mem::size_of::<[libc::c_char; 5]>()
                                         as
                                         libc::c_ulong).wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_ulong),
                                    b0.b0_uname.as_mut_ptr() as
                                        *mut libc::c_char, B0_UNAME_SIZE);
                tv_dict_add_str_len(d,
                                    b"host\x00" as *const u8 as
                                        *const libc::c_char,
                                    (::std::mem::size_of::<[libc::c_char; 5]>()
                                         as
                                         libc::c_ulong).wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_ulong),
                                    b0.b0_hname.as_mut_ptr() as
                                        *mut libc::c_char, B0_HNAME_SIZE);
                tv_dict_add_str_len(d,
                                    b"fname\x00" as *const u8 as
                                        *const libc::c_char,
                                    (::std::mem::size_of::<[libc::c_char; 6]>()
                                         as
                                         libc::c_ulong).wrapping_sub(1 as
                                                                         libc::c_int
                                                                         as
                                                                         libc::c_ulong),
                                    b0.b0_fname.as_mut_ptr() as
                                        *mut libc::c_char, B0_FNAME_SIZE_ORG);
                tv_dict_add_nr(d,
                               b"pid\x00" as *const u8 as *const libc::c_char,
                               (::std::mem::size_of::<[libc::c_char; 4]>() as
                                    libc::c_ulong).wrapping_sub(1 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong),
                               char_to_long(b0.b0_pid.as_mut_ptr()));
                tv_dict_add_nr(d,
                               b"mtime\x00" as *const u8 as
                                   *const libc::c_char,
                               (::std::mem::size_of::<[libc::c_char; 6]>() as
                                    libc::c_ulong).wrapping_sub(1 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong),
                               char_to_long(b0.b0_mtime.as_mut_ptr()));
                tv_dict_add_nr(d,
                               b"dirty\x00" as *const u8 as
                                   *const libc::c_char,
                               (::std::mem::size_of::<[libc::c_char; 6]>() as
                                    libc::c_ulong).wrapping_sub(1 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong),
                               if b0.b0_fname[(B0_FNAME_SIZE_ORG -
                                                   1 as libc::c_int) as usize]
                                      as libc::c_int != 0 {
                                   1 as libc::c_int
                               } else { 0 as libc::c_int } as varnumber_T);
                tv_dict_add_nr(d,
                               b"inode\x00" as *const u8 as
                                   *const libc::c_char,
                               (::std::mem::size_of::<[libc::c_char; 6]>() as
                                    libc::c_ulong).wrapping_sub(1 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong),
                               char_to_long(b0.b0_ino.as_mut_ptr()));
            }
        } else {
            tv_dict_add_str(d,
                            b"error\x00" as *const u8 as *const libc::c_char,
                            (::std::mem::size_of::<[libc::c_char; 6]>() as
                                 libc::c_ulong).wrapping_sub(1 as libc::c_int
                                                                 as
                                                                 libc::c_ulong),
                            b"Cannot read file\x00" as *const u8 as
                                *const libc::c_char);
        }
        close(fd);
    } else {
        tv_dict_add_str(d, b"error\x00" as *const u8 as *const libc::c_char,
                        (::std::mem::size_of::<[libc::c_char; 6]>() as
                             libc::c_ulong).wrapping_sub(1 as libc::c_int as
                                                             libc::c_ulong),
                        b"Cannot open file\x00" as *const u8 as
                            *const libc::c_char);
    };
}
// / Give information about an existing swap file.
// / Returns timestamp (0 when unknown).
#[c2rust::src_loc = "1501:1"]
unsafe extern "C" fn swapfile_info(mut fname: *mut char_u) -> time_t {
    if !fname.is_null() {
    } else {
        __assert_fail(b"fname != NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/vole/neovim/src/nvim/memline.c\x00" as *const u8
                          as *const libc::c_char,
                      1503 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 31],
                                                &[libc::c_char; 31]>(b"time_t swapfile_info(char_u *)\x00")).as_ptr());
    }
    let mut fd: libc::c_int = 0;
    let mut b0 =
        block0{b0_id: [0; 2],
               b0_version: [0; 10],
               b0_page_size: [0; 4],
               b0_mtime: [0; 4],
               b0_ino: [0; 4],
               b0_pid: [0; 4],
               b0_uname: [0; 40],
               b0_hname: [0; 40],
               b0_fname: [0; 900],
               b0_magic_long: 0,
               b0_magic_int: 0,
               b0_magic_short: 0,
               b0_magic_char: 0,};
    let mut x = 0 as libc::c_int as time_t;
    let mut p = 0 as *mut libc::c_char;
    let mut uname: [libc::c_char; 40] = [0; 40];
    /* print the swap file date */
    let mut file_info =
        FileInfo{stat:
                     uv_stat_t{st_dev: 0,
                               st_mode: 0,
                               st_nlink: 0,
                               st_uid: 0,
                               st_gid: 0,
                               st_rdev: 0,
                               st_ino: 0,
                               st_size: 0,
                               st_blksize: 0,
                               st_blocks: 0,
                               st_flags: 0,
                               st_gen: 0,
                               st_atim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_mtim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_ctim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_birthtim:
                                   uv_timespec_t{tv_sec: 0, tv_nsec: 0,},},};
    if os_fileinfo(fname as *mut libc::c_char, &mut file_info) {
        /* print name of owner of the file */
        if os_get_uname(file_info.stat.st_uid as uv_uid_t, uname.as_mut_ptr(),
                        B0_UNAME_SIZE as size_t) == OK {
            msg_puts(gettext(b"          owned by: \x00" as *const u8 as
                                 *const libc::c_char as *mut libc::c_char) as
                         *const libc::c_char); // includes '\n'
            msg_outtrans(uname.as_mut_ptr() as *mut char_u);
            msg_puts(gettext(b"   dated: \x00" as *const u8 as
                                 *const libc::c_char as *mut libc::c_char) as
                         *const libc::c_char);
        } else {
            msg_puts(gettext(b"             dated: \x00" as *const u8 as
                                 *const libc::c_char as *mut libc::c_char) as
                         *const libc::c_char);
        }
        x = file_info.stat.st_mtim.tv_sec;
        p = ctime(&mut x);
        if p.is_null() {
            msg_puts(b"(invalid)\n\x00" as *const u8 as *const libc::c_char);
        } else { msg_puts(p as *const libc::c_char); }
    }
    /*
   * print the original file name
   */
    fd = os_open(fname as *mut libc::c_char, O_RDONLY, 0 as libc::c_int);
    if fd >= 0 as libc::c_int {
        if read_eintr(fd, &mut b0 as *mut block0 as *mut libc::c_void,
                      ::std::mem::size_of::<block0>() as libc::c_ulong) as
               libc::c_ulong ==
               ::std::mem::size_of::<block0>() as libc::c_ulong {
            if strncmp(b0.b0_version.as_mut_ptr() as *mut libc::c_char,
                       b"VIM 3.0\x00" as *const u8 as *const libc::c_char as
                           *mut libc::c_char, 7 as libc::c_int as size_t) ==
                   0 as libc::c_int {
                msg_puts(gettext(b"         [from Vim version 3.0]\x00" as
                                     *const u8 as *const libc::c_char as
                                     *mut libc::c_char) as
                             *const libc::c_char);
            } else if ml_check_b0_id(&mut b0) as libc::c_int == FAIL {
                msg_puts(gettext(b"         [does not look like a Vim swap file]\x00"
                                     as *const u8 as *const libc::c_char as
                                     *mut libc::c_char) as
                             *const libc::c_char);
            } else if !ml_check_b0_strings(&mut b0) {
                msg_puts(gettext(b"         [garbled strings (not nul terminated)]\x00"
                                     as *const u8 as *const libc::c_char as
                                     *mut libc::c_char) as
                             *const libc::c_char);
            } else {
                msg_puts(gettext(b"         file name: \x00" as *const u8 as
                                     *const libc::c_char as *mut libc::c_char)
                             as *const libc::c_char);
                if b0.b0_fname[0 as libc::c_int as usize] as libc::c_int ==
                       NUL {
                    msg_puts(gettext(b"[No Name]\x00" as *const u8 as
                                         *const libc::c_char as
                                         *mut libc::c_char) as
                                 *const libc::c_char);
                } else { msg_outtrans(b0.b0_fname.as_mut_ptr()); }
                msg_puts(gettext(b"\n          modified: \x00" as *const u8 as
                                     *const libc::c_char as *mut libc::c_char)
                             as *const libc::c_char);
                msg_puts(if b0.b0_fname[(900 as libc::c_int -
                                             1 as libc::c_int) as usize] as
                                libc::c_int != 0 {
                             gettext(b"YES\x00" as *const u8 as
                                         *const libc::c_char as
                                         *mut libc::c_char)
                         } else {
                             gettext(b"no\x00" as *const u8 as
                                         *const libc::c_char as
                                         *mut libc::c_char)
                         } as *const libc::c_char);
                if *b0.b0_uname.as_mut_ptr() as libc::c_int != NUL {
                    msg_puts(gettext(b"\n         user name: \x00" as
                                         *const u8 as *const libc::c_char as
                                         *mut libc::c_char) as
                                 *const libc::c_char);
                    msg_outtrans(b0.b0_uname.as_mut_ptr());
                }
                if *b0.b0_hname.as_mut_ptr() as libc::c_int != NUL {
                    if *b0.b0_uname.as_mut_ptr() as libc::c_int != NUL {
                        msg_puts(gettext(b"   host name: \x00" as *const u8 as
                                             *const libc::c_char as
                                             *mut libc::c_char) as
                                     *const libc::c_char);
                    } else {
                        msg_puts(gettext(b"\n         host name: \x00" as
                                             *const u8 as *const libc::c_char
                                             as *mut libc::c_char) as
                                     *const libc::c_char);
                    }
                    msg_outtrans(b0.b0_hname.as_mut_ptr());
                }
                if char_to_long(b0.b0_pid.as_mut_ptr()) != 0 as libc::c_long {
                    msg_puts(gettext(b"\n        process ID: \x00" as
                                         *const u8 as *const libc::c_char as
                                         *mut libc::c_char) as
                                 *const libc::c_char);
                    msg_outnum(char_to_long(b0.b0_pid.as_mut_ptr()));
                    if os_proc_running(char_to_long(b0.b0_pid.as_mut_ptr()) as
                                           libc::c_int) {
                        msg_puts(gettext(b" (STILL RUNNING)\x00" as *const u8
                                             as *const libc::c_char as
                                             *mut libc::c_char) as
                                     *const libc::c_char);
                        process_still_running = true_0 != 0
                    }
                }
                if b0_magic_wrong(&mut b0) != 0 {
                    msg_puts(gettext(b"\n         [not usable on this computer]\x00"
                                         as *const u8 as *const libc::c_char
                                         as *mut libc::c_char) as
                                 *const libc::c_char);
                }
            }
        } else {
            msg_puts(gettext(b"         [cannot be read]\x00" as *const u8 as
                                 *const libc::c_char as *mut libc::c_char) as
                         *const libc::c_char);
        }
        close(fd);
    } else {
        msg_puts(gettext(b"         [cannot be opened]\x00" as *const u8 as
                             *const libc::c_char as *mut libc::c_char) as
                     *const libc::c_char);
    }
    msg_putchar('\n' as i32);
    return x;
}
// / Returns TRUE if the swap file looks OK and there are no changes, thus it
// / can be safely deleted.
#[c2rust::src_loc = "1592:1"]
unsafe extern "C" fn swapfile_unchanged(mut fname: *mut libc::c_char)
 -> time_t {
    let mut b0 =
        block0{b0_id: [0; 2],
               b0_version: [0; 10],
               b0_page_size: [0; 4],
               b0_mtime: [0; 4],
               b0_ino: [0; 4],
               b0_pid: [0; 4],
               b0_uname: [0; 40],
               b0_hname: [0; 40],
               b0_fname: [0; 900],
               b0_magic_long: 0,
               b0_magic_int: 0,
               b0_magic_short: 0,
               b0_magic_char: 0,};
    let mut ret = true_0;
    // Swap file must exist.
    if !os_path_exists(fname as *mut char_u) { return false_0 as time_t }
    // must be able to read the first block
    let mut fd = os_open(fname, O_RDONLY, 0 as libc::c_int);
    if fd < 0 as libc::c_int { return false_0 as time_t }
    if read_eintr(fd, &mut b0 as *mut block0 as *mut libc::c_void,
                  ::std::mem::size_of::<block0>() as libc::c_ulong) as
           libc::c_ulong != ::std::mem::size_of::<block0>() as libc::c_ulong {
        close(fd);
        return false_0 as time_t
    }
    // the ID and magic number must be correct
    if ml_check_b0_id(&mut b0) as libc::c_int == FAIL ||
           b0_magic_wrong(&mut b0) != 0 {
        ret = false_0
    }
    // must be unchanged
    if b0.b0_fname[(B0_FNAME_SIZE_ORG - 1 as libc::c_int) as usize] != 0 {
        ret = false_0
    }
    // process must be known and not running.
    let mut pid = char_to_long(b0.b0_pid.as_mut_ptr());
    if pid == 0 as libc::c_long ||
           os_proc_running(pid as libc::c_int) as libc::c_int != 0 {
        ret = false_0
    }
    // TODO(bram): Should we check if the swap file was created on the current
  // system?  And the current user?
    close(fd);
    return ret as time_t;
}
#[c2rust::src_loc = "1635:1"]
unsafe extern "C" fn recov_file_names(mut names: *mut *mut char_u,
                                      mut path: *mut char_u,
                                      mut prepend_dot: libc::c_int)
 -> libc::c_int {
    let mut num_names = 0 as libc::c_int;
    // May also add the file name with a dot prepended, for swap file in same
  // dir as original file.
    if prepend_dot != 0 {
        let ref mut fresh14 = *names.offset(num_names as isize);
        *fresh14 =
            modname(path as *mut libc::c_char,
                    b".sw?\x00" as *const u8 as *const libc::c_char,
                    TRUE != 0) as *mut char_u;
        if (*names.offset(num_names as isize)).is_null() { return num_names }
        num_names += 1
    }
    // Form the normal swap file name pattern by appending ".sw?".
    let ref mut fresh15 = *names.offset(num_names as isize);
    *fresh15 =
        concat_fnames(path as *mut libc::c_char,
                      b".sw?\x00" as *const u8 as *const libc::c_char,
                      FALSE != 0) as *mut char_u;
    if num_names >= 1 as libc::c_int {
        /* check if we have the same name twice */
        let mut p =
            *names.offset((num_names - 1 as libc::c_int) as
                              isize); /* file name has been expanded to full path */
        let mut i =
            strlen(*names.offset((num_names - 1 as libc::c_int) as isize) as
                       *mut libc::c_char) as libc::c_int -
                strlen(*names.offset(num_names as isize) as *mut libc::c_char)
                    as libc::c_int;
        if i > 0 as libc::c_int { p = p.offset(i as isize) }
        if strcmp(p as *mut libc::c_char,
                  *names.offset(num_names as isize) as *mut libc::c_char) !=
               0 as libc::c_int {
            num_names += 1
        } else {
            xfree(*names.offset(num_names as isize) as *mut libc::c_void);
        }
    } else { num_names += 1 }
    return num_names;
}
/*
 * sync all memlines
 *
 * If 'check_file' is TRUE, check if original file exists and was not changed.
 * If 'check_char' is TRUE, stop syncing when character becomes available, but
 * always sync at least one block.
 */
#[no_mangle]
#[c2rust::src_loc = "1674:1"]
pub unsafe extern "C" fn ml_sync_all(mut check_file: libc::c_int,
                                     mut check_char: libc::c_int,
                                     mut do_fsync: bool) {
    let mut buf = firstbuf; /* no file */
    while !buf.is_null() {
        if !((*buf).b_ml.ml_mfp.is_null() ||
                 (*(*buf).b_ml.ml_mfp).mf_fname.is_null()) {
            ml_flush_line(buf); /* flush buffered line */
                                            /* flush locked block */
            ml_find_line(buf, 0 as libc::c_int as linenr_T, ML_FLUSH);
            if bufIsChanged(buf) as libc::c_int != 0 && check_file != 0 &&
                   mf_need_trans((*buf).b_ml.ml_mfp) as libc::c_int != 0 &&
                   !(*buf).b_ffname.is_null() {
                /*
       * If the original file does not exist anymore or has been changed
       * call ml_preserve() to get rid of all negative numbered blocks.
       */
                let mut file_info =
                    FileInfo{stat:
                                 uv_stat_t{st_dev: 0,
                                           st_mode: 0,
                                           st_nlink: 0,
                                           st_uid: 0,
                                           st_gid: 0,
                                           st_rdev: 0,
                                           st_ino: 0,
                                           st_size: 0,
                                           st_blksize: 0,
                                           st_blocks: 0,
                                           st_flags: 0,
                                           st_gen: 0,
                                           st_atim:
                                               uv_timespec_t{tv_sec: 0,
                                                             tv_nsec: 0,},
                                           st_mtim:
                                               uv_timespec_t{tv_sec: 0,
                                                             tv_nsec: 0,},
                                           st_ctim:
                                               uv_timespec_t{tv_sec: 0,
                                                             tv_nsec: 0,},
                                           st_birthtim:
                                               uv_timespec_t{tv_sec: 0,
                                                             tv_nsec: 0,},},};
                if !os_fileinfo((*buf).b_ffname as *mut libc::c_char,
                                &mut file_info) ||
                       file_info.stat.st_mtim.tv_sec != (*buf).b_mtime_read ||
                       os_fileinfo_size(&mut file_info) != (*buf).b_orig_size
                   {
                    ml_preserve(buf, false_0, do_fsync);
                    did_check_timestamps = false_0;
                    need_check_timestamps = true_0
                    // give message later
                }
            }
            if (*(*buf).b_ml.ml_mfp).mf_dirty {
                mf_sync((*buf).b_ml.ml_mfp,
                        (if check_char != 0 {
                             MFS_STOP
                         } else { 0 as libc::c_int }) |
                            (if do_fsync as libc::c_int != 0 &&
                                    bufIsChanged(buf) as libc::c_int != 0 {
                                 MFS_FLUSH
                             } else { 0 as libc::c_int }));
                if check_char != 0 && os_char_avail() as libc::c_int != 0 {
                    break ;
                }
            }
        }
        buf = (*buf).b_next
    };
}
/*
 * sync one buffer, including negative blocks
 *
 * after this all the blocks are in the swap file
 *
 * Used for the :preserve command and when the original file has been
 * changed or deleted.
 *
 * when message is TRUE the success of preserving is reported
 */
#[no_mangle]
#[c2rust::src_loc = "1718:1"]
pub unsafe extern "C" fn ml_preserve(mut buf: *mut buf_T,
                                     mut message: libc::c_int,
                                     mut do_fsync: bool) {
    let mut current_block: u64;
    let mut hp = 0 as *mut bhdr_T;
    let mut lnum: linenr_T = 0;
    let mut mfp = (*buf).b_ml.ml_mfp;
    let mut status: libc::c_int = 0;
    let mut got_int_save = got_int;
    if mfp.is_null() || (*mfp).mf_fname.is_null() {
        if message != 0 {
            emsg(gettext(b"E313: Cannot preserve, there is no swap file\x00"
                             as *const u8 as *const libc::c_char as
                             *mut libc::c_char) as *mut char_u);
        }
        return
    }
    /* We only want to stop when interrupted here, not when interrupted
   * before. */
    ::std::ptr::write_volatile(&mut got_int as *mut libc::c_int,
                               FALSE); // flush buffered line
    ml_flush_line(buf); // flush locked block
    ml_find_line(buf, 0 as libc::c_int as linenr_T, ML_FLUSH);
    status =
        mf_sync(mfp,
                MFS_ALL |
                    (if do_fsync as libc::c_int != 0 {
                         MFS_FLUSH
                     } else { 0 as libc::c_int }));
    /* stack is invalid after mf_sync(.., MFS_ALL) */
    (*buf).b_ml.ml_stack_top = 0 as libc::c_int;
    /*
   * Some of the data blocks may have been changed from negative to
   * positive block number. In that case the pointer blocks need to be
   * updated.
   *
   * We don't know in which pointer block the references are, so we visit
   * all data blocks until there are no more translations to be done (or
   * we hit the end of the file, which can only happen in case a write fails,
   * e.g. when file system if full).
   * ml_find_line() does the work by translating the negative block numbers
   * when getting the first line of each data block.
   */
    if mf_need_trans(mfp) as libc::c_int != 0 && got_int == 0 {
        lnum = 1 as libc::c_int as linenr_T;
        loop  {
            if !(mf_need_trans(mfp) as libc::c_int != 0 &&
                     lnum <= (*buf).b_ml.ml_line_count) {
                current_block = 12147880666119273379;
                break ;
            }
            hp = ml_find_line(buf, lnum, ML_FIND);
            if hp.is_null() {
                status = FAIL;
                current_block = 2850111382077548052;
                break ;
            } else {
                lnum =
                    (*buf).b_ml.ml_locked_high +
                        1 as libc::c_int as libc::c_long
            }
        }
        match current_block {
            2850111382077548052 => { }
            _ => {
                // stack is invalid now
                ml_find_line(buf, 0 as libc::c_int as linenr_T,
                             ML_FLUSH); // flush locked block
                // sync the updated pointer blocks
                if mf_sync(mfp,
                           MFS_ALL |
                               (if do_fsync as libc::c_int != 0 {
                                    MFS_FLUSH
                                } else { 0 as libc::c_int })) == FAIL {
                    status = FAIL
                }
                (*buf).b_ml.ml_stack_top = 0 as libc::c_int
            }
        }
    }
    ::std::ptr::write_volatile(&mut got_int as *mut libc::c_int,
                               ::std::ptr::read_volatile::<libc::c_int>(&got_int
                                                                            as
                                                                            *const libc::c_int)
                                   | got_int_save);
    if message != 0 {
        if status == OK {
            msg(gettext(b"File preserved\x00" as *const u8 as
                            *const libc::c_char as *mut libc::c_char) as
                    *mut char_u);
        } else {
            emsg(gettext(b"E314: Preserve failed\x00" as *const u8 as
                             *const libc::c_char as *mut libc::c_char) as
                     *mut char_u);
        }
    };
}
/*
 * NOTE: The pointer returned by the ml_get_*() functions only remains valid
 * until the next call!
 *  line1 = ml_get(1);
 *  line2 = ml_get(2);	// line1 is now invalid!
 * Make a copy of the line if necessary.
 */
/*
 * Return a pointer to a (read-only copy of a) line.
 *
 * On failure an error message is given and IObuff is returned (to avoid
 * having to check for error everywhere).
 */
#[no_mangle]
#[c2rust::src_loc = "1797:1"]
pub unsafe extern "C" fn ml_get(mut lnum: linenr_T) -> *mut char_u {
    return ml_get_buf(curbuf, lnum, FALSE != 0);
}
/*
 * Return pointer to position "pos".
 */
#[no_mangle]
#[c2rust::src_loc = "1805:1"]
pub unsafe extern "C" fn ml_get_pos(mut pos: *const pos_T) -> *mut char_u {
    return ml_get_buf(curbuf, (*pos).lnum,
                      false_0 != 0).offset((*pos).col as isize);
}
/*
 * Return a pointer to a line in a specific buffer
 *
 * "will_change": if TRUE mark the buffer dirty (chars in the line will be
 * changed)
 */
#[no_mangle]
#[c2rust::src_loc = "1817:1"]
pub unsafe extern "C" fn ml_get_buf(mut buf: *mut buf_T, mut lnum: linenr_T,
                                    mut will_change: bool) -> *mut char_u 
 // line will be changed
 {
    let mut current_block: u64;
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut ptr = 0 as *mut char_u;
    static mut recursive: libc::c_int = 0 as libc::c_int;
    if lnum > (*buf).b_ml.ml_line_count {
        /* invalid line number */
        if recursive == 0 as libc::c_int {
            // Avoid giving this message for a recursive call, may happen when
      // the GUI redraws part of the text.
            recursive += 1;
            iemsgf(gettext(b"E315: ml_get: invalid lnum: %ld\x00" as *const u8
                               as *const libc::c_char as *mut libc::c_char) as
                       *const libc::c_char, lnum);
            recursive -= 1
        }
    } else {
        if lnum <= 0 as libc::c_int as libc::c_long {
            /* pretend line 0 is line 1 */
            lnum = 1 as libc::c_int as linenr_T
        }
        if (*buf).b_ml.ml_mfp.is_null() {
            /* there are no lines */
            return b"\x00" as *const u8 as *const libc::c_char as *mut char_u
        }
        /*
   * See if it is the same line as requested last time.
   * Otherwise may need to flush last used line.
   * Don't use the last used line when 'swapfile' is reset, need to load all
   * blocks.
   */
        if (*buf).b_ml.ml_line_lnum != lnum {
            ml_flush_line(buf);
            /*
     * Find the data block containing the line.
     * This also fills the stack with the blocks from the root to the data
     * block and releases any locked block.
     */
            hp = ml_find_line(buf, lnum, ML_FIND);
            if hp.is_null() {
                if recursive == 0 as libc::c_int {
                    // Avoid giving this message for a recursive call, may happen
        // when the GUI redraws part of the text.
                    recursive += 1;
                    get_trans_bufname(buf);
                    shorten_dir(NameBuff.as_mut_ptr());
                    iemsgf(gettext(b"E316: ml_get: cannot find line %ld in buffer %d %s\x00"
                                       as *const u8 as *const libc::c_char as
                                       *mut libc::c_char), lnum,
                           (*buf).handle, NameBuff.as_mut_ptr());
                    recursive -= 1
                }
                current_block = 6491659306918573152;
            } else {
                dp = (*hp).bh_data as *mut DATA_BL;
                ptr =
                    (dp as
                         *mut char_u).offset((*(*dp).db_index.as_mut_ptr().offset((lnum
                                                                                       -
                                                                                       (*buf).b_ml.ml_locked_low)
                                                                                      as
                                                                                      isize)
                                                  &
                                                  !((1 as libc::c_int as
                                                         libc::c_uint) <<
                                                        (::std::mem::size_of::<libc::c_uint>()
                                                             as
                                                             libc::c_ulong).wrapping_mul(8
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_ulong).wrapping_sub(1
                                                                                                                             as
                                                                                                                             libc::c_int
                                                                                                                             as
                                                                                                                             libc::c_ulong)))
                                                 as isize);
                (*buf).b_ml.ml_line_ptr = ptr;
                (*buf).b_ml.ml_line_lnum = lnum;
                (*buf).b_ml.ml_flags &= !ML_LINE_DIRTY;
                current_block = 14763689060501151050;
            }
        } else { current_block = 14763689060501151050; }
        match current_block {
            6491659306918573152 => { }
            _ => {
                if will_change {
                    (*buf).b_ml.ml_flags |= ML_LOCKED_DIRTY | ML_LOCKED_POS
                }
                return (*buf).b_ml.ml_line_ptr
            }
        }
    }
    strcpy(IObuff.as_mut_ptr() as *mut libc::c_char,
           b"???\x00" as *const u8 as *const libc::c_char as
               *mut libc::c_char);
    return IObuff.as_mut_ptr();
}
/*
 * Check if a line that was just obtained by a call to ml_get
 * is in allocated memory.
 */
#[no_mangle]
#[c2rust::src_loc = "1893:1"]
pub unsafe extern "C" fn ml_line_alloced() -> libc::c_int {
    return (*curbuf).b_ml.ml_flags & ML_LINE_DIRTY;
}
/*
 * Append a line after lnum (may be 0 to insert a line in front of the file).
 * "line" does not need to be allocated, but can't be another line in a
 * buffer, unlocking may make it invalid.
 *
 *   newfile: TRUE when starting to edit a new file, meaning that pe_old_lnum
 *		will be set for recovery
 * Check: The caller of this function should probably also call
 * appended_lines().
 *
 * return FAIL for failure, OK otherwise
 */
#[no_mangle]
#[c2rust::src_loc = "1910:1"]
pub unsafe extern "C" fn ml_append(mut lnum: linenr_T, mut line: *mut char_u,
                                   mut len: colnr_T, mut newfile: bool)
 -> libc::c_int 
 // flag, see above
 {
    /* When starting up, we might still need to create the memfile */
    if (*curbuf).b_ml.ml_mfp.is_null() &&
           open_buffer(FALSE, NULL_1 as *mut exarg_T, 0 as libc::c_int) ==
               FAIL {
        return FAIL
    }
    if (*curbuf).b_ml.ml_line_lnum != 0 as libc::c_int as libc::c_long {
        ml_flush_line(curbuf);
    }
    return ml_append_int(curbuf, lnum, line, len, newfile, FALSE);
}
/*
 * Like ml_append() but for an arbitrary buffer.  The buffer must already have
 * a memline.
 */
#[no_mangle]
#[c2rust::src_loc = "1930:1"]
pub unsafe extern "C" fn ml_append_buf(mut buf: *mut buf_T,
                                       mut lnum: linenr_T,
                                       mut line: *mut char_u,
                                       mut len: colnr_T, mut newfile: bool)
 -> libc::c_int 
 // flag, see above
 {
    if (*buf).b_ml.ml_mfp.is_null() { return FAIL }
    if (*buf).b_ml.ml_line_lnum != 0 as libc::c_int as libc::c_long {
        ml_flush_line(buf);
    }
    return ml_append_int(buf, lnum, line, len, newfile, FALSE);
}
#[c2rust::src_loc = "1947:1"]
unsafe extern "C" fn ml_append_int(mut buf: *mut buf_T, mut lnum: linenr_T,
                                   mut line: *mut char_u, mut len: colnr_T,
                                   mut newfile: bool, mut mark: libc::c_int)
 -> libc::c_int 
 // mark the new line
 {
    let mut i: libc::c_int = 0; /* number of indexes in current block */
    let mut line_count: libc::c_int = 0; /* space needed for new line */
    let mut offset: libc::c_int = 0; /* index for lnum in data block */
    let mut from: libc::c_int = 0;
    let mut to: libc::c_int = 0;
    let mut space_needed: libc::c_int = 0;
    let mut page_size: libc::c_int = 0;
    let mut page_count: libc::c_int = 0;
    let mut db_idx: libc::c_int = 0;
    let mut hp = 0 as *mut bhdr_T;
    let mut mfp = 0 as *mut memfile_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut pp = 0 as *mut PTR_BL;
    let mut ip = 0 as *mut infoptr_T;
    /* lnum out of range */
    if lnum > (*buf).b_ml.ml_line_count || (*buf).b_ml.ml_mfp.is_null() {
        return FAIL
    } /* space needed for the text */
    if lowest_marked != 0 && lowest_marked > lnum {
        lowest_marked = lnum + 1 as libc::c_int as libc::c_long
    } /* space needed for text + index */
    if len == 0 as libc::c_int {
        len = strlen(line as *mut libc::c_char) as colnr_T + 1 as libc::c_int
    }
    space_needed =
        (len as libc::c_ulong).wrapping_add(INDEX_SIZE) as libc::c_int;
    mfp = (*buf).b_ml.ml_mfp;
    page_size = (*mfp).mf_page_size as libc::c_int;
    /*
   * find the data block containing the previous line
   * This also fills the stack with the blocks from the root to the data block
   * This also releases any locked block.
   */
    hp =
        ml_find_line(buf,
                     if lnum == 0 as libc::c_int as libc::c_long {
                         1 as libc::c_int as linenr_T
                     } else { lnum }, ML_INSERT);
    if hp.is_null() { return FAIL }
    (*buf).b_ml.ml_flags &= !ML_EMPTY;
    if lnum == 0 as libc::c_int as libc::c_long {
        /* got line one instead, correct db_idx */
        db_idx = -(1 as libc::c_int)
    } else {
        db_idx = (lnum - (*buf).b_ml.ml_locked_low) as libc::c_int
    } /* careful, it is negative! */
    /* get line count before the insertion */
    line_count =
        ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low) as
            libc::c_int;
    dp = (*hp).bh_data as *mut DATA_BL;
    /*
   * If
   * - there is not enough room in the current block
   * - appending to the last line in the block
   * - not appending to the last line in the file
   * insert in front of the next block.
   */
    if ((*dp).db_free as libc::c_int) < space_needed &&
           db_idx == line_count - 1 as libc::c_int &&
           lnum < (*buf).b_ml.ml_line_count {
        /*
     * Now that the line is not going to be inserted in the block that we
     * expected, the line count has to be adjusted in the pointer blocks
     * by using ml_locked_lineadd.
     */
        (*buf).b_ml.ml_locked_lineadd -= 1; /* careful, it is negative! */
        (*buf).b_ml.ml_locked_high -= 1;
        hp =
            ml_find_line(buf, lnum + 1 as libc::c_int as libc::c_long,
                         ML_INSERT);
        if hp.is_null() { return FAIL }
        db_idx = -(1 as libc::c_int);
        /* get line count before the insertion */
        line_count =
            ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low) as
                libc::c_int; /* not enough space in data block */
        dp = (*hp).bh_data as *mut DATA_BL
    }
    (*buf).b_ml.ml_line_count += 1;
    if (*dp).db_free as libc::c_int >= space_needed {
        /* enough room in data block */
        /*
     * Insert new line in existing data block, or in data block allocated above.
     */
        (*dp).db_txt_start =
            (*dp).db_txt_start.wrapping_sub(len as libc::c_uint);
        (*dp).db_free =
            (*dp).db_free.wrapping_sub(space_needed as libc::c_uint);
        (*dp).db_line_count += 1;
        /*
     * move the text of the lines that follow to the front
     * adjust the indexes of the lines that follow
     */
        if line_count > db_idx + 1 as libc::c_int {
            if db_idx < 0 as libc::c_int {
                offset = (*dp).db_txt_end as libc::c_int
            } else {
                offset =
                    (*(*dp).db_index.as_mut_ptr().offset(db_idx as isize) &
                         !((1 as libc::c_int as libc::c_uint) <<
                               (::std::mem::size_of::<libc::c_uint>() as
                                    libc::c_ulong).wrapping_mul(8 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong).wrapping_sub(1
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    libc::c_ulong)))
                        as libc::c_int
            } /* add line at the end */
            memmove((dp as
                         *mut libc::c_char).offset((*dp).db_txt_start as
                                                       isize) as
                        *mut libc::c_void,
                    (dp as
                         *mut libc::c_char).offset((*dp).db_txt_start as
                                                       isize).offset(len as
                                                                         isize)
                        as *const libc::c_void,
                    (offset as
                         libc::c_uint).wrapping_sub((*dp).db_txt_start.wrapping_add(len
                                                                                        as
                                                                                        libc::c_uint))
                        as size_t);
            i = line_count - 1 as libc::c_int;
            while i > db_idx {
                *(*dp).db_index.as_mut_ptr().offset((i + 1 as libc::c_int) as
                                                        isize) =
                    (*(*dp).db_index.as_mut_ptr().offset(i as
                                                             isize)).wrapping_sub(len
                                                                                      as
                                                                                      libc::c_uint);
                i -= 1
            }
            *(*dp).db_index.as_mut_ptr().offset((db_idx + 1 as libc::c_int) as
                                                    isize) =
                (offset - len) as libc::c_uint
        } else {
            *(*dp).db_index.as_mut_ptr().offset((db_idx + 1 as libc::c_int) as
                                                    isize) =
                (*dp).db_txt_start
        }
        /* if there are following lines */
        /*
       * Offset is the start of the previous line.
       * This will become the character just after the new line.
       */
        /*
     * copy the text into the block
     */
        memmove((dp as
                     *mut libc::c_char).offset(*(*dp).db_index.as_mut_ptr().offset((db_idx
                                                                                        +
                                                                                        1
                                                                                            as
                                                                                            libc::c_int)
                                                                                       as
                                                                                       isize)
                                                   as isize) as
                    *mut libc::c_void, line as *const libc::c_void,
                len as size_t);
        if mark != 0 {
            *(*dp).db_index.as_mut_ptr().offset((db_idx + 1 as libc::c_int) as
                                                    isize) |=
                (1 as libc::c_int as libc::c_uint) <<
                    (::std::mem::size_of::<libc::c_uint>() as
                         libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                         libc::c_ulong).wrapping_sub(1
                                                                                         as
                                                                                         libc::c_int
                                                                                         as
                                                                                         libc::c_ulong)
        }
        /*
     * Mark the block dirty.
     */
        (*buf).b_ml.ml_flags |= ML_LOCKED_DIRTY;
        if !newfile { (*buf).b_ml.ml_flags |= ML_LOCKED_POS }
    } else {
        /*
     * If there is not enough room we have to create a new data block and copy some
     * lines into it.
     * Then we have to insert an entry in the pointer block.
     * If this pointer block also is full, we go up another block, and so on, up
     * to the root if necessary.
     * The line counts in the pointer blocks have already been adjusted by
     * ml_find_line().
     */
        let mut line_count_left: libc::c_long = 0; /* init to shut up gcc */
        let mut line_count_right: libc::c_long = 0; /* init to shut up gcc */
        let mut page_count_left: libc::c_int = 0;
        let mut page_count_right: libc::c_int = 0;
        let mut hp_left = 0 as *mut bhdr_T;
        let mut hp_right = 0 as *mut bhdr_T;
        let mut hp_new = 0 as *mut bhdr_T;
        let mut lines_moved: libc::c_int = 0;
        let mut data_moved = 0 as libc::c_int;
        let mut total_moved = 0 as libc::c_int;
        let mut dp_right = 0 as *mut DATA_BL;
        let mut dp_left = 0 as *mut DATA_BL;
        let mut stack_idx: libc::c_int = 0;
        let mut in_left: libc::c_int = 0;
        let mut lineadd: libc::c_int = 0;
        let mut bnum_left: blocknr_T = 0;
        let mut bnum_right: blocknr_T = 0;
        let mut lnum_left: linenr_T = 0;
        let mut lnum_right: linenr_T = 0;
        let mut pb_idx: libc::c_int = 0;
        let mut pp_new = 0 as *mut PTR_BL;
        /*
     * We are going to allocate a new data block. Depending on the
     * situation it will be put to the left or right of the existing
     * block.  If possible we put the new line in the left block and move
     * the lines after it to the right block. Otherwise the new line is
     * also put in the right block. This method is more efficient when
     * inserting a lot of lines at one place.
     */
        if db_idx < 0 as libc::c_int {
            /* left block is new, right block is existing */
            lines_moved = 0 as libc::c_int;
            in_left = TRUE
            /* space_needed does not change */
        } else {
            lines_moved =
                line_count - db_idx -
                    1 as
                        libc::c_int; /* put new line in right block */
                                        /* space_needed does not change */
            if lines_moved == 0 as libc::c_int {
                in_left = FALSE
            } else {
                data_moved =
                    (*(*dp).db_index.as_mut_ptr().offset(db_idx as isize) &
                         !((1 as libc::c_int as libc::c_uint) <<
                               (::std::mem::size_of::<libc::c_uint>() as
                                    libc::c_ulong).wrapping_mul(8 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong).wrapping_sub(1
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    libc::c_ulong))).wrapping_sub((*dp).db_txt_start)
                        as libc::c_int; /* put new line in left block */
                total_moved =
                    (data_moved as
                         libc::c_ulong).wrapping_add((lines_moved as
                                                          libc::c_ulong).wrapping_mul(INDEX_SIZE))
                        as libc::c_int; /* put new line in right block */
                if (*dp).db_free as libc::c_int + total_moved >= space_needed
                   {
                    in_left = TRUE; /* right block is new */
                    space_needed = total_moved
                } else { in_left = FALSE; space_needed += total_moved }
            }
        }
        page_count =
            (space_needed as
                 libc::c_ulong).wrapping_add((::std::mem::size_of::<DATA_BL>()
                                                  as
                                                  libc::c_ulong).wrapping_sub(INDEX_SIZE)).wrapping_add(page_size
                                                                                                            as
                                                                                                            libc::c_ulong).wrapping_sub(1
                                                                                                                                            as
                                                                                                                                            libc::c_int
                                                                                                                                            as
                                                                                                                                            libc::c_ulong).wrapping_div(page_size
                                                                                                                                                                            as
                                                                                                                                                                            libc::c_ulong)
                as libc::c_int;
        hp_new = ml_new_data(mfp, newfile, page_count);
        if db_idx < 0 as libc::c_int {
            /* left block is new */
            hp_left = hp_new;
            hp_right = hp;
            line_count_left = 0 as libc::c_int as libc::c_long;
            line_count_right = line_count as libc::c_long
        } else {
            hp_left = hp;
            hp_right = hp_new;
            line_count_left = line_count as libc::c_long;
            line_count_right = 0 as libc::c_int as libc::c_long
        }
        dp_right = (*hp_right).bh_data as *mut DATA_BL;
        dp_left = (*hp_left).bh_data as *mut DATA_BL;
        bnum_left = (*hp_left).bh_hashitem.mhi_key;
        bnum_right = (*hp_right).bh_hashitem.mhi_key;
        page_count_left = (*hp_left).bh_page_count as libc::c_int;
        page_count_right = (*hp_right).bh_page_count as libc::c_int;
        /*
     * May move the new line into the right/new block.
     */
        if in_left == 0 {
            (*dp_right).db_txt_start =
                (*dp_right).db_txt_start.wrapping_sub(len as libc::c_uint);
            (*dp_right).db_free =
                ((*dp_right).db_free as
                     libc::c_ulong).wrapping_sub((len as
                                                      libc::c_ulong).wrapping_add(INDEX_SIZE))
                    as libc::c_uint as libc::c_uint;
            *(*dp_right).db_index.as_mut_ptr().offset(0 as libc::c_int as
                                                          isize) =
                (*dp_right).db_txt_start;
            if mark != 0 {
                *(*dp_right).db_index.as_mut_ptr().offset(0 as libc::c_int as
                                                              isize) |=
                    (1 as libc::c_int as libc::c_uint) <<
                        (::std::mem::size_of::<libc::c_uint>() as
                             libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                             libc::c_ulong).wrapping_sub(1
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_ulong)
            }
            memmove((dp_right as
                         *mut libc::c_char).offset((*dp_right).db_txt_start as
                                                       isize) as
                        *mut libc::c_void, line as *const libc::c_void,
                    len as size_t);
            line_count_right += 1
        }
        /*
     * may move lines from the left/old block to the right/new one.
     */
        if lines_moved != 0 {
            /*
       */
            (*dp_right).db_txt_start =
                (*dp_right).db_txt_start.wrapping_sub(data_moved as
                                                          libc::c_uint);
            (*dp_right).db_free =
                (*dp_right).db_free.wrapping_sub(total_moved as libc::c_uint);
            memmove((dp_right as
                         *mut libc::c_char).offset((*dp_right).db_txt_start as
                                                       isize) as
                        *mut libc::c_void,
                    (dp_left as
                         *mut libc::c_char).offset((*dp_left).db_txt_start as
                                                       isize) as
                        *const libc::c_void, data_moved as size_t);
            offset =
                (*dp_right).db_txt_start.wrapping_sub((*dp_left).db_txt_start)
                    as libc::c_int;
            (*dp_left).db_txt_start =
                (*dp_left).db_txt_start.wrapping_add(data_moved as
                                                         libc::c_uint);
            (*dp_left).db_free =
                (*dp_left).db_free.wrapping_add(total_moved as libc::c_uint);
            /*
       * update indexes in the new block
       */
            to = line_count_right as libc::c_int;
            from = db_idx + 1 as libc::c_int;
            while (from as libc::c_long) < line_count_left {
                *(*dp_right).db_index.as_mut_ptr().offset(to as isize) =
                    (*(*dp).db_index.as_mut_ptr().offset(from as
                                                             isize)).wrapping_add(offset
                                                                                      as
                                                                                      libc::c_uint);
                from += 1;
                to += 1
            }
            line_count_right += lines_moved as libc::c_long;
            line_count_left -= lines_moved as libc::c_long
        }
        /*
     * May move the new line into the left (old or new) block.
     */
        if in_left != 0 {
            (*dp_left).db_txt_start =
                (*dp_left).db_txt_start.wrapping_sub(len as
                                                         libc::c_uint); /* right block is new */
            (*dp_left).db_free =
                ((*dp_left).db_free as
                     libc::c_ulong).wrapping_sub((len as
                                                      libc::c_ulong).wrapping_add(INDEX_SIZE))
                    as libc::c_uint as libc::c_uint;
            *(*dp_left).db_index.as_mut_ptr().offset(line_count_left as isize)
                = (*dp_left).db_txt_start;
            if mark != 0 {
                *(*dp_left).db_index.as_mut_ptr().offset(line_count_left as
                                                             isize) |=
                    (1 as libc::c_int as libc::c_uint) <<
                        (::std::mem::size_of::<libc::c_uint>() as
                             libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                             libc::c_ulong).wrapping_sub(1
                                                                                             as
                                                                                             libc::c_int
                                                                                             as
                                                                                             libc::c_ulong)
            }
            memmove((dp_left as
                         *mut libc::c_char).offset((*dp_left).db_txt_start as
                                                       isize) as
                        *mut libc::c_void, line as *const libc::c_void,
                    len as size_t);
            line_count_left += 1
        }
        if db_idx < 0 as libc::c_int {
            /* left block is new */
            lnum_left = lnum + 1 as libc::c_int as libc::c_long;
            lnum_right = 0 as libc::c_int as linenr_T
        } else {
            lnum_left = 0 as libc::c_int as linenr_T;
            if in_left != 0 {
                lnum_right = lnum + 2 as libc::c_int as libc::c_long
            } else { lnum_right = lnum + 1 as libc::c_int as libc::c_long }
        }
        (*dp_left).db_line_count = line_count_left;
        (*dp_right).db_line_count = line_count_right;
        /*
     * release the two data blocks
     * The new one (hp_new) already has a correct blocknumber.
     * The old one (hp, in ml_locked) gets a positive blocknumber if
     * we changed it and we are not editing a new file.
     */
        if lines_moved != 0 || in_left != 0 {
            (*buf).b_ml.ml_flags |= ML_LOCKED_DIRTY
        }
        if !newfile && db_idx >= 0 as libc::c_int && in_left != 0 {
            (*buf).b_ml.ml_flags |= ML_LOCKED_POS
        }
        mf_put(mfp, hp_new, true_0 != 0, false_0 != 0);
        /*
     * flush the old data block
     * set ml_locked_lineadd to 0, because the updating of the
     * pointer blocks is done below
     */
        lineadd = (*buf).b_ml.ml_locked_lineadd; /* flush data block */
        (*buf).b_ml.ml_locked_lineadd = 0 as libc::c_int;
        ml_find_line(buf, 0 as libc::c_int as linenr_T, ML_FLUSH);
        /*
     * update pointer blocks for the new data block
     */
        stack_idx =
            (*buf).b_ml.ml_stack_top -
                1 as libc::c_int; /* must be pointer block */
        while stack_idx >= 0 as libc::c_int {
            ip =
                &mut *(*buf).b_ml.ml_stack.offset(stack_idx as isize) as
                    *mut infoptr_T;
            pb_idx = (*ip).ip_index;
            hp = mf_get(mfp, (*ip).ip_bnum, 1 as libc::c_int as libc::c_uint);
            if hp.is_null() { return FAIL }
            pp = (*hp).bh_data as *mut PTR_BL;
            if (*pp).pb_id as libc::c_int != PTR_ID {
                iemsg(gettext(b"E317: pointer block id wrong 3\x00" as
                                  *const u8 as *const libc::c_char as
                                  *mut libc::c_char) as *const libc::c_char);
                mf_put(mfp, hp, false_0 != 0, false_0 != 0);
                return FAIL
            }
            /*
       * TODO: If the pointer block is full and we are adding at the end
       * try to insert in front of the next block
       */
      /* block not full, add one entry */
            if ((*pp).pb_count as libc::c_int) <
                   (*pp).pb_count_max as libc::c_int {
                if (pb_idx + 1 as libc::c_int) < (*pp).pb_count as libc::c_int
                   {
                    memmove(&mut *(*pp).pb_pointer.as_mut_ptr().offset((pb_idx
                                                                            +
                                                                            2
                                                                                as
                                                                                libc::c_int)
                                                                           as
                                                                           isize)
                                as *mut PTR_EN as *mut libc::c_void,
                            &mut *(*pp).pb_pointer.as_mut_ptr().offset((pb_idx
                                                                            +
                                                                            1
                                                                                as
                                                                                libc::c_int)
                                                                           as
                                                                           isize)
                                as *mut PTR_EN as *const libc::c_void,
                            (((*pp).pb_count as libc::c_int - pb_idx -
                                  1 as libc::c_int) as
                                 size_t).wrapping_mul(::std::mem::size_of::<PTR_EN>()
                                                          as
                                                          libc::c_ulong)); /* pointer block full */
                } /* truncate stack */
                (*pp).pb_count = (*pp).pb_count.wrapping_add(1);
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_line_count
                    = line_count_left;
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_bnum =
                    bnum_left;
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_page_count
                    = page_count_left;
                (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                            1 as libc::c_int)
                                                           as
                                                           isize)).pe_line_count
                    = line_count_right;
                (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                            1 as libc::c_int)
                                                           as isize)).pe_bnum
                    = bnum_right;
                (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                            1 as libc::c_int)
                                                           as
                                                           isize)).pe_page_count
                    = page_count_right;
                if lnum_left != 0 as libc::c_int as libc::c_long {
                    (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                               isize)).pe_old_lnum
                        = lnum_left
                }
                if lnum_right != 0 as libc::c_int as libc::c_long {
                    (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                                1 as
                                                                    libc::c_int)
                                                               as
                                                               isize)).pe_old_lnum
                        = lnum_right
                }
                mf_put(mfp, hp, true_0 != 0, false_0 != 0);
                (*buf).b_ml.ml_stack_top = stack_idx + 1 as libc::c_int;
                if lineadd != 0 {
                    (*buf).b_ml.ml_stack_top -= 1;
                    /* fix line count for rest of blocks in the stack */
                    ml_lineadd(buf, lineadd);
                    /* fix stack itself */
                    let ref mut fresh16 =
                        (*(*buf).b_ml.ml_stack.offset((*buf).b_ml.ml_stack_top
                                                          as isize)).ip_high;
                    *fresh16 += lineadd as libc::c_long;
                    (*buf).b_ml.ml_stack_top += 1
                }
                break ;
            } else {
                loop 
                     /*
         * split the pointer block
         * allocate a new pointer block
         * move some of the pointer into the new block
         * prepare for updating the parent block
         */
                     /* do this twice when splitting block 1 */
                     {
                    hp_new = ml_new_ptr(mfp);
                    if hp_new.is_null() {
                        /* TODO: try to fix tree */
                        return FAIL
                    }
                    pp_new = (*hp_new).bh_data as *mut PTR_BL;
                    if (*hp).bh_hashitem.mhi_key !=
                           1 as libc::c_int as libc::c_long {
                        break ;
                    }
                    /*
           * if block 1 becomes full the tree is given an extra level
           * The pointers from block 1 are moved into the new block.
           * block 1 is updated to point to the new block
           * then continue to split the new block
           */
                    memmove(pp_new as *mut libc::c_void,
                            pp as *const libc::c_void,
                            page_size as size_t); /* release block 1 */
                    (*pp).pb_count =
                        1 as libc::c_int as
                            uint16_t; /* new block is to be split */
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_bnum
                        = (*hp_new).bh_hashitem.mhi_key;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_line_count
                        = (*buf).b_ml.ml_line_count;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_old_lnum
                        = 1 as libc::c_int as linenr_T;
                    (*(*pp).pb_pointer.as_mut_ptr().offset(0 as libc::c_int as
                                                               isize)).pe_page_count
                        = 1 as libc::c_int;
                    mf_put(mfp, hp, true_0 != 0, false_0 != 0);
                    hp = hp_new;
                    pp = pp_new;
                    (*ip).ip_index = 0 as libc::c_int;
                    stack_idx += 1
                }
                /*
         * move the pointers after the current one to the new block
         * If there are none, the new entry will be in the new block.
         */
                total_moved =
                    (*pp).pb_count as libc::c_int - pb_idx - 1 as libc::c_int;
                if total_moved != 0 {
                    memmove(&mut *(*pp_new).pb_pointer.as_mut_ptr().offset(0
                                                                               as
                                                                               libc::c_int
                                                                               as
                                                                               isize)
                                as *mut PTR_EN as *mut libc::c_void,
                            &mut *(*pp).pb_pointer.as_mut_ptr().offset((pb_idx
                                                                            +
                                                                            1
                                                                                as
                                                                                libc::c_int)
                                                                           as
                                                                           isize)
                                as *mut PTR_EN as *const libc::c_void,
                            (total_moved as
                                 size_t).wrapping_mul(::std::mem::size_of::<PTR_EN>()
                                                          as libc::c_ulong));
                    (*pp_new).pb_count = total_moved as uint16_t;
                    (*pp).pb_count =
                        ((*pp).pb_count as libc::c_int -
                             (total_moved - 1 as libc::c_int)) as uint16_t;
                    (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                                1 as
                                                                    libc::c_int)
                                                               as
                                                               isize)).pe_bnum
                        = bnum_right;
                    (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                                1 as
                                                                    libc::c_int)
                                                               as
                                                               isize)).pe_line_count
                        = line_count_right;
                    (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                                1 as
                                                                    libc::c_int)
                                                               as
                                                               isize)).pe_page_count
                        = page_count_right;
                    if lnum_right != 0 {
                        (*(*pp).pb_pointer.as_mut_ptr().offset((pb_idx +
                                                                    1 as
                                                                        libc::c_int)
                                                                   as
                                                                   isize)).pe_old_lnum
                            = lnum_right
                    }
                } else {
                    (*pp_new).pb_count = 1 as libc::c_int as uint16_t;
                    (*(*pp_new).pb_pointer.as_mut_ptr().offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).pe_bnum
                        = bnum_right;
                    (*(*pp_new).pb_pointer.as_mut_ptr().offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).pe_line_count
                        = line_count_right;
                    (*(*pp_new).pb_pointer.as_mut_ptr().offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).pe_page_count
                        = page_count_right;
                    (*(*pp_new).pb_pointer.as_mut_ptr().offset(0 as
                                                                   libc::c_int
                                                                   as
                                                                   isize)).pe_old_lnum
                        = lnum_right
                }
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_bnum =
                    bnum_left;
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_line_count
                    = line_count_left;
                (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                           isize)).pe_page_count
                    = page_count_left;
                if lnum_left != 0 {
                    (*(*pp).pb_pointer.as_mut_ptr().offset(pb_idx as
                                                               isize)).pe_old_lnum
                        = lnum_left
                }
                lnum_left = 0 as libc::c_int as linenr_T;
                lnum_right = 0 as libc::c_int as linenr_T;
                /*
         * recompute line counts
         */
                line_count_right = 0 as libc::c_int as libc::c_long;
                i = 0 as libc::c_int;
                while i < (*pp_new).pb_count as libc::c_int {
                    line_count_right +=
                        (*(*pp_new).pb_pointer.as_mut_ptr().offset(i as
                                                                       isize)).pe_line_count;
                    i += 1
                }
                line_count_left = 0 as libc::c_int as libc::c_long;
                i = 0 as libc::c_int;
                while i < (*pp).pb_count as libc::c_int {
                    line_count_left +=
                        (*(*pp).pb_pointer.as_mut_ptr().offset(i as
                                                                   isize)).pe_line_count;
                    i += 1
                }
                bnum_left = (*hp).bh_hashitem.mhi_key;
                bnum_right = (*hp_new).bh_hashitem.mhi_key;
                page_count_left = 1 as libc::c_int;
                page_count_right = 1 as libc::c_int;
                mf_put(mfp, hp, true_0 != 0, false_0 != 0);
                mf_put(mfp, hp_new, true_0 != 0, false_0 != 0);
                stack_idx -= 1
            }
        }
        /*
     * Safety check: fallen out of for loop?
     */
        if stack_idx < 0 as libc::c_int {
            iemsg(gettext(b"E318: Updated too many blocks?\x00" as *const u8
                              as *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char);
            (*buf).b_ml.ml_stack_top = 0 as libc::c_int
            // invalidate stack
        }
    }
    /* The line was inserted below 'lnum' */
    ml_updatechunk(buf, lnum + 1 as libc::c_int as libc::c_long,
                   len as libc::c_long, ML_CHNK_ADDLINE); // NL char
    return OK;
}
#[no_mangle]
#[c2rust::src_loc = "2395:1"]
pub unsafe extern "C" fn ml_add_deleted_len(mut ptr: *mut char_u,
                                            mut len: ssize_t) {
    if inhibit_delete_count != 0 { return }
    if len == -(1 as libc::c_int) as libc::c_long {
        len = strlen(ptr as *mut libc::c_char) as ssize_t
    }
    (*curbuf).deleted_bytes =
        ((*curbuf).deleted_bytes as
             libc::c_ulong).wrapping_add((len +
                                              1 as libc::c_int as
                                                  libc::c_long) as
                                             libc::c_ulong) as size_t as
            size_t;
    if (*curbuf).update_need_codepoints {
        mb_utflen(ptr, len as size_t, &mut (*curbuf).deleted_codepoints,
                  &mut (*curbuf).deleted_codeunits);
        (*curbuf).deleted_codepoints =
            (*curbuf).deleted_codepoints.wrapping_add(1);
        (*curbuf).deleted_codeunits =
            (*curbuf).deleted_codeunits.wrapping_add(1)
    };
}
/*
 * Replace line lnum, with buffering, in current buffer.
 *
 * If "copy" is TRUE, make a copy of the line, otherwise the line has been
 * copied to allocated memory already.
 *
 * Check: The caller of this function should probably also call
 * changed_lines(), unless update_screen(NOT_VALID) is used.
 *
 * return FAIL for failure, OK otherwise
 */
#[no_mangle]
#[c2rust::src_loc = "2423:1"]
pub unsafe extern "C" fn ml_replace(mut lnum: linenr_T, mut line: *mut char_u,
                                    mut copy: bool) -> libc::c_int {
    if line.is_null() {
        /* just checking... */
        return FAIL
    }
    /* When starting up, we might still need to create the memfile */
    if (*curbuf).b_ml.ml_mfp.is_null() &&
           open_buffer(FALSE, NULL_1 as *mut exarg_T, 0 as libc::c_int) ==
               FAIL {
        return FAIL
    }
    let mut readlen = true_0 != 0;
    if copy { line = vim_strsave(line) }
    if (*curbuf).b_ml.ml_line_lnum != lnum {
        // other line buffered
        ml_flush_line(curbuf);
        // flush it
    } else if (*curbuf).b_ml.ml_flags & ML_LINE_DIRTY != 0 {
        // same line allocated
        ml_add_deleted_len((*curbuf).b_ml.ml_line_ptr,
                           -(1 as libc::c_int) as ssize_t);
        // free it
        readlen = false_0 != 0; // already added the length
        xfree((*curbuf).b_ml.ml_line_ptr as *mut libc::c_void);
    }
    if readlen as libc::c_int != 0 && (*curbuf).update_callbacks.size != 0 {
        ml_add_deleted_len(ml_get_buf(curbuf, lnum, false_0 != 0),
                           -(1 as libc::c_int) as ssize_t);
    }
    (*curbuf).b_ml.ml_line_ptr = line;
    (*curbuf).b_ml.ml_line_lnum = lnum;
    (*curbuf).b_ml.ml_flags =
        ((*curbuf).b_ml.ml_flags | ML_LINE_DIRTY) & !ML_EMPTY;
    return OK;
}
// / Delete line `lnum` in the current buffer.
// /
// / @note The caller of this function should probably also call
// / deleted_lines() after this.
// /
// / @param message  Show "--No lines in buffer--" message.
// / @return FAIL for failure, OK otherwise
#[no_mangle]
#[c2rust::src_loc = "2464:1"]
pub unsafe extern "C" fn ml_delete(mut lnum: linenr_T, mut message: bool)
 -> libc::c_int {
    ml_flush_line(curbuf); /* number of entries in block */
    return ml_delete_int(curbuf, lnum, message);
}
#[c2rust::src_loc = "2470:1"]
unsafe extern "C" fn ml_delete_int(mut buf: *mut buf_T, mut lnum: linenr_T,
                                   mut message: bool) -> libc::c_int {
    let mut hp = 0 as *mut bhdr_T;
    let mut mfp = 0 as *mut memfile_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut pp = 0 as *mut PTR_BL;
    let mut ip = 0 as *mut infoptr_T;
    let mut count: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut stack_idx: libc::c_int = 0;
    let mut text_start: libc::c_int = 0;
    let mut line_start: libc::c_int = 0;
    let mut line_size: libc::c_long = 0;
    let mut i: libc::c_int = 0;
    if lnum < 1 as libc::c_int as libc::c_long ||
           lnum > (*buf).b_ml.ml_line_count {
        return FAIL
    }
    if lowest_marked != 0 && lowest_marked > lnum { lowest_marked -= 1 }
    /*
   * If the file becomes empty the last line is replaced by an empty line.
   */
    if (*buf).b_ml.ml_line_count == 1 as libc::c_int as libc::c_long {
        /* file becomes empty */
        if message {
            set_keep_msg(gettext(no_lines_msg.as_mut_ptr() as
                                     *mut libc::c_char) as *mut char_u,
                         0 as libc::c_int);
        }
        i =
            ml_replace(1 as libc::c_int as linenr_T,
                       b"\x00" as *const u8 as *const libc::c_char as
                           *mut char_u, true_0 != 0);
        (*buf).b_ml.ml_flags |= ML_EMPTY;
        return i
    }
    /*
   * find the data block containing the line
   * This also fills the stack with the blocks from the root to the data block
   * This also releases any locked block.
   */
    mfp = (*buf).b_ml.ml_mfp;
    if mfp.is_null() { return FAIL }
    hp = ml_find_line(buf, lnum, ML_DELETE);
    if hp.is_null() { return FAIL }
    dp = (*hp).bh_data as *mut DATA_BL;
    /* compute line count before the delete */
    count =
        ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low +
             2 as libc::c_int as libc::c_long) as libc::c_int;
    idx = (lnum - (*buf).b_ml.ml_locked_low) as libc::c_int;
    (*buf).b_ml.ml_line_count -= 1;
    line_start =
        (*(*dp).db_index.as_mut_ptr().offset(idx as isize) &
             !((1 as libc::c_int as libc::c_uint) <<
                   (::std::mem::size_of::<libc::c_uint>() as
                        libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                        libc::c_ulong).wrapping_sub(1
                                                                                        as
                                                                                        libc::c_int
                                                                                        as
                                                                                        libc::c_ulong)))
            as libc::c_int;
    if idx == 0 as libc::c_int {
        /* first line in block, text at the end */
        line_size =
            (*dp).db_txt_end.wrapping_sub(line_start as libc::c_uint) as
                libc::c_long
    } else {
        line_size =
            (*(*dp).db_index.as_mut_ptr().offset((idx - 1 as libc::c_int) as
                                                     isize) &
                 !((1 as libc::c_int as libc::c_uint) <<
                       (::std::mem::size_of::<libc::c_uint>() as
                            libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                            libc::c_ulong).wrapping_sub(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_ulong))).wrapping_sub(line_start
                                                                                                                              as
                                                                                                                              libc::c_uint)
                as libc::c_long
    }
    // Line should always have an NL char internally (represented as NUL),
  // even if 'noeol' is set.
    if line_size >= 1 as libc::c_int as libc::c_long {
    } else {
        __assert_fail(b"line_size >= 1\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/vole/neovim/src/nvim/memline.c\x00" as *const u8
                          as *const libc::c_char,
                      2533 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 44],
                                                &[libc::c_char; 44]>(b"int ml_delete_int(buf_T *, linenr_T, _Bool)\x00")).as_ptr());
    }
    ml_add_deleted_len((dp as *mut char_u).offset(line_start as isize),
                       line_size - 1 as libc::c_int as libc::c_long);
    /*
   * special case: If there is only one line in the data block it becomes empty.
   * Then we have to remove the entry, pointing to this data block, from the
   * pointer block. If this pointer block also becomes empty, we go up another
   * block, and so on, up to the root if necessary.
   * The line counts in the pointer blocks have already been adjusted by
   * ml_find_line().
   */
    if count == 1 as libc::c_int {
        mf_free(mfp, hp); /* free the data block */
        (*buf).b_ml.ml_locked =
            NULL_1 as *mut bhdr_T; /* stack is invalid when failing */
        stack_idx =
            (*buf).b_ml.ml_stack_top -
                1 as libc::c_int; /* must be pointer block */
        while stack_idx >= 0 as libc::c_int {
            (*buf).b_ml.ml_stack_top = 0 as libc::c_int;
            ip =
                &mut *(*buf).b_ml.ml_stack.offset(stack_idx as isize) as
                    *mut infoptr_T;
            idx = (*ip).ip_index;
            hp = mf_get(mfp, (*ip).ip_bnum, 1 as libc::c_int as libc::c_uint);
            if hp.is_null() { return FAIL }
            pp = (*hp).bh_data as *mut PTR_BL;
            if (*pp).pb_id as libc::c_int != PTR_ID {
                iemsg(gettext(b"E317: pointer block id wrong 4\x00" as
                                  *const u8 as *const libc::c_char as
                                  *mut libc::c_char) as *const libc::c_char);
                mf_put(mfp, hp, false_0 != 0, false_0 != 0);
                return FAIL
            }
            (*pp).pb_count = (*pp).pb_count.wrapping_sub(1);
            count = (*pp).pb_count as libc::c_int;
            if count == 0 as libc::c_int {
                /* the pointer block becomes empty! */
                mf_free(mfp, hp);
                stack_idx -= 1
            } else {
                if count != idx {
                    /* move entries after the deleted one */
                    memmove(&mut *(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                           isize)
                                as *mut PTR_EN as *mut libc::c_void,
                            &mut *(*pp).pb_pointer.as_mut_ptr().offset((idx +
                                                                            1
                                                                                as
                                                                                libc::c_int)
                                                                           as
                                                                           isize)
                                as *mut PTR_EN as *const libc::c_void,
                            ((count - idx) as
                                 size_t).wrapping_mul(::std::mem::size_of::<PTR_EN>()
                                                          as
                                                          libc::c_ulong)); /* truncate stack */
                }
                mf_put(mfp, hp, true_0 != 0, false_0 != 0);
                (*buf).b_ml.ml_stack_top = stack_idx;
                /* fix line count for rest of blocks in the stack */
                if (*buf).b_ml.ml_locked_lineadd != 0 as libc::c_int {
                    ml_lineadd(buf, (*buf).b_ml.ml_locked_lineadd);
                    let ref mut fresh17 =
                        (*(*buf).b_ml.ml_stack.offset((*buf).b_ml.ml_stack_top
                                                          as isize)).ip_high;
                    *fresh17 += (*buf).b_ml.ml_locked_lineadd as libc::c_long
                }
                (*buf).b_ml.ml_stack_top += 1;
                break ;
            }
        }
    } else {
        /*
     * delete the text by moving the next lines forwards
     */
        text_start = (*dp).db_txt_start as libc::c_int;
        memmove((dp as
                     *mut libc::c_char).offset(text_start as
                                                   isize).offset(line_size as
                                                                     isize) as
                    *mut libc::c_void,
                (dp as *mut libc::c_char).offset(text_start as isize) as
                    *const libc::c_void, (line_start - text_start) as size_t);
        /*
     * delete the index by moving the next indexes backwards
     * Adjust the indexes for the text movement.
     */
        i = idx;
        while i < count - 1 as libc::c_int {
            *(*dp).db_index.as_mut_ptr().offset(i as isize) =
                (*(*dp).db_index.as_mut_ptr().offset((i + 1 as libc::c_int) as
                                                         isize) as
                     libc::c_long + line_size) as libc::c_uint;
            i += 1
        }
        (*dp).db_free =
            ((*dp).db_free as
                 libc::c_ulong).wrapping_add((line_size as
                                                  libc::c_ulong).wrapping_add(INDEX_SIZE))
                as libc::c_uint as libc::c_uint;
        (*dp).db_txt_start =
            ((*dp).db_txt_start as libc::c_long + line_size) as libc::c_uint;
        (*dp).db_line_count -= 1;
        /*
     * mark the block dirty and make sure it is in the file (for recovery)
     */
        (*buf).b_ml.ml_flags |= ML_LOCKED_DIRTY | ML_LOCKED_POS
    }
    ml_updatechunk(buf, lnum, line_size, ML_CHNK_DELLINE);
    return OK;
}
/*
 * set the B_MARKED flag for line 'lnum'
 */
#[no_mangle]
#[c2rust::src_loc = "2615:1"]
pub unsafe extern "C" fn ml_setmarked(mut lnum: linenr_T) {
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    /* invalid line number */
    if lnum < 1 as libc::c_int as libc::c_long ||
           lnum > (*curbuf).b_ml.ml_line_count ||
           (*curbuf).b_ml.ml_mfp.is_null() {
        return
    } /* give error message? */
    if lowest_marked == 0 as libc::c_int as libc::c_long ||
           lowest_marked > lnum {
        lowest_marked = lnum
    }
    /*
   * find the data block containing the line
   * This also fills the stack with the blocks from the root to the data block
   * This also releases any locked block.
   */
    hp = ml_find_line(curbuf, lnum, ML_FIND); /* give error message? */
    if hp.is_null() { return }
    dp = (*hp).bh_data as *mut DATA_BL;
    *(*dp).db_index.as_mut_ptr().offset((lnum - (*curbuf).b_ml.ml_locked_low)
                                            as isize) |=
        (1 as libc::c_int as libc::c_uint) <<
            (::std::mem::size_of::<libc::c_uint>() as
                 libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                 libc::c_ulong).wrapping_sub(1
                                                                                 as
                                                                                 libc::c_int
                                                                                 as
                                                                                 libc::c_ulong);
    (*curbuf).b_ml.ml_flags |= ML_LOCKED_DIRTY;
}
/*
 * find the first line with its B_MARKED flag set
 */
#[no_mangle]
#[c2rust::src_loc = "2643:1"]
pub unsafe extern "C" fn ml_firstmarked() -> linenr_T {
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut lnum: linenr_T = 0;
    let mut i: libc::c_int = 0;
    if (*curbuf).b_ml.ml_mfp.is_null() { return 0 as libc::c_int as linenr_T }
    /*
   * The search starts with lowest_marked line. This is the last line where
   * a mark was found, adjusted by inserting/deleting lines.
   */
    lnum = lowest_marked;
    while lnum <= (*curbuf).b_ml.ml_line_count {
        /*
     * Find the data block containing the line.
     * This also fills the stack with the blocks from the root to the data
     * block This also releases any locked block.
     */
        hp = ml_find_line(curbuf, lnum, ML_FIND); /* give error message? */
        if hp.is_null() { return 0 as libc::c_int as linenr_T }
        dp = (*hp).bh_data as *mut DATA_BL;
        i = (lnum - (*curbuf).b_ml.ml_locked_low) as libc::c_int;
        while lnum <= (*curbuf).b_ml.ml_locked_high {
            if *(*dp).db_index.as_mut_ptr().offset(i as isize) &
                   (1 as libc::c_int as libc::c_uint) <<
                       (::std::mem::size_of::<libc::c_uint>() as
                            libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                            libc::c_ulong).wrapping_sub(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_ulong)
                   != 0 {
                *(*dp).db_index.as_mut_ptr().offset(i as isize) &=
                    !((1 as libc::c_int as libc::c_uint) <<
                          (::std::mem::size_of::<libc::c_uint>() as
                               libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                               libc::c_ulong).wrapping_sub(1
                                                                                               as
                                                                                               libc::c_int
                                                                                               as
                                                                                               libc::c_ulong));
                (*curbuf).b_ml.ml_flags |= ML_LOCKED_DIRTY;
                lowest_marked = lnum + 1 as libc::c_int as libc::c_long;
                return lnum
            }
            i += 1;
            lnum += 1
        }
    }
    return 0 as libc::c_int as linenr_T;
}
/*
 * clear all DB_MARKED flags
 */
#[no_mangle]
#[c2rust::src_loc = "2684:1"]
pub unsafe extern "C" fn ml_clearmarked() {
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut lnum: linenr_T = 0;
    let mut i: libc::c_int = 0;
    if (*curbuf).b_ml.ml_mfp.is_null() {
        /* nothing to do */
        return
    }
    /*
   * The search starts with line lowest_marked.
   */
    lnum = lowest_marked;
    while lnum <= (*curbuf).b_ml.ml_line_count {
        /*
     * Find the data block containing the line.
     * This also fills the stack with the blocks from the root to the data
     * block and releases any locked block.
     */
        hp = ml_find_line(curbuf, lnum, ML_FIND); /* give error message? */
        if hp.is_null() { return }
        dp = (*hp).bh_data as *mut DATA_BL;
        i = (lnum - (*curbuf).b_ml.ml_locked_low) as libc::c_int;
        while lnum <= (*curbuf).b_ml.ml_locked_high {
            if *(*dp).db_index.as_mut_ptr().offset(i as isize) &
                   (1 as libc::c_int as libc::c_uint) <<
                       (::std::mem::size_of::<libc::c_uint>() as
                            libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                            libc::c_ulong).wrapping_sub(1
                                                                                            as
                                                                                            libc::c_int
                                                                                            as
                                                                                            libc::c_ulong)
                   != 0 {
                *(*dp).db_index.as_mut_ptr().offset(i as isize) &=
                    !((1 as libc::c_int as libc::c_uint) <<
                          (::std::mem::size_of::<libc::c_uint>() as
                               libc::c_ulong).wrapping_mul(8 as libc::c_int as
                                                               libc::c_ulong).wrapping_sub(1
                                                                                               as
                                                                                               libc::c_int
                                                                                               as
                                                                                               libc::c_ulong));
                (*curbuf).b_ml.ml_flags |= ML_LOCKED_DIRTY
            }
            i += 1;
            lnum += 1
        }
    }
    lowest_marked = 0 as libc::c_int as linenr_T;
}
#[no_mangle]
#[c2rust::src_loc = "2720:1"]
pub unsafe extern "C" fn ml_flush_deleted_bytes(mut buf: *mut buf_T,
                                                mut codepoints: *mut size_t,
                                                mut codeunits: *mut size_t)
 -> size_t {
    let mut ret = (*buf).deleted_bytes;
    *codepoints = (*buf).deleted_codepoints;
    *codeunits = (*buf).deleted_codeunits;
    (*buf).deleted_bytes = 0 as libc::c_int as size_t;
    (*buf).deleted_codepoints = 0 as libc::c_int as size_t;
    (*buf).deleted_codeunits = 0 as libc::c_int as size_t;
    return ret;
}
/*
 * flush ml_line if necessary
 */
#[c2rust::src_loc = "2734:1"]
unsafe extern "C" fn ml_flush_line(mut buf: *mut buf_T) {
    let mut hp = 0 as *mut bhdr_T; /* nothing to do */
    let mut dp = 0 as *mut DATA_BL;
    let mut lnum: linenr_T = 0;
    let mut new_line = 0 as *mut char_u;
    let mut old_line = 0 as *mut char_u;
    let mut new_len: colnr_T = 0;
    let mut old_len: libc::c_int = 0;
    let mut extra: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut start: libc::c_int = 0;
    let mut count: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    static mut entered: libc::c_int = FALSE;
    if (*buf).b_ml.ml_line_lnum == 0 as libc::c_int as libc::c_long ||
           (*buf).b_ml.ml_mfp.is_null() {
        return
    }
    if (*buf).b_ml.ml_flags & ML_LINE_DIRTY != 0 {
        /* This code doesn't work recursively. */
        if entered != 0 { return }
        entered = TRUE;
        (*buf).flush_count += 1;
        lnum = (*buf).b_ml.ml_line_lnum;
        new_line = (*buf).b_ml.ml_line_ptr;
        hp = ml_find_line(buf, lnum, ML_FIND);
        if hp.is_null() {
            iemsgf(gettext(b"E320: Cannot find line %ld\x00" as *const u8 as
                               *const libc::c_char as *mut libc::c_char) as
                       *const libc::c_char, lnum);
        } else {
            dp = (*hp).bh_data as *mut DATA_BL;
            idx = (lnum - (*buf).b_ml.ml_locked_low) as libc::c_int;
            start =
                (*(*dp).db_index.as_mut_ptr().offset(idx as isize) &
                     !((1 as libc::c_int as libc::c_uint) <<
                           (::std::mem::size_of::<libc::c_uint>() as
                                libc::c_ulong).wrapping_mul(8 as libc::c_int
                                                                as
                                                                libc::c_ulong).wrapping_sub(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_ulong)))
                    as libc::c_int;
            old_line = (dp as *mut char_u).offset(start as isize);
            if idx == 0 as libc::c_int {
                /* line is last in block */
                old_len =
                    (*dp).db_txt_end.wrapping_sub(start as libc::c_uint) as
                        libc::c_int
            } else {
                /* text of previous line follows */
                old_len =
                    (*(*dp).db_index.as_mut_ptr().offset((idx -
                                                              1 as
                                                                  libc::c_int)
                                                             as isize) &
                         !((1 as libc::c_int as libc::c_uint) <<
                               (::std::mem::size_of::<libc::c_uint>() as
                                    libc::c_ulong).wrapping_mul(8 as
                                                                    libc::c_int
                                                                    as
                                                                    libc::c_ulong).wrapping_sub(1
                                                                                                    as
                                                                                                    libc::c_int
                                                                                                    as
                                                                                                    libc::c_ulong))).wrapping_sub(start
                                                                                                                                      as
                                                                                                                                      libc::c_uint)
                        as libc::c_int
            } /* negative if lines gets smaller */
            new_len =
                strlen(new_line as *mut libc::c_char) as colnr_T +
                    1 as libc::c_int;
            extra = new_len - old_len;
            /*
       * if new line fits in data block, replace directly
       */
            if (*dp).db_free as libc::c_int >= extra {
                /* if the length changes and there are following lines */
                count =
                    ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low +
                         1 as libc::c_int as libc::c_long) as libc::c_int;
                if extra != 0 as libc::c_int && idx < count - 1 as libc::c_int
                   {
                    /* move text of following lines */
                    memmove((dp as
                                 *mut libc::c_char).offset((*dp).db_txt_start
                                                               as
                                                               isize).offset(-(extra
                                                                                   as
                                                                                   isize))
                                as *mut libc::c_void,
                            (dp as
                                 *mut libc::c_char).offset((*dp).db_txt_start
                                                               as isize) as
                                *const libc::c_void,
                            (start as
                                 libc::c_uint).wrapping_sub((*dp).db_txt_start)
                                as size_t);
                    /* adjust pointers of this and following lines */
                    i = idx + 1 as libc::c_int;
                    while i < count {
                        let ref mut fresh18 =
                            *(*dp).db_index.as_mut_ptr().offset(i as isize);
                        *fresh18 =
                            (*fresh18).wrapping_sub(extra as libc::c_uint);
                        i += 1
                    }
                }
                let ref mut fresh19 =
                    *(*dp).db_index.as_mut_ptr().offset(idx as isize);
                *fresh19 = (*fresh19).wrapping_sub(extra as libc::c_uint);
                /* adjust free space */
                (*dp).db_free =
                    (*dp).db_free.wrapping_sub(extra as libc::c_uint);
                (*dp).db_txt_start =
                    (*dp).db_txt_start.wrapping_sub(extra as libc::c_uint);
                /* copy new line into the data block */
                memmove(old_line.offset(-(extra as isize)) as
                            *mut libc::c_void,
                        new_line as *const libc::c_void, new_len as size_t);
                (*buf).b_ml.ml_flags |= ML_LOCKED_DIRTY | ML_LOCKED_POS;
                /* The else case is already covered by the insert and delete */
                ml_updatechunk(buf, lnum, extra as libc::c_long,
                               ML_CHNK_UPDLINE);
            } else {
                // Cannot do it in one data block: Delete and append.
        // Append first, because ml_delete_int() cannot delete the
        // last line in a buffer, which causes trouble for a buffer
        // that has only one line.
        // Don't forget to copy the mark!
        // How about handling errors???
                ml_append_int(buf, lnum, new_line, new_len, false_0 != 0,
                              (*(*dp).db_index.as_mut_ptr().offset(idx as
                                                                       isize)
                                   &
                                   (1 as libc::c_int as libc::c_uint) <<
                                       (::std::mem::size_of::<libc::c_uint>()
                                            as
                                            libc::c_ulong).wrapping_mul(8 as
                                                                            libc::c_int
                                                                            as
                                                                            libc::c_ulong).wrapping_sub(1
                                                                                                            as
                                                                                                            libc::c_int
                                                                                                            as
                                                                                                            libc::c_ulong))
                                  as libc::c_int);
                ml_delete_int(buf, lnum, false_0 != 0);
            }
        }
        xfree(new_line as *mut libc::c_void);
        entered = FALSE
    }
    (*buf).b_ml.ml_line_lnum = 0 as libc::c_int as linenr_T;
}
/*
 * create a new, empty, data block
 */
#[c2rust::src_loc = "2829:1"]
unsafe extern "C" fn ml_new_data(mut mfp: *mut memfile_T, mut negative: bool,
                                 mut page_count: libc::c_int) -> *mut bhdr_T {
    if page_count >= 0 as libc::c_int {
    } else {
        __assert_fail(b"page_count >= 0\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/vole/neovim/src/nvim/memline.c\x00" as *const u8
                          as *const libc::c_char,
                      2831 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 45],
                                                &[libc::c_char; 45]>(b"bhdr_T *ml_new_data(memfile_T *, _Bool, int)\x00")).as_ptr());
    }
    let mut hp = mf_new(mfp, negative, page_count as libc::c_uint);
    let mut dp = (*hp).bh_data as *mut DATA_BL;
    (*dp).db_id = DATA_ID as uint16_t;
    (*dp).db_txt_end =
        (page_count as libc::c_uint).wrapping_mul((*mfp).mf_page_size);
    (*dp).db_txt_start = (*dp).db_txt_end;
    (*dp).db_free =
        ((*dp).db_txt_start as
             libc::c_ulong).wrapping_sub((::std::mem::size_of::<DATA_BL>() as
                                              libc::c_ulong).wrapping_sub(INDEX_SIZE))
            as libc::c_uint;
    (*dp).db_line_count = 0 as libc::c_int as linenr_T;
    return hp;
}
/*
 * create a new, empty, pointer block
 */
#[c2rust::src_loc = "2845:1"]
unsafe extern "C" fn ml_new_ptr(mut mfp: *mut memfile_T) -> *mut bhdr_T {
    let mut hp = mf_new(mfp, false_0 != 0, 1 as libc::c_int as libc::c_uint);
    let mut pp = (*hp).bh_data as *mut PTR_BL;
    (*pp).pb_id = PTR_ID as uint16_t;
    (*pp).pb_count = 0 as libc::c_int as uint16_t;
    (*pp).pb_count_max =
        ((*mfp).mf_page_size as
             libc::c_ulong).wrapping_sub(::std::mem::size_of::<PTR_BL>() as
                                             libc::c_ulong).wrapping_div(::std::mem::size_of::<PTR_EN>()
                                                                             as
                                                                             libc::c_ulong).wrapping_add(1
                                                                                                             as
                                                                                                             libc::c_int
                                                                                                             as
                                                                                                             libc::c_ulong)
            as uint16_t;
    return hp;
}
/*
 * lookup line 'lnum' in a memline
 *
 *   action: if ML_DELETE or ML_INSERT the line count is updated while searching
 *	     if ML_FLUSH only flush a locked block
 *	     if ML_FIND just find the line
 *
 * If the block was found it is locked and put in ml_locked.
 * The stack is updated to lead to the locked block. The ip_high field in
 * the stack is updated to reflect the last line in the block AFTER the
 * insert or delete, also if the pointer block has not been updated yet. But
 * if ml_locked != NULL ml_locked_lineadd must be added to ip_high.
 *
 * return: NULL for failure, pointer to block header otherwise
 */
#[c2rust::src_loc = "2871:1"]
unsafe extern "C" fn ml_find_line(mut buf: *mut buf_T, mut lnum: linenr_T,
                                  mut action: libc::c_int) -> *mut bhdr_T {
    let mut current_block: u64;
    let mut dp = 0 as *mut DATA_BL;
    let mut pp = 0 as *mut PTR_BL;
    let mut ip = 0 as *mut infoptr_T;
    let mut hp = 0 as *mut bhdr_T;
    let mut mfp = 0 as *mut memfile_T;
    let mut t: linenr_T = 0;
    let mut bnum: blocknr_T = 0;
    let mut bnum2: blocknr_T = 0;
    let mut dirty: libc::c_int = 0;
    let mut low: linenr_T = 0;
    let mut high: linenr_T = 0;
    let mut top: libc::c_int = 0;
    let mut page_count: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    mfp = (*buf).b_ml.ml_mfp;
    /*
   * If there is a locked block check if the wanted line is in it.
   * If not, flush and release the locked block.
   * Don't do this for ML_INSERT_SAME, because the stack need to be updated.
   * Don't do this for ML_FLUSH, because we want to flush the locked block.
   * Don't do this when 'swapfile' is reset, we want to load all the blocks.
   */
    if !(*buf).b_ml.ml_locked.is_null() {
        if action & 0x10 as libc::c_int != 0 &&
               (*buf).b_ml.ml_locked_low <= lnum &&
               (*buf).b_ml.ml_locked_high >= lnum {
            // remember to update pointer blocks and stack later
            if action == ML_INSERT {
                (*buf).b_ml.ml_locked_lineadd += 1;
                (*buf).b_ml.ml_locked_high += 1
            } else if action == ML_DELETE {
                (*buf).b_ml.ml_locked_lineadd -= 1;
                (*buf).b_ml.ml_locked_high -= 1
            }
            return (*buf).b_ml.ml_locked
        }
        mf_put(mfp, (*buf).b_ml.ml_locked,
               (*buf).b_ml.ml_flags & ML_LOCKED_DIRTY != 0,
               (*buf).b_ml.ml_flags & ML_LOCKED_POS != 0);
        (*buf).b_ml.ml_locked = NULL_1 as *mut bhdr_T;
        /*
     * If lines have been added or deleted in the locked block, need to
     * update the line count in pointer blocks.
     */
        if (*buf).b_ml.ml_locked_lineadd != 0 as libc::c_int {
            ml_lineadd(buf, (*buf).b_ml.ml_locked_lineadd);
        }
    }
    if action == ML_FLUSH {
        /* nothing else to do */
        return NULL_1 as *mut bhdr_T
    } /* start at the root of the tree */
    bnum = 1 as libc::c_int as blocknr_T; /* start at the root */
    page_count = 1 as libc::c_int;
    low = 1 as libc::c_int as linenr_T;
    high = (*buf).b_ml.ml_line_count;
    if action == ML_FIND {
        /* first try stack entries */
        top =
            (*buf).b_ml.ml_stack_top -
                1 as libc::c_int; /* truncate stack at prev entry */
        while top >= 0 as libc::c_int {
            ip =
                &mut *(*buf).b_ml.ml_stack.offset(top as isize) as
                    *mut infoptr_T;
            if (*ip).ip_low <= lnum && (*ip).ip_high >= lnum {
                bnum = (*ip).ip_bnum;
                low = (*ip).ip_low;
                high = (*ip).ip_high;
                (*buf).b_ml.ml_stack_top = top;
                break ;
            } else { top -= 1 }
        }
        if top < 0 as libc::c_int {
            (*buf).b_ml.ml_stack_top = 0 as libc::c_int
        }
        /* not found, start at the root */
    } else { (*buf).b_ml.ml_stack_top = 0 as libc::c_int }
    loop 
         /*
   * search downwards in the tree until a data block is found
   */
         {
        hp = mf_get(mfp, bnum, page_count as libc::c_uint);
        if hp.is_null() { current_block = 7552242699231948298; break ; }
        /*
     * update high for insert/delete
     */
        if action == ML_INSERT {
            high += 1
        } else if action == ML_DELETE { high -= 1 }
        dp = (*hp).bh_data as *mut DATA_BL;
        if (*dp).db_id as libc::c_int == DATA_ID {
            /* data block */
            (*buf).b_ml.ml_locked = hp; /* must be pointer block */
            (*buf).b_ml.ml_locked_low = low; // add new entry to stack
            (*buf).b_ml.ml_locked_high = high; /* index not known yet */
            (*buf).b_ml.ml_locked_lineadd = 0 as libc::c_int;
            (*buf).b_ml.ml_flags &= !(ML_LOCKED_DIRTY | ML_LOCKED_POS);
            return hp
        }
        pp = dp as *mut PTR_BL;
        if (*pp).pb_id as libc::c_int != PTR_ID {
            iemsg(gettext(b"E317: pointer block id wrong\x00" as *const u8 as
                              *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char);
            current_block = 8223815779778591167;
            break ;
        } else {
            top = ml_add_stack(buf);
            ip =
                &mut *(*buf).b_ml.ml_stack.offset(top as isize) as
                    *mut infoptr_T;
            (*ip).ip_bnum = bnum;
            (*ip).ip_low = low;
            (*ip).ip_high = high;
            (*ip).ip_index = -(1 as libc::c_int);
            dirty = FALSE;
            idx = 0 as libc::c_int;
            while idx < (*pp).pb_count as libc::c_int {
                t =
                    (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                               isize)).pe_line_count;
                low += t;
                if low > lnum {
                    (*ip).ip_index = idx;
                    bnum =
                        (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                   isize)).pe_bnum;
                    page_count =
                        (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                   isize)).pe_page_count;
                    high = low - 1 as libc::c_int as libc::c_long;
                    low -= t;
                    /*
         * a negative block number may have been changed
         */
                    if bnum < 0 as libc::c_int as libc::c_long {
                        bnum2 = mf_trans_del(mfp, bnum);
                        if bnum != bnum2 {
                            bnum = bnum2;
                            (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                       isize)).pe_bnum
                                = bnum;
                            dirty = TRUE
                        }
                    }
                    break ;
                } else { idx += 1 }
            }
            if idx >= (*pp).pb_count as libc::c_int {
                // past the end: something wrong!
                if lnum > (*buf).b_ml.ml_line_count {
                    iemsgf(gettext(b"E322: line number out of range: %ld past the end\x00"
                                       as *const u8 as *const libc::c_char as
                                       *mut libc::c_char) as
                               *const libc::c_char,
                           lnum - (*buf).b_ml.ml_line_count);
                } else {
                    iemsgf(gettext(b"E323: line count wrong in block %ld\x00"
                                       as *const u8 as *const libc::c_char as
                                       *mut libc::c_char) as
                               *const libc::c_char, bnum);
                }
                current_block = 8223815779778591167;
                break ;
            } else {
                if action == ML_DELETE {
                    let ref mut fresh20 =
                        (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                   isize)).pe_line_count;
                    *fresh20 -= 1;
                    dirty = TRUE
                } else if action == ML_INSERT {
                    let ref mut fresh21 =
                        (*(*pp).pb_pointer.as_mut_ptr().offset(idx as
                                                                   isize)).pe_line_count;
                    *fresh21 += 1;
                    dirty = TRUE
                }
                mf_put(mfp, hp, dirty != 0, false_0 != 0);
            }
        }
    }
    match current_block {
        8223815779778591167 => {
            mf_put(mfp, hp, false_0 != 0, false_0 != 0);
        }
        _ => { }
    }
    /*
   * If action is ML_DELETE or ML_INSERT we have to correct the tree for
   * the incremented/decremented line counts, because there won't be a line
   * inserted/deleted after all.
   */
    if action == ML_DELETE {
        ml_lineadd(buf, 1 as libc::c_int);
    } else if action == ML_INSERT { ml_lineadd(buf, -(1 as libc::c_int)); }
    (*buf).b_ml.ml_stack_top = 0 as libc::c_int;
    return NULL_1 as *mut bhdr_T;
}
/*
 * add an entry to the info pointer stack
 *
 * return number of the new entry
 */
#[c2rust::src_loc = "3051:1"]
unsafe extern "C" fn ml_add_stack(mut buf: *mut buf_T) -> libc::c_int {
    let mut top = (*buf).b_ml.ml_stack_top;
    /* may have to increase the stack size */
    if top == (*buf).b_ml.ml_stack_size {
        /* more than 5 levels??? */
        (*buf).b_ml.ml_stack_size += STACK_INCR;
        let mut new_size =
            (::std::mem::size_of::<infoptr_T>() as
                 libc::c_ulong).wrapping_mul((*buf).b_ml.ml_stack_size as
                                                 libc::c_ulong);
        (*buf).b_ml.ml_stack =
            xrealloc((*buf).b_ml.ml_stack as *mut libc::c_void, new_size) as
                *mut infoptr_T
    }
    (*buf).b_ml.ml_stack_top += 1;
    return top;
}
/*
 * Update the pointer blocks on the stack for inserted/deleted lines.
 * The stack itself is also updated.
 *
 * When an insert/delete line action fails, the line is not inserted/deleted,
 * but the pointer blocks have already been updated. That is fixed here by
 * walking through the stack.
 *
 * Count is the number of lines added, negative if lines have been deleted.
 */
#[c2rust::src_loc = "3078:1"]
unsafe extern "C" fn ml_lineadd(mut buf: *mut buf_T, mut count: libc::c_int) {
    let mut idx: libc::c_int = 0; /* must be pointer block */
    let mut ip = 0 as *mut infoptr_T;
    let mut pp = 0 as *mut PTR_BL;
    let mut mfp = (*buf).b_ml.ml_mfp;
    let mut hp = 0 as *mut bhdr_T;
    idx = (*buf).b_ml.ml_stack_top - 1 as libc::c_int;
    while idx >= 0 as libc::c_int {
        ip =
            &mut *(*buf).b_ml.ml_stack.offset(idx as isize) as *mut infoptr_T;
        hp = mf_get(mfp, (*ip).ip_bnum, 1 as libc::c_int as libc::c_uint);
        if hp.is_null() { break ; }
        pp = (*hp).bh_data as *mut PTR_BL;
        if (*pp).pb_id as libc::c_int != PTR_ID {
            mf_put(mfp, hp, false_0 != 0, false_0 != 0);
            iemsg(gettext(b"E317: pointer block id wrong 2\x00" as *const u8
                              as *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char);
            break ;
        } else {
            let ref mut fresh22 =
                (*(*pp).pb_pointer.as_mut_ptr().offset((*ip).ip_index as
                                                           isize)).pe_line_count;
            *fresh22 += count as libc::c_long;
            (*ip).ip_high += count as libc::c_long;
            mf_put(mfp, hp, true_0 != 0, false_0 != 0);
            idx -= 1
        }
    };
}
/*
 * Resolve a symlink in the last component of a file name.
 * Note that f_resolve() does it for every part of the path, we don't do that
 * here.
 * If it worked returns OK and the resolved link in "buf[MAXPATHL]".
 * Otherwise returns FAIL.
 */
#[no_mangle]
#[c2rust::src_loc = "3110:1"]
pub unsafe extern "C" fn resolve_symlink(mut fname: *const char_u,
                                         mut buf: *mut char_u)
 -> libc::c_int {
    let mut tmp: [char_u; 4096] = [0; 4096];
    let mut ret: libc::c_int = 0;
    let mut depth = 0 as libc::c_int;
    if fname.is_null() { return FAIL }
    /* Put the result so far in tmp[], starting with the original name. */
    xstrlcpy(tmp.as_mut_ptr() as *mut libc::c_char,
             fname as *mut libc::c_char, 4096 as libc::c_int as size_t);
    loop  {
        /* Limit symlink depth to 100, catch recursive loops. */
        depth += 1;
        if depth == 100 as libc::c_int {
            emsgf(gettext(b"E773: Symlink loop for \"%s\"\x00" as *const u8 as
                              *const libc::c_char as *mut libc::c_char) as
                      *const libc::c_char, fname);
            return FAIL
        }
        ret =
            readlink(tmp.as_mut_ptr() as *mut libc::c_char,
                     buf as *mut libc::c_char,
                     (MAXPATHL - 1 as libc::c_int) as size_t) as libc::c_int;
        if ret <= 0 as libc::c_int {
            if errno == EINVAL || errno == ENOENT {
                /* Found non-symlink or not existing file, stop here.
         * When at the first level use the unmodified name, skip the
         * call to vim_FullName(). */
                if depth == 1 as libc::c_int { return FAIL }
                break ;
            } else {
                /* There must be some error reading links, use original name. */
                return FAIL
            }
        } else {
            *buf.offset(ret as isize) = NUL as char_u;
            // Check whether the symlink is relative or absolute.
    // If it's relative, build a new path based on the directory
    // portion of the filename (if any) and the path the symlink
    // points to.
            if path_is_absolute(buf) != 0 {
                strcpy(tmp.as_mut_ptr() as *mut libc::c_char,
                       buf as *mut libc::c_char);
            } else {
                let mut tail = path_tail(tmp.as_mut_ptr());
                if strlen(tail as
                              *mut libc::c_char).wrapping_add(strlen(buf as
                                                                         *mut libc::c_char))
                       >= MAXPATHL as libc::c_ulong {
                    return FAIL
                }
                strcpy(tail as *mut libc::c_char, buf as *mut libc::c_char);
            }
        }
    }
    /*
   * Try to resolve the full name of the file so that the swapfile name will
   * be consistent even when opening a relative symlink from different
   * working directories.
   */
    return vim_FullName(tmp.as_mut_ptr() as *mut libc::c_char,
                        buf as *mut libc::c_char, MAXPATHL as size_t,
                        TRUE != 0);
}
/*
 * Make swap file name out of the file name and a directory name.
 * Returns pointer to allocated memory or NULL.
 */
#[no_mangle]
#[c2rust::src_loc = "3175:1"]
pub unsafe extern "C" fn makeswapname(mut fname: *mut char_u,
                                      mut ffname: *mut char_u,
                                      mut buf: *mut buf_T,
                                      mut dir_name: *mut char_u)
 -> *mut char_u {
    let mut r = 0 as *mut char_u;
    let mut s = 0 as *mut char_u;
    let mut fname_res = fname;
    let mut fname_buf: [char_u; 4096] = [0; 4096];
    let mut len = strlen(dir_name as *mut libc::c_char) as libc::c_int;
    s = dir_name.offset(len as isize);
    if after_pathsep(dir_name as *mut libc::c_char, s as *mut libc::c_char) !=
           0 && len > 1 as libc::c_int &&
           *s.offset(-(1 as libc::c_int) as isize) as libc::c_int ==
               *s.offset(-(2 as libc::c_int) as isize) as libc::c_int {
        // Ends with '//', Use Full path
        r = NULL_1 as *mut char_u;
        s =
            make_percent_swname(dir_name as *mut libc::c_char,
                                fname as *mut libc::c_char) as *mut char_u;
        if !s.is_null() {
            r =
                modname(s as *mut libc::c_char,
                        b".swp\x00" as *const u8 as *const libc::c_char,
                        FALSE != 0) as *mut char_u;
            xfree(s as *mut libc::c_void);
        }
        return r
    }
    /* Expand symlink in the file name, so that we put the swap file with the
   * actual file instead of with the symlink. */
    if resolve_symlink(fname, fname_buf.as_mut_ptr()) == OK {
        fname_res = fname_buf.as_mut_ptr()
    }
    // Prepend a '.' to the swap file name for the current directory.
    r =
        modname(fname_res as *mut libc::c_char,
                b".swp\x00" as *const u8 as *const libc::c_char,
                *dir_name.offset(0 as libc::c_int as isize) as libc::c_int ==
                    '.' as i32 &&
                    *dir_name.offset(1 as libc::c_int as isize) as libc::c_int
                        == NUL) as *mut char_u;
    if r.is_null() {
        /* out of memory */
        return NULL_1 as *mut char_u
    }
    s = get_file_in_dir(r, dir_name);
    xfree(r as *mut libc::c_void);
    return s;
}
/*
 * Get file name to use for swap file or backup file.
 * Use the name of the edited file "fname" and an entry in the 'dir' or 'bdir'
 * option "dname".
 * - If "dname" is ".", return "fname" (swap file in dir of file).
 * - If "dname" starts with "./", insert "dname" in "fname" (swap file
 *   relative to dir of file).
 * - Otherwise, prepend "dname" to the tail of "fname" (swap file in specific
 *   dir).
 *
 * The return value is an allocated string and can be NULL.
 */
#[no_mangle]
#[c2rust::src_loc = "3226:1"]
pub unsafe extern "C" fn get_file_in_dir(mut fname: *mut char_u,
                                         mut dname: *mut char_u)
 -> *mut char_u 
 /* don't use "dirname", it is a global for Alpha */
 {
    let mut t = 0 as *mut char_u;
    let mut tail = 0 as *mut char_u;
    let mut retval = 0 as *mut char_u;
    let mut save_char: libc::c_int = 0;
    tail = path_tail(fname);
    if *dname.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
           && *dname.offset(1 as libc::c_int as isize) as libc::c_int == NUL {
        retval = vim_strsave(fname)
    } else if *dname.offset(0 as libc::c_int as isize) as libc::c_int ==
                  '.' as i32 &&
                  vim_ispathsep(*dname.offset(1 as libc::c_int as isize) as
                                    libc::c_int) != 0 {
        if tail == fname {
            /* no path before file name */
            retval =
                concat_fnames((dname as
                                   *mut libc::c_char).offset(2 as libc::c_int
                                                                 as isize),
                              tail as *mut libc::c_char, TRUE != 0) as
                    *mut char_u
        } else {
            save_char = *tail as libc::c_int;
            *tail = NUL as char_u;
            t =
                concat_fnames(fname as *mut libc::c_char,
                              (dname as
                                   *mut libc::c_char).offset(2 as libc::c_int
                                                                 as isize),
                              TRUE != 0) as *mut char_u;
            *tail = save_char as char_u;
            retval =
                concat_fnames(t as *mut libc::c_char,
                              tail as *mut libc::c_char, TRUE != 0) as
                    *mut char_u;
            xfree(t as *mut libc::c_void);
        }
    } else {
        retval =
            concat_fnames(dname as *mut libc::c_char,
                          tail as *mut libc::c_char, TRUE != 0) as *mut char_u
    }
    return retval;
}
/*
 * Print the ATTENTION message: info about an existing swap file.
 */
#[c2rust::src_loc = "3263:1"]
unsafe extern "C" fn attention_message(mut buf: *mut buf_T,
                                       mut fname: *mut char_u) 
 /* swap file name */
 {
    if !(*buf).b_fname.is_null() {
    } else {
        __assert_fail(b"buf->b_fname != NULL\x00" as *const u8 as
                          *const libc::c_char,
                      b"/home/vole/neovim/src/nvim/memline.c\x00" as *const u8
                          as *const libc::c_char,
                      3269 as libc::c_int as libc::c_uint,
                      (*::std::mem::transmute::<&[u8; 42],
                                                &[libc::c_char; 42]>(b"void attention_message(buf_T *, char_u *)\x00")).as_ptr()); // includes '\n'
    }
    let mut x: time_t = 0;
    let mut sx: time_t = 0;
    let mut p = 0 as *mut libc::c_char;
    no_wait_return += 1;
    emsg(gettext(b"E325: ATTENTION\x00" as *const u8 as *const libc::c_char as
                     *mut libc::c_char) as *mut char_u);
    msg_puts(gettext(b"\nFound a swap file by the name \"\x00" as *const u8 as
                         *const libc::c_char as *mut libc::c_char) as
                 *const libc::c_char);
    msg_home_replace(fname);
    msg_puts(b"\"\n\x00" as *const u8 as *const libc::c_char);
    sx = swapfile_info(fname);
    msg_puts(gettext(b"While opening file \"\x00" as *const u8 as
                         *const libc::c_char as *mut libc::c_char) as
                 *const libc::c_char);
    msg_outtrans((*buf).b_fname);
    msg_puts(b"\"\n\x00" as *const u8 as *const libc::c_char);
    let mut file_info =
        FileInfo{stat:
                     uv_stat_t{st_dev: 0,
                               st_mode: 0,
                               st_nlink: 0,
                               st_uid: 0,
                               st_gid: 0,
                               st_rdev: 0,
                               st_ino: 0,
                               st_size: 0,
                               st_blksize: 0,
                               st_blocks: 0,
                               st_flags: 0,
                               st_gen: 0,
                               st_atim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_mtim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_ctim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_birthtim:
                                   uv_timespec_t{tv_sec: 0, tv_nsec: 0,},},};
    if !os_fileinfo((*buf).b_fname as *mut libc::c_char, &mut file_info) {
        msg_puts(gettext(b"      CANNOT BE FOUND\x00" as *const u8 as
                             *const libc::c_char as *mut libc::c_char) as
                     *const libc::c_char);
    } else {
        msg_puts(gettext(b"             dated: \x00" as *const u8 as
                             *const libc::c_char as *mut libc::c_char) as
                     *const libc::c_char);
        x = file_info.stat.st_mtim.tv_sec;
        p = ctime(&mut x);
        if p.is_null() {
            msg_puts(b"(invalid)\n\x00" as *const u8 as *const libc::c_char);
        } else { msg_puts(p as *const libc::c_char); }
        if sx != 0 as libc::c_int as libc::c_long && x > sx {
            msg_puts(gettext(b"      NEWER than swap file!\n\x00" as *const u8
                                 as *const libc::c_char as *mut libc::c_char)
                         as *const libc::c_char);
        }
    }
    /* Some of these messages are long to allow translation to
   * other languages. */
    msg_puts(gettext(b"\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes.  Quit, or continue with caution.\n\x00"
                         as *const u8 as *const libc::c_char as
                         *mut libc::c_char) as *const libc::c_char);
    msg_puts(gettext(b"(2) An edit session for this file crashed.\n\x00" as
                         *const u8 as *const libc::c_char as
                         *mut libc::c_char) as *const libc::c_char);
    msg_puts(gettext(b"    If this is the case, use \":recover\" or \"vim -r \x00"
                         as *const u8 as *const libc::c_char as
                         *mut libc::c_char) as *const libc::c_char);
    msg_outtrans((*buf).b_fname);
    msg_puts(gettext(b"\"\n    to recover the changes (see \":help recovery\").\n\x00"
                         as *const u8 as *const libc::c_char as
                         *mut libc::c_char) as *const libc::c_char);
    msg_puts(gettext(b"    If you did this already, delete the swap file \"\x00"
                         as *const u8 as *const libc::c_char as
                         *mut libc::c_char) as *const libc::c_char);
    msg_outtrans(fname);
    msg_puts(gettext(b"\"\n    to avoid this message.\n\x00" as *const u8 as
                         *const libc::c_char as *mut libc::c_char) as
                 *const libc::c_char);
    cmdline_row = msg_row;
    no_wait_return -= 1;
}
/*
 * Trigger the SwapExists autocommands.
 * Returns a value for equivalent to do_dialog() (see below):
 * 0: still need to ask for a choice
 * 1: open read-only
 * 2: edit anyway
 * 3: recover
 * 4: delete it
 * 5: quit
 * 6: abort
 */
#[c2rust::src_loc = "3325:1"]
unsafe extern "C" fn do_swapexists(mut buf: *mut buf_T,
                                   mut fname: *mut char_u) -> libc::c_int {
    set_vim_var_string(VV_SWAPNAME, fname as *mut libc::c_char,
                       -(1 as libc::c_int) as ptrdiff_t);
    set_vim_var_string(VV_SWAPCHOICE, NULL_1 as *const libc::c_char,
                       -(1 as libc::c_int) as ptrdiff_t);
    /* Trigger SwapExists autocommands with <afile> set to the file being
   * edited.  Disallow changing directory here. */
    allbuf_lock += 1;
    apply_autocmds(EVENT_SWAPEXISTS, (*buf).b_fname, NULL_1 as *mut char_u,
                   FALSE != 0, NULL_1 as *mut buf_T);
    allbuf_lock -= 1;
    set_vim_var_string(VV_SWAPNAME, NULL_1 as *const libc::c_char,
                       -(1 as libc::c_int) as ptrdiff_t);
    match *get_vim_var_str(VV_SWAPCHOICE as libc::c_int) as libc::c_int {
        111 => { return 1 as libc::c_int }
        101 => { return 2 as libc::c_int }
        114 => { return 3 as libc::c_int }
        100 => { return 4 as libc::c_int }
        113 => { return 5 as libc::c_int }
        97 => { return 6 as libc::c_int }
        _ => { }
    }
    return 0 as libc::c_int;
}
// / Find out what name to use for the swap file for buffer 'buf'.
// /
// / Several names are tried to find one that does not exist. Last directory in
// / option is automatically created.
// /
// / @note If BASENAMELEN is not correct, you will get error messages for
// /   not being able to open the swap or undo file.
// / @note May trigger SwapExists autocmd, pointers may change!
// /
// / @param[in]  buf  Buffer for which swap file names needs to be found.
// / @param[in,out]  dirp  Pointer to a list of directories. When out of memory,
// /                       is set to NULL. Is advanced to the next directory in
// /                       the list otherwise.
// / @param[in]  old_fname  Allowed existing swap file name. Except for this
// /                        case, name of the non-existing file is used.
// / @param[in,out]  found_existing_dir  If points to true, then new directory
// /                                     for swap file is not created. At first
// /                                     findswapname() call this argument must
// /                                     point to false. This parameter may only
// /                                     be set to true by this function, it is
// /                                     never set to false.
// /
// / @return [allocated] Name of the swap file.
#[c2rust::src_loc = "3373:1"]
unsafe extern "C" fn findswapname(mut buf: *mut buf_T,
                                  mut dirp: *mut *mut libc::c_char,
                                  mut old_fname: *mut libc::c_char,
                                  mut found_existing_dir: *mut bool)
 -> *mut libc::c_char {
    let mut fname = 0 as *mut libc::c_char;
    let mut n: size_t = 0;
    let mut dir_name = 0 as *mut libc::c_char;
    let mut buf_fname = (*buf).b_fname as *mut libc::c_char;
    /*
   * Isolate a directory name from *dirp and put it in dir_name.
   * First allocate some memory to put the directory name in.
   */
    let dir_len =
        strlen(*dirp).wrapping_add(1 as libc::c_int as libc::c_ulong);
    dir_name = xmalloc(dir_len) as *mut libc::c_char;
    copy_option_part(dirp as *mut *mut char_u, dir_name as *mut char_u,
                     dir_len,
                     b",\x00" as *const u8 as *const libc::c_char as
                         *mut libc::c_char);
    /*
   * we try different names until we find one that does not exist yet
   */
    fname =
        makeswapname(buf_fname as *mut char_u, (*buf).b_ffname, buf,
                     dir_name as *mut char_u) as *mut libc::c_char;
    while !fname.is_null() {
        n = strlen(fname);
        if n == 0 as libc::c_int as libc::c_ulong {
            // safety check
            let mut ptr_ =
                &mut fname as *mut *mut libc::c_char as
                    *mut *mut libc::c_void;
            xfree(*ptr_);
            *ptr_ = NULL_1 as *mut libc::c_void;
            break ;
        } else {
            // check if the swapfile already exists
    // Extra security check: When a swap file is a symbolic link, this
    // is most likely a symlink attack.
            let mut file_info =
                FileInfo{stat:
                             uv_stat_t{st_dev: 0,
                                       st_mode: 0,
                                       st_nlink: 0,
                                       st_uid: 0,
                                       st_gid: 0,
                                       st_rdev: 0,
                                       st_ino: 0,
                                       st_size: 0,
                                       st_blksize: 0,
                                       st_blocks: 0,
                                       st_flags: 0,
                                       st_gen: 0,
                                       st_atim:
                                           uv_timespec_t{tv_sec: 0,
                                                         tv_nsec: 0,},
                                       st_mtim:
                                           uv_timespec_t{tv_sec: 0,
                                                         tv_nsec: 0,},
                                       st_ctim:
                                           uv_timespec_t{tv_sec: 0,
                                                         tv_nsec: 0,},
                                       st_birthtim:
                                           uv_timespec_t{tv_sec: 0,
                                                         tv_nsec: 0,},},};
            let mut file_or_link_found =
                os_fileinfo_link(fname, &mut file_info);
            if !file_or_link_found { break ; }
            // A file name equal to old_fname is OK to use.
            if !old_fname.is_null() &&
                   path_fnamecmp(fname as *const libc::c_char,
                                 old_fname as *const libc::c_char) ==
                       0 as libc::c_int {
                break ;
            }
            // get here when file already exists
            if *fname.offset(n.wrapping_sub(2 as libc::c_int as libc::c_ulong)
                                 as isize) as libc::c_int == 'w' as i32 &&
                   *fname.offset(n.wrapping_sub(1 as libc::c_int as
                                                    libc::c_ulong) as isize)
                       as libc::c_int == 'p' as i32 {
                // first try
                // If we get here the ".swp" file really exists.
      // Give an error message, unless recovering, no file name, we are
      // viewing a help file or when the path of the file is different
      // (happens when all .swp files are in one directory).
                if recoverymode == 0 && !buf_fname.is_null() && !(*buf).b_help
                       && (*buf).b_flags & BF_DUMMY == 0 {
                    let mut fd: libc::c_int = 0;
                    let mut b0 =
                        block0{b0_id: [0; 2],
                               b0_version: [0; 10],
                               b0_page_size: [0; 4],
                               b0_mtime: [0; 4],
                               b0_ino: [0; 4],
                               b0_pid: [0; 4],
                               b0_uname: [0; 40],
                               b0_hname: [0; 40],
                               b0_fname: [0; 900],
                               b0_magic_long: 0,
                               b0_magic_int: 0,
                               b0_magic_short: 0,
                               b0_magic_char: 0,};
                    let mut differ = FALSE;
                    // Try to read block 0 from the swap file to get the original
        // file name (and inode number).
                    fd = os_open(fname, O_RDONLY, 0 as libc::c_int);
                    if fd >= 0 as libc::c_int {
                        if read_eintr(fd,
                                      &mut b0 as *mut block0 as
                                          *mut libc::c_void,
                                      ::std::mem::size_of::<block0>() as
                                          libc::c_ulong) as libc::c_ulong ==
                               ::std::mem::size_of::<block0>() as
                                   libc::c_ulong {
                            // If the swapfile has the same directory as the
            // buffer don't compare the directory names, they can
            // have a different mountpoint.
                            if b0.b0_fname[(B0_FNAME_SIZE_ORG -
                                                2 as libc::c_int) as usize] as
                                   libc::c_int & B0_SAME_DIR != 0 {
                                if path_fnamecmp(path_tail((*buf).b_ffname) as
                                                     *const libc::c_char,
                                                 path_tail(b0.b0_fname.as_mut_ptr())
                                                     as *const libc::c_char)
                                       != 0 as libc::c_int ||
                                       !same_directory(fname as *mut char_u,
                                                       (*buf).b_ffname) {
                                    // Symlinks may point to the same file even
                // when the name differs, need to check the
                // inode too.
                                    expand_env(b0.b0_fname.as_mut_ptr(),
                                               NameBuff.as_mut_ptr(),
                                               MAXPATHL);
                                    if fnamecmp_ino((*buf).b_ffname,
                                                    NameBuff.as_mut_ptr(),
                                                    char_to_long(b0.b0_ino.as_mut_ptr()))
                                       {
                                        differ = TRUE
                                    }
                                }
                            } else {
                                // The name in the swap file may be
              // "~user/path/file".  Expand it first.
                                expand_env(b0.b0_fname.as_mut_ptr(),
                                           NameBuff.as_mut_ptr(), MAXPATHL);
                                if fnamecmp_ino((*buf).b_ffname,
                                                NameBuff.as_mut_ptr(),
                                                char_to_long(b0.b0_ino.as_mut_ptr()))
                                   {
                                    differ = TRUE
                                }
                            }
                        }
                        close(fd);
                    }
                    // give the ATTENTION message when there is an old swap file
        // for the current file, and the buffer was not recovered. */
                    if differ == false_0 &&
                           (*curbuf).b_flags & BF_RECOVERED == 0 &&
                           vim_strchr(p_shm,
                                      SHM_ATTENTION as libc::c_int).is_null()
                       {
                        let mut choice = 0 as libc::c_int;
                        process_still_running = false_0 != 0;
                        // It's safe to delete the swap file if all these are true:
          // - the edited file exists
          // - the swap file has no changes and looks OK
                        if os_path_exists((*buf).b_fname) as libc::c_int != 0
                               && swapfile_unchanged(fname) != 0 {
                            choice = 4 as libc::c_int;
                            if p_verbose > 0 as libc::c_int as libc::c_long {
                                verb_msg(gettext(b"Found a swap file that is not useful, deleting it\x00"
                                                     as *const u8 as
                                                     *const libc::c_char as
                                                     *mut libc::c_char));
                            }
                        }
                        // If there is a SwapExists autocommand and we can handle the
          // response, trigger it.  It may return 0 to ask the user anyway.
                        if choice == 0 as libc::c_int &&
                               swap_exists_action != SEA_NONE &&
                               has_autocmd(EVENT_SWAPEXISTS,
                                           buf_fname as *mut char_u, buf) as
                                   libc::c_int != 0 {
                            choice = do_swapexists(buf, fname as *mut char_u)
                        }
                        if choice == 0 as libc::c_int {
                            // Show info about the existing swap file.
                            attention_message(buf, fname as *mut char_u);
                            // We don't want a 'q' typed at the more-prompt
            // interrupt loading a file.
                            ::std::ptr::write_volatile(&mut got_int as
                                                           *mut libc::c_int,
                                                       false_0);
                            // If vimrc has "simalt ~x" we don't want it to
            // interfere with the prompt here.
                            flush_buffers(FLUSH_TYPEAHEAD);
                        }
                        if swap_exists_action != SEA_NONE &&
                               choice == 0 as libc::c_int {
                            let sw_msg_1: *const libc::c_char =
                                gettext(b"Swap file \"\x00" as *const u8 as
                                            *const libc::c_char as
                                            *mut libc::c_char);
                            let sw_msg_2: *const libc::c_char =
                                gettext(b"\" already exists!\x00" as *const u8
                                            as *const libc::c_char as
                                            *mut libc::c_char);
                            let fname_len = strlen(fname);
                            let sw_msg_1_len = strlen(sw_msg_1);
                            let sw_msg_2_len = strlen(sw_msg_2);
                            let name_len =
                                sw_msg_1_len.wrapping_add(fname_len).wrapping_add(sw_msg_2_len).wrapping_add(5
                                                                                                                 as
                                                                                                                 libc::c_int
                                                                                                                 as
                                                                                                                 libc::c_ulong);
                            let name = xmalloc(name_len) as *mut libc::c_char;
                            memcpy(name as *mut libc::c_void,
                                   sw_msg_1 as *const libc::c_void,
                                   sw_msg_1_len.wrapping_add(1 as libc::c_int
                                                                 as
                                                                 libc::c_ulong));
                            home_replace(NULL_1 as *const buf_T,
                                         fname as *mut char_u,
                                         &mut *name.offset(sw_msg_1_len as
                                                               isize) as
                                             *mut libc::c_char as *mut char_u,
                                         fname_len, true_0 != 0);
                            xstrlcat(name, sw_msg_2, name_len);
                            choice =
                                do_dialog(VIM_WARNING,
                                          gettext(b"VIM - ATTENTION\x00" as
                                                      *const u8 as
                                                      *const libc::c_char as
                                                      *mut libc::c_char) as
                                              *mut char_u,
                                          name as *mut char_u,
                                          if process_still_running as
                                                 libc::c_int != 0 {
                                              gettext(b"&Open Read-Only\n&Edit anyway\n&Recover\n&Quit\n&Abort\x00"
                                                          as *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char)
                                                  as *mut char_u
                                          } else {
                                              gettext(b"&Open Read-Only\n&Edit anyway\n&Recover\n&Delete it\n&Quit\n&Abort\x00"
                                                          as *const u8 as
                                                          *const libc::c_char
                                                          as
                                                          *mut libc::c_char)
                                                  as *mut char_u
                                          }, 1 as libc::c_int,
                                          NULL_1 as *mut char_u, false_0);
                            if process_still_running as libc::c_int != 0 &&
                                   choice >= 4 as libc::c_int {
                                choice += 1
                                // Skip missing "Delete it" button.
                            }
                            xfree(name as *mut libc::c_void);
                            // pretend screen didn't scroll, need redraw anyway
                            msg_reset_scroll();
                        }
                        if choice > 0 as libc::c_int {
                            match choice {
                                1 => { (*buf).b_p_ro = TRUE }
                                3 => { swap_exists_action = SEA_RECOVER }
                                4 => { os_remove(fname); }
                                5 => { swap_exists_action = SEA_QUIT }
                                6 => {
                                    swap_exists_action = SEA_QUIT;
                                    ::std::ptr::write_volatile(&mut got_int as
                                                                   *mut libc::c_int,
                                                               TRUE)
                                }
                                2 | _ => { }
                            }
                            // If the file was deleted this fname can be used.
                            if !os_path_exists(fname as *mut char_u) {
                                break ;
                            }
                        } else {
                            msg_puts(b"\n\x00" as *const u8 as
                                         *const libc::c_char);
                            if msg_silent == 0 as libc::c_int {
                                /* call wait_return() later */
                                need_wait_return = TRUE
                            }
                        }
                    }
                }
            }
            /*
     * Change the ".swp" extension to find another file that can be used.
     * First decrement the last char: ".swo", ".swn", etc.
     * If that still isn't enough decrement the last but one char: ".svz"
     * Can happen when editing many "No Name" buffers.
     */
            if *fname.offset(n.wrapping_sub(1 as libc::c_int as libc::c_ulong)
                                 as isize) as libc::c_int == 'a' as i32 {
                /* ".s?a" */
                if *fname.offset(n.wrapping_sub(2 as libc::c_int as
                                                    libc::c_ulong) as isize)
                       as libc::c_int == 'a' as i32 {
                    /* ".saa": tried enough, give up */
                    emsg(gettext(b"E326: Too many swap files found\x00" as
                                     *const u8 as *const libc::c_char as
                                     *mut libc::c_char) as
                             *mut char_u); /* ".svz", ".suz", etc. */
                    let mut ptr__0 =
                        &mut fname as *mut *mut libc::c_char as
                            *mut *mut libc::c_void;
                    xfree(*ptr__0);
                    *ptr__0 = NULL_1 as *mut libc::c_void;
                    break ;
                } else {
                    let ref mut fresh23 =
                        *fname.offset(n.wrapping_sub(2 as libc::c_int as
                                                         libc::c_ulong) as
                                          isize);
                    *fresh23 -= 1;
                    *fname.offset(n.wrapping_sub(1 as libc::c_int as
                                                     libc::c_ulong) as isize)
                        = ('z' as i32 + 1 as libc::c_int) as libc::c_char
                }
            }
            let ref mut fresh24 =
                *fname.offset(n.wrapping_sub(1 as libc::c_int as
                                                 libc::c_ulong) as isize);
            *fresh24 -= 1
        }
        /* ".swo", ".swn", etc. */
    }
    if os_isdir(dir_name as *mut char_u) {
        *found_existing_dir = true_0 != 0
    } else if !*found_existing_dir && **dirp as libc::c_int == NUL {
        let mut ret: libc::c_int = 0;
        let mut failed_dir = 0 as *mut libc::c_char;
        ret =
            os_mkdir_recurse(dir_name, 0o755 as libc::c_int, &mut failed_dir);
        if ret != 0 as libc::c_int {
            emsgf(gettext(b"E303: Unable to create directory \"%s\" for swap file, recovery impossible: %s\x00"
                              as *const u8 as *const libc::c_char as
                              *mut libc::c_char) as *const libc::c_char,
                  failed_dir, uv_strerror(ret));
            xfree(failed_dir as *mut libc::c_void);
        }
    }
    xfree(dir_name as *mut libc::c_void);
    return fname;
}
#[c2rust::src_loc = "3609:1"]
unsafe extern "C" fn b0_magic_wrong(mut b0p: *mut ZERO_BL) -> libc::c_int {
    return ((*b0p).b0_magic_long != B0_MAGIC_LONG ||
                (*b0p).b0_magic_int != B0_MAGIC_INT as libc::c_int ||
                (*b0p).b0_magic_short as libc::c_int !=
                    B0_MAGIC_SHORT as libc::c_short as libc::c_int ||
                (*b0p).b0_magic_char as libc::c_int != B0_MAGIC_CHAR) as
               libc::c_int;
}
/*
 * Compare current file name with file name from swap file.
 * Try to use inode numbers when possible.
 * Return non-zero when files are different.
 *
 * When comparing file names a few things have to be taken into consideration:
 * - When working over a network the full path of a file depends on the host.
 *   We check the inode number if possible.  It is not 100% reliable though,
 *   because the device number cannot be used over a network.
 * - When a file does not exist yet (editing a new file) there is no inode
 *   number.
 * - The file name in a swap file may not be valid on the current host.  The
 *   "~user" form is used whenever possible to avoid this.
 *
 * This is getting complicated, let's make a table:
 *
 *		ino_c  ino_s  fname_c  fname_s	differ =
 *
 * both files exist -> compare inode numbers:
 *		!= 0   != 0	X	 X	ino_c != ino_s
 *
 * inode number(s) unknown, file names available -> compare file names
 *		== 0	X	OK	 OK	fname_c != fname_s
 *		 X     == 0	OK	 OK	fname_c != fname_s
 *
 * current file doesn't exist, file for swap file exist, file name(s) not
 * available -> probably different
 *		== 0   != 0    FAIL	 X	TRUE
 *		== 0   != 0	X	FAIL	TRUE
 *
 * current file exists, inode for swap unknown, file name(s) not
 * available -> probably different
 *		!= 0   == 0    FAIL	 X	TRUE
 *		!= 0   == 0	X	FAIL	TRUE
 *
 * current file doesn't exist, inode for swap unknown, one file name not
 * available -> probably different
 *		== 0   == 0    FAIL	 OK	TRUE
 *		== 0   == 0	OK	FAIL	TRUE
 *
 * current file doesn't exist, inode for swap unknown, both file names not
 * available -> compare file names
 *		== 0   == 0    FAIL	FAIL	fname_c != fname_s
 *
 * Only the last 32 bits of the inode will be used. This can't be changed
 * without making the block 0 incompatible with 32 bit versions.
 */
#[c2rust::src_loc = "3665:1"]
unsafe extern "C" fn fnamecmp_ino(mut fname_c: *mut char_u,
                                  mut fname_s: *mut char_u,
                                  mut ino_block0: libc::c_long) -> bool {
    let mut ino_c = 0 as libc::c_int as uint64_t; /* ino of current file */
    let mut ino_s: uint64_t = 0; /* ino of file from swap file */
    let mut buf_c: [char_u; 4096] = [0; 4096]; /* full path of fname_c */
    let mut buf_s: [char_u; 4096] = [0; 4096]; /* full path of fname_s */
    let mut retval_c: libc::c_int = 0; /* flag: buf_c valid */
    let mut retval_s: libc::c_int = 0; /* flag: buf_s valid */
    let mut file_info =
        FileInfo{stat:
                     uv_stat_t{st_dev: 0,
                               st_mode: 0,
                               st_nlink: 0,
                               st_uid: 0,
                               st_gid: 0,
                               st_rdev: 0,
                               st_ino: 0,
                               st_size: 0,
                               st_blksize: 0,
                               st_blocks: 0,
                               st_flags: 0,
                               st_gen: 0,
                               st_atim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_mtim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_ctim: uv_timespec_t{tv_sec: 0, tv_nsec: 0,},
                               st_birthtim:
                                   uv_timespec_t{tv_sec: 0, tv_nsec: 0,},},};
    if os_fileinfo(fname_c as *mut libc::c_char, &mut file_info) {
        ino_c = os_fileinfo_inode(&mut file_info)
    }
    /*
   * First we try to get the inode from the file name, because the inode in
   * the swap file may be outdated.  If that fails (e.g. this path is not
   * valid on this machine), use the inode from block 0.
   */
    if os_fileinfo(fname_s as *mut libc::c_char, &mut file_info) {
        ino_s = os_fileinfo_inode(&mut file_info)
    } else { ino_s = ino_block0 as uint64_t }
    if ino_c != 0 && ino_s != 0 { return ino_c != ino_s }
    /*
   * One of the inode numbers is unknown, try a forced vim_FullName() and
   * compare the file names.
   */
    retval_c =
        vim_FullName(fname_c as *mut libc::c_char,
                     buf_c.as_mut_ptr() as *mut libc::c_char,
                     MAXPATHL as size_t, TRUE != 0);
    retval_s =
        vim_FullName(fname_s as *mut libc::c_char,
                     buf_s.as_mut_ptr() as *mut libc::c_char,
                     MAXPATHL as size_t, TRUE != 0);
    if retval_c == OK && retval_s == OK {
        return strcmp(buf_c.as_mut_ptr() as *mut libc::c_char,
                      buf_s.as_mut_ptr() as *mut libc::c_char) !=
                   0 as libc::c_int
    }
    /*
   * Can't compare inodes or file names, guess that the files are different,
   * unless both appear not to exist at all, then compare with the file name
   * in the swap file.
   */
    if ino_s == 0 as libc::c_int as libc::c_ulong &&
           ino_c == 0 as libc::c_int as libc::c_ulong && retval_c == FAIL &&
           retval_s == FAIL {
        return strcmp(fname_c as *mut libc::c_char,
                      fname_s as *mut libc::c_char) != 0 as libc::c_int
    }
    return true_0 != 0;
}
/*
 * Move a long integer into a four byte character array.
 * Used for machine independency in block zero.
 */
#[c2rust::src_loc = "3721:1"]
unsafe extern "C" fn long_to_char(mut n: libc::c_long, mut s: *mut char_u) {
    *s.offset(0 as libc::c_int as isize) =
        (n & 0xff as libc::c_int as libc::c_long) as char_u;
    n = (n as libc::c_uint >> 8 as libc::c_int) as libc::c_long;
    *s.offset(1 as libc::c_int as isize) =
        (n & 0xff as libc::c_int as libc::c_long) as char_u;
    n = (n as libc::c_uint >> 8 as libc::c_int) as libc::c_long;
    *s.offset(2 as libc::c_int as isize) =
        (n & 0xff as libc::c_int as libc::c_long) as char_u;
    n = (n as libc::c_uint >> 8 as libc::c_int) as libc::c_long;
    *s.offset(3 as libc::c_int as isize) =
        (n & 0xff as libc::c_int as libc::c_long) as char_u;
}
#[c2rust::src_loc = "3732:1"]
unsafe extern "C" fn char_to_long(mut s: *mut char_u) -> libc::c_long {
    let mut retval: libc::c_long = 0;
    retval = *s.offset(3 as libc::c_int as isize) as libc::c_long;
    retval <<= 8 as libc::c_int;
    retval |= *s.offset(2 as libc::c_int as isize) as libc::c_long;
    retval <<= 8 as libc::c_int;
    retval |= *s.offset(1 as libc::c_int as isize) as libc::c_long;
    retval <<= 8 as libc::c_int;
    retval |= *s.offset(0 as libc::c_int as isize) as libc::c_long;
    return retval;
}
/*
 * Set the flags in the first block of the swap file:
 * - file is modified or not: buf->b_changed
 * - 'fileformat'
 * - 'fileencoding'
 */
#[no_mangle]
#[c2rust::src_loc = "3753:1"]
pub unsafe extern "C" fn ml_setflags(mut buf: *mut buf_T) {
    let mut hp = 0 as *mut bhdr_T;
    let mut b0p = 0 as *mut ZERO_BL;
    if (*buf).b_ml.ml_mfp.is_null() { return }
    hp = (*(*buf).b_ml.ml_mfp).mf_used_last;
    while !hp.is_null() {
        if (*hp).bh_hashitem.mhi_key == 0 as libc::c_int as libc::c_long {
            b0p = (*hp).bh_data as *mut ZERO_BL;
            (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 1 as libc::c_int) as usize] =
                if (*buf).b_changed != 0 {
                    B0_DIRTY
                } else { 0 as libc::c_int } as char_u;
            (*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as usize] =
                ((*b0p).b0_fname[(B0_FNAME_SIZE_ORG - 2 as libc::c_int) as
                                     usize] as libc::c_int & !B0_FF_MASK |
                     get_fileformat(buf) + 1 as libc::c_int) as char_u;
            add_b0_fenc(b0p, buf);
            (*hp).bh_flags |= BH_DIRTY;
            mf_sync((*buf).b_ml.ml_mfp, MFS_ZERO);
            break ;
        } else { hp = (*hp).bh_prev }
    };
}
#[c2rust::src_loc = "3774:9"]
pub const MLCS_MAXL: libc::c_int = 800 as libc::c_int;
/* max no of lines in chunk */
#[c2rust::src_loc = "3775:9"]
pub const MLCS_MINL: libc::c_int = 400 as libc::c_int;
/* should be half of MLCS_MAXL */
/*
 * Keep information for finding byte offset of a line, updtype may be one of:
 * ML_CHNK_ADDLINE: Add len to parent chunk, possibly splitting it
 *	   Careful: ML_CHNK_ADDLINE may cause ml_find_line() to be called.
 * ML_CHNK_DELLINE: Subtract len from parent chunk, possibly deleting it
 * ML_CHNK_UPDLINE: Add len to parent chunk, as a signed entity.
 */
#[c2rust::src_loc = "3784:1"]
unsafe extern "C" fn ml_updatechunk(mut buf: *mut buf_T, mut line: linenr_T,
                                    mut len: libc::c_long,
                                    mut updtype: libc::c_int) {
    static mut ml_upd_lastbuf: *mut buf_T = NULL_1 as *mut buf_T;
    static mut ml_upd_lastline: linenr_T = 0;
    static mut ml_upd_lastcurline: linenr_T = 0;
    static mut ml_upd_lastcurix: libc::c_int = 0;
    let mut curline = ml_upd_lastcurline;
    let mut curix = ml_upd_lastcurix;
    let mut size: libc::c_long = 0;
    let mut curchnk = 0 as *mut chunksize_T;
    let mut rest: libc::c_int = 0;
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    if (*buf).b_ml.ml_usedchunks == -(1 as libc::c_int) ||
           len == 0 as libc::c_int as libc::c_long {
        return
    }
    if (*buf).b_ml.ml_chunksize.is_null() {
        (*buf).b_ml.ml_chunksize =
            xmalloc((::std::mem::size_of::<chunksize_T>() as
                         libc::c_ulong).wrapping_mul(100 as libc::c_int as
                                                         libc::c_ulong)) as
                *mut chunksize_T;
        (*buf).b_ml.ml_numchunks = 100 as libc::c_int;
        (*buf).b_ml.ml_usedchunks = 1 as libc::c_int;
        (*(*buf).b_ml.ml_chunksize.offset(0 as libc::c_int as
                                              isize)).mlcs_numlines =
            1 as libc::c_int;
        (*(*buf).b_ml.ml_chunksize.offset(0 as libc::c_int as
                                              isize)).mlcs_totalsize =
            1 as libc::c_int as libc::c_long
    }
    if updtype == ML_CHNK_UPDLINE &&
           (*buf).b_ml.ml_line_count == 1 as libc::c_int as libc::c_long {
        /*
     * First line in empty buffer from ml_flush_line() -- reset
     */
        (*buf).b_ml.ml_usedchunks = 1 as libc::c_int;
        (*(*buf).b_ml.ml_chunksize.offset(0 as libc::c_int as
                                              isize)).mlcs_numlines =
            1 as libc::c_int;
        (*(*buf).b_ml.ml_chunksize.offset(0 as libc::c_int as
                                              isize)).mlcs_totalsize =
            strlen((*buf).b_ml.ml_line_ptr as *mut libc::c_char) as
                libc::c_long + 1 as libc::c_int as libc::c_long;
        return
    }
    /*
   * Find chunk that our line belongs to, curline will be at start of the
   * chunk.
   */
    if buf != ml_upd_lastbuf ||
           line != ml_upd_lastline + 1 as libc::c_int as libc::c_long ||
           updtype != ML_CHNK_ADDLINE {
        curline = 1 as libc::c_int as linenr_T;
        curix = 0 as libc::c_int;
        while curix < (*buf).b_ml.ml_usedchunks - 1 as libc::c_int &&
                  line >=
                      curline +
                          (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                                isize)).mlcs_numlines
                              as libc::c_long {
            curline +=
                (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                      isize)).mlcs_numlines as
                    libc::c_long;
            curix += 1
        }
    } else if curix < (*buf).b_ml.ml_usedchunks - 1 as libc::c_int &&
                  line >=
                      curline +
                          (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                                isize)).mlcs_numlines
                              as libc::c_long {
        // Adjust cached curix & curline
        curline +=
            (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_numlines
                as libc::c_long;
        curix += 1
    }
    curchnk = (*buf).b_ml.ml_chunksize.offset(curix as isize);
    if updtype == ML_CHNK_DELLINE { len = -len }
    (*curchnk).mlcs_totalsize += len;
    if updtype == ML_CHNK_ADDLINE {
        (*curchnk).mlcs_numlines += 1;
        /* May resize here so we don't have to do it in both cases below */
        if (*buf).b_ml.ml_usedchunks + 1 as libc::c_int >=
               (*buf).b_ml.ml_numchunks {
            (*buf).b_ml.ml_numchunks =
                (*buf).b_ml.ml_numchunks * 3 as libc::c_int /
                    2 as libc::c_int; /* number of entries in block */
            (*buf).b_ml.ml_chunksize =
                xrealloc((*buf).b_ml.ml_chunksize as *mut libc::c_void,
                         (::std::mem::size_of::<chunksize_T>() as
                              libc::c_ulong).wrapping_mul((*buf).b_ml.ml_numchunks
                                                              as
                                                              libc::c_ulong))
                    as *mut chunksize_T
        }
        if (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_numlines >=
               MLCS_MAXL {
            let mut count: libc::c_int = 0;
            let mut idx: libc::c_int = 0;
            let mut text_end: libc::c_int = 0;
            let mut linecnt: libc::c_int = 0;
            memmove((*buf).b_ml.ml_chunksize.offset(curix as
                                                        isize).offset(1 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)
                        as *mut libc::c_void,
                    (*buf).b_ml.ml_chunksize.offset(curix as isize) as
                        *const libc::c_void,
                    (((*buf).b_ml.ml_usedchunks - curix) as
                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<chunksize_T>()
                                                         as libc::c_ulong));
            /* Compute length of first half of lines in the split chunk */
            size = 0 as libc::c_int as libc::c_long;
            linecnt = 0 as libc::c_int;
            while curline < (*buf).b_ml.ml_line_count && linecnt < MLCS_MINL {
                hp = ml_find_line(buf, curline, ML_FIND);
                if hp.is_null() {
                    (*buf).b_ml.ml_usedchunks = -(1 as libc::c_int);
                    return
                }
                dp = (*hp).bh_data as *mut DATA_BL;
                count =
                    ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low +
                         1 as libc::c_int as libc::c_long) as libc::c_int;
                idx = (curline - (*buf).b_ml.ml_locked_low) as libc::c_int;
                curline =
                    (*buf).b_ml.ml_locked_high +
                        1 as libc::c_int as libc::c_long;
                if idx == 0 as libc::c_int {
                    /* first line in block, text at the end */
                    text_end = (*dp).db_txt_end as libc::c_int
                } else {
                    text_end =
                        (*(*dp).db_index.as_mut_ptr().offset((idx -
                                                                  1 as
                                                                      libc::c_int)
                                                                 as isize) &
                             !((1 as libc::c_int as libc::c_uint) <<
                                   (::std::mem::size_of::<libc::c_uint>() as
                                        libc::c_ulong).wrapping_mul(8 as
                                                                        libc::c_int
                                                                        as
                                                                        libc::c_ulong).wrapping_sub(1
                                                                                                        as
                                                                                                        libc::c_int
                                                                                                        as
                                                                                                        libc::c_ulong)))
                            as libc::c_int
                }
                /* Compute index of last line to use in this MEMLINE */
                rest = count - idx; /* Force recalc of curix & curline */
                if linecnt + rest > MLCS_MINL {
                    idx += MLCS_MINL - linecnt - 1 as libc::c_int;
                    linecnt = MLCS_MINL
                } else { idx = count - 1 as libc::c_int; linecnt += rest }
                size +=
                    (text_end as
                         libc::c_uint).wrapping_sub(*(*dp).db_index.as_mut_ptr().offset(idx
                                                                                            as
                                                                                            isize)
                                                        &
                                                        !((1 as libc::c_int as
                                                               libc::c_uint)
                                                              <<
                                                              (::std::mem::size_of::<libc::c_uint>()
                                                                   as
                                                                   libc::c_ulong).wrapping_mul(8
                                                                                                   as
                                                                                                   libc::c_int
                                                                                                   as
                                                                                                   libc::c_ulong).wrapping_sub(1
                                                                                                                                   as
                                                                                                                                   libc::c_int
                                                                                                                                   as
                                                                                                                                   libc::c_ulong)))
                        as libc::c_long
            }
            (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_numlines =
                linecnt;
            (*(*buf).b_ml.ml_chunksize.offset((curix + 1 as libc::c_int) as
                                                  isize)).mlcs_numlines -=
                linecnt;
            (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_totalsize
                = size;
            (*(*buf).b_ml.ml_chunksize.offset((curix + 1 as libc::c_int) as
                                                  isize)).mlcs_totalsize -=
                size;
            (*buf).b_ml.ml_usedchunks += 1;
            ml_upd_lastbuf = NULL_1 as *mut buf_T;
            return
        } else {
            if (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                     isize)).mlcs_numlines >=
                   MLCS_MINL &&
                   curix == (*buf).b_ml.ml_usedchunks - 1 as libc::c_int &&
                   (*buf).b_ml.ml_line_count - line <=
                       1 as libc::c_int as libc::c_long {
                /*
       * We are in the last chunk and it is cheap to crate a new one
       * after this. Do it now to avoid the loop above later on
       */
                curchnk =
                    (*buf).b_ml.ml_chunksize.offset(curix as
                                                        isize).offset(1 as
                                                                          libc::c_int
                                                                          as
                                                                          isize);
                (*buf).b_ml.ml_usedchunks += 1;
                if line == (*buf).b_ml.ml_line_count {
                    (*curchnk).mlcs_numlines = 0 as libc::c_int;
                    (*curchnk).mlcs_totalsize =
                        0 as libc::c_int as libc::c_long
                } else {
                    /*
         * Line is just prior to last, move count for last
         * This is the common case  when loading a new file
         */
                    hp =
                        ml_find_line(buf, (*buf).b_ml.ml_line_count,
                                     ML_FIND); /* Force recalc of curix & curline */
                    if hp.is_null() {
                        (*buf).b_ml.ml_usedchunks = -(1 as libc::c_int);
                        return
                    }
                    dp = (*hp).bh_data as *mut DATA_BL;
                    if (*dp).db_line_count == 1 as libc::c_int as libc::c_long
                       {
                        rest =
                            (*dp).db_txt_end.wrapping_sub((*dp).db_txt_start)
                                as libc::c_int
                    } else {
                        rest =
                            (*(*dp).db_index.as_mut_ptr().offset(((*dp).db_line_count
                                                                      -
                                                                      2 as
                                                                          libc::c_int
                                                                          as
                                                                          libc::c_long)
                                                                     as isize)
                                 &
                                 !((1 as libc::c_int as libc::c_uint) <<
                                       (::std::mem::size_of::<libc::c_uint>()
                                            as
                                            libc::c_ulong).wrapping_mul(8 as
                                                                            libc::c_int
                                                                            as
                                                                            libc::c_ulong).wrapping_sub(1
                                                                                                            as
                                                                                                            libc::c_int
                                                                                                            as
                                                                                                            libc::c_ulong))).wrapping_sub((*dp).db_txt_start)
                                as libc::c_int
                    }
                    (*curchnk).mlcs_totalsize = rest as libc::c_long;
                    (*curchnk).mlcs_numlines = 1 as libc::c_int;
                    (*curchnk.offset(-(1 as libc::c_int) as
                                         isize)).mlcs_totalsize -=
                        rest as libc::c_long;
                    (*curchnk.offset(-(1 as libc::c_int) as
                                         isize)).mlcs_numlines -=
                        1 as libc::c_int
                }
            }
        }
    } else if updtype == ML_CHNK_DELLINE {
        (*curchnk).mlcs_numlines -= 1;
        ml_upd_lastbuf = NULL_1 as *mut buf_T;
        if curix < (*buf).b_ml.ml_usedchunks - 1 as libc::c_int &&
               (*curchnk).mlcs_numlines +
                   (*curchnk.offset(1 as libc::c_int as isize)).mlcs_numlines
                   <= MLCS_MINL {
            curix += 1;
            curchnk = (*buf).b_ml.ml_chunksize.offset(curix as isize)
        } else if curix == 0 as libc::c_int &&
                      (*curchnk).mlcs_numlines <= 0 as libc::c_int {
            (*buf).b_ml.ml_usedchunks -= 1;
            memmove((*buf).b_ml.ml_chunksize as *mut libc::c_void,
                    (*buf).b_ml.ml_chunksize.offset(1 as libc::c_int as isize)
                        as *const libc::c_void,
                    ((*buf).b_ml.ml_usedchunks as
                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<chunksize_T>()
                                                         as libc::c_ulong));
            return
        } else {
            if curix == 0 as libc::c_int ||
                   (*curchnk).mlcs_numlines > 10 as libc::c_int &&
                       (*curchnk).mlcs_numlines +
                           (*curchnk.offset(-(1 as libc::c_int) as
                                                isize)).mlcs_numlines >
                           MLCS_MINL {
                return
            }
        }
        /* Collapse chunks */
        (*curchnk.offset(-(1 as libc::c_int) as isize)).mlcs_numlines +=
            (*curchnk).mlcs_numlines;
        (*curchnk.offset(-(1 as libc::c_int) as isize)).mlcs_totalsize +=
            (*curchnk).mlcs_totalsize;
        (*buf).b_ml.ml_usedchunks -= 1;
        if curix < (*buf).b_ml.ml_usedchunks {
            memmove((*buf).b_ml.ml_chunksize.offset(curix as isize) as
                        *mut libc::c_void,
                    (*buf).b_ml.ml_chunksize.offset(curix as
                                                        isize).offset(1 as
                                                                          libc::c_int
                                                                          as
                                                                          isize)
                        as *const libc::c_void,
                    (((*buf).b_ml.ml_usedchunks - curix) as
                         libc::c_ulong).wrapping_mul(::std::mem::size_of::<chunksize_T>()
                                                         as libc::c_ulong));
        }
        return
    }
    ml_upd_lastbuf = buf;
    ml_upd_lastline = line;
    ml_upd_lastcurline = curline;
    ml_upd_lastcurix = curix;
}
// / Find offset for line or line with offset.
// /
// / @param buf buffer to use
// / @param lnum if > 0, find offset of lnum, store offset in offp
// /             if == 0, return line with offset *offp
// / @param offp Location where offset of line is stored, or to read offset to
// /             use to find line. In the later case, store remaining offset.
// / @param no_ff ignore 'fileformat' option, always use one byte for NL.
// /
// / @return -1 if information is not available
#[no_mangle]
#[c2rust::src_loc = "3984:1"]
pub unsafe extern "C" fn ml_find_line_or_offset(mut buf: *mut buf_T,
                                                mut lnum: linenr_T,
                                                mut offp: *mut libc::c_long,
                                                mut no_ff: bool)
 -> libc::c_long {
    let mut curline: linenr_T = 0; /* number of entries in block */
    let mut curix: libc::c_int = 0;
    let mut size: libc::c_long = 0;
    let mut hp = 0 as *mut bhdr_T;
    let mut dp = 0 as *mut DATA_BL;
    let mut count: libc::c_int = 0;
    let mut idx: libc::c_int = 0;
    let mut start_idx: libc::c_int = 0;
    let mut text_end: libc::c_int = 0;
    let mut offset: libc::c_long = 0;
    let mut len: libc::c_int = 0;
    let mut ffdos = (!no_ff && get_fileformat(buf) == EOL_DOS) as libc::c_int;
    let mut extra = 0 as libc::c_int;
    /* take care of cached line first */
    ml_flush_line(curbuf); /* Not a "find offset" and offset 0 _must_ be in line 1 */
    if (*buf).b_ml.ml_usedchunks == -(1 as libc::c_int) ||
           (*buf).b_ml.ml_chunksize.is_null() ||
           lnum < 0 as libc::c_int as libc::c_long {
        return -(1 as libc::c_int) as libc::c_long
    }
    if offp.is_null() {
        offset = 0 as libc::c_int as libc::c_long
    } else { offset = *offp }
    if lnum == 0 as libc::c_int as libc::c_long &&
           offset <= 0 as libc::c_int as libc::c_long {
        return 1 as libc::c_int as libc::c_long
    }
    /*
   * Find the last chunk before the one containing our line. Last chunk is
   * special because it will never qualify
   */
    curline = 1 as libc::c_int as linenr_T;
    size = 0 as libc::c_int as libc::c_long;
    curix = size as libc::c_int;
    while curix < (*buf).b_ml.ml_usedchunks - 1 as libc::c_int &&
              (lnum != 0 as libc::c_int as libc::c_long &&
                   lnum >=
                       curline +
                           (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                                 isize)).mlcs_numlines
                               as libc::c_long ||
                   offset != 0 as libc::c_int as libc::c_long &&
                       offset >
                           size +
                               (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                                     isize)).mlcs_totalsize
                               +
                               (ffdos *
                                    (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                                          isize)).mlcs_numlines)
                                   as libc::c_long) {
        curline +=
            (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_numlines
                as libc::c_long;
        size +=
            (*(*buf).b_ml.ml_chunksize.offset(curix as isize)).mlcs_totalsize;
        if offset != 0 && ffdos != 0 {
            size +=
                (*(*buf).b_ml.ml_chunksize.offset(curix as
                                                      isize)).mlcs_numlines as
                    libc::c_long
        }
        curix += 1
    }
    while lnum != 0 as libc::c_int as libc::c_long && curline < lnum ||
              offset != 0 as libc::c_int as libc::c_long && size < offset {
        if curline > (*buf).b_ml.ml_line_count ||
               { hp = ml_find_line(buf, curline, ML_FIND); hp.is_null() } {
            return -(1 as libc::c_int) as libc::c_long
        }
        dp = (*hp).bh_data as *mut DATA_BL;
        count =
            ((*buf).b_ml.ml_locked_high - (*buf).b_ml.ml_locked_low +
                 1 as libc::c_int as libc::c_long) as libc::c_int;
        idx = (curline - (*buf).b_ml.ml_locked_low) as libc::c_int;
        start_idx = idx;
        if idx == 0 as libc::c_int {
            /* first line in block, text at the end */
            text_end = (*dp).db_txt_end as libc::c_int
        } else {
            text_end =
                (*(*dp).db_index.as_mut_ptr().offset((idx - 1 as libc::c_int)
                                                         as isize) &
                     !((1 as libc::c_int as libc::c_uint) <<
                           (::std::mem::size_of::<libc::c_uint>() as
                                libc::c_ulong).wrapping_mul(8 as libc::c_int
                                                                as
                                                                libc::c_ulong).wrapping_sub(1
                                                                                                as
                                                                                                libc::c_int
                                                                                                as
                                                                                                libc::c_ulong)))
                    as libc::c_int
        }
        /* Compute index of last line to use in this MEMLINE */
        if lnum != 0 as libc::c_int as libc::c_long {
            if curline + (count - idx) as libc::c_long >= lnum {
                idx =
                    (idx as libc::c_long +
                         (lnum - curline - 1 as libc::c_int as libc::c_long))
                        as libc::c_int
            } else { idx = count - 1 as libc::c_int }
        } else {
            extra = 0 as libc::c_int; /* exactly one byte beyond the end */
            while offset >=
                      size + text_end as libc::c_long -
                          (*(*dp).db_index.as_mut_ptr().offset(idx as isize) &
                               !((1 as libc::c_int as libc::c_uint) <<
                                     (::std::mem::size_of::<libc::c_uint>() as
                                          libc::c_ulong).wrapping_mul(8 as
                                                                          libc::c_int
                                                                          as
                                                                          libc::c_ulong).wrapping_sub(1
                                                                                                          as
                                                                                                          libc::c_int
                                                                                                          as
                                                                                                          libc::c_ulong)))
                              as libc::c_int as libc::c_long +
                          ffdos as libc::c_long {
                if ffdos != 0 { size += 1 }
                if idx == count - 1 as libc::c_int {
                    extra = 1 as libc::c_int;
                    break ;
                } else { idx += 1 }
            }
        }
        len =
            (text_end as
                 libc::c_uint).wrapping_sub(*(*dp).db_index.as_mut_ptr().offset(idx
                                                                                    as
                                                                                    isize)
                                                &
                                                !((1 as libc::c_int as
                                                       libc::c_uint) <<
                                                      (::std::mem::size_of::<libc::c_uint>()
                                                           as
                                                           libc::c_ulong).wrapping_mul(8
                                                                                           as
                                                                                           libc::c_int
                                                                                           as
                                                                                           libc::c_ulong).wrapping_sub(1
                                                                                                                           as
                                                                                                                           libc::c_int
                                                                                                                           as
                                                                                                                           libc::c_ulong)))
                as libc::c_int;
        size += len as libc::c_long;
        if offset != 0 as libc::c_int as libc::c_long && size >= offset {
            if size + ffdos as libc::c_long == offset {
                *offp = 0 as libc::c_int as libc::c_long
            } else if idx == start_idx {
                *offp = offset - size + len as libc::c_long
            } else {
                *offp =
                    offset - size + len as libc::c_long -
                        (text_end as
                             libc::c_uint).wrapping_sub(*(*dp).db_index.as_mut_ptr().offset((idx
                                                                                                 -
                                                                                                 1
                                                                                                     as
                                                                                                     libc::c_int)
                                                                                                as
                                                                                                isize)
                                                            &
                                                            !((1 as
                                                                   libc::c_int
                                                                   as
                                                                   libc::c_uint)
                                                                  <<
                                                                  (::std::mem::size_of::<libc::c_uint>()
                                                                       as
                                                                       libc::c_ulong).wrapping_mul(8
                                                                                                       as
                                                                                                       libc::c_int
                                                                                                       as
                                                                                                       libc::c_ulong).wrapping_sub(1
                                                                                                                                       as
                                                                                                                                       libc::c_int
                                                                                                                                       as
                                                                                                                                       libc::c_ulong)))
                            as libc::c_long
            }
            curline += (idx - start_idx + extra) as libc::c_long;
            if curline > (*buf).b_ml.ml_line_count {
                return -(1 as libc::c_int) as libc::c_long
            }
            return curline
        }
        curline =
            (*buf).b_ml.ml_locked_high + 1 as libc::c_int as libc::c_long
    }
    if lnum != 0 as libc::c_int as libc::c_long {
        /* Count extra CR characters. */
        if ffdos != 0 { size += lnum - 1 as libc::c_int as libc::c_long }
        /* Don't count the last line break if 'noeol' and ('bin' or
     * 'nofixeol'). */
        if ((*buf).b_p_fixeol == 0 || (*buf).b_p_bin != 0) &&
               (*buf).b_p_eol == 0 && lnum > (*buf).b_ml.ml_line_count {
            size -= (ffdos + 1 as libc::c_int) as libc::c_long
        }
    }
    return size;
}
// / Goto byte in buffer with offset 'cnt'.
#[no_mangle]
#[c2rust::src_loc = "4101:1"]
pub unsafe extern "C" fn goto_byte(mut cnt: libc::c_long) {
    let mut boff = cnt; // cached line may be dirty
    let mut lnum: linenr_T = 0;
    ml_flush_line(curbuf);
    setpcmark();
    if boff != 0 { boff -= 1 }
    lnum =
        ml_find_line_or_offset(curbuf, 0 as libc::c_int as linenr_T,
                               &mut boff, false_0 != 0);
    if lnum < 1 as libc::c_int as libc::c_long {
        // past the end
        (*curwin).w_cursor.lnum = (*curbuf).b_ml.ml_line_count;
        (*curwin).w_curswant = MAXCOL as libc::c_int;
        coladvance(MAXCOL as libc::c_int);
    } else {
        (*curwin).w_cursor.lnum = lnum;
        (*curwin).w_cursor.col = boff as colnr_T;
        (*curwin).w_cursor.coladd = 0 as libc::c_int;
        (*curwin).w_set_curswant = TRUE
    }
    check_cursor();
    // Make sure the cursor is on the first byte of a multi-byte char.
    mb_adjust_cursor();
}
// / Increment the line pointer "lp" crossing line boundaries as necessary.
// / Return 1 when going to the next line.
// / Return 2 when moving forward onto a NUL at the end of the line).
// / Return -1 when at the end of file.
// / Return 0 otherwise.
#[no_mangle]
#[c2rust::src_loc = "4135:1"]
pub unsafe extern "C" fn inc(mut lp: *mut pos_T) -> libc::c_int {
    // when searching position may be set to end of a line
    if (*lp).col != MAXCOL as libc::c_int {
        let p: *const char_u = ml_get_pos(lp);
        if *p as libc::c_int != NUL {
            // still within line, move to next char (may be NUL)
            let l = utfc_ptr2len(p);
            (*lp).col += l;
            return if *p.offset(l as isize) as libc::c_int != NUL {
                       0 as libc::c_int
                   } else { 2 as libc::c_int }
        }
    }
    if (*lp).lnum != (*curbuf).b_ml.ml_line_count {
        // there is a next line
        (*lp).col = 0 as libc::c_int;
        (*lp).lnum += 1;
        (*lp).coladd = 0 as libc::c_int;
        return 1 as libc::c_int
    }
    return -(1 as libc::c_int);
}
// / Same as inc(), but skip NUL at the end of non-empty lines.
#[no_mangle]
#[c2rust::src_loc = "4157:1"]
pub unsafe extern "C" fn incl(mut lp: *mut pos_T) -> libc::c_int {
    let mut r: libc::c_int = 0;
    r = inc(lp);
    if r >= 1 as libc::c_int && (*lp).col != 0 { r = inc(lp) }
    return r;
}
#[no_mangle]
#[c2rust::src_loc = "4167:1"]
pub unsafe extern "C" fn dec(mut lp: *mut pos_T) -> libc::c_int {
    (*lp).coladd = 0 as libc::c_int;
    if (*lp).col == MAXCOL as libc::c_int {
        // past end of line
        let mut p = ml_get((*lp).lnum);
        (*lp).col = strlen(p as *mut libc::c_char) as colnr_T;
        (*lp).col -= utf_head_off(p, p.offset((*lp).col as isize));
        return 0 as libc::c_int
    }
    if (*lp).col > 0 as libc::c_int {
        // still within line
        (*lp).col -= 1;
        let mut p_0 = ml_get((*lp).lnum);
        (*lp).col -= utf_head_off(p_0, p_0.offset((*lp).col as isize));
        return 0 as libc::c_int
    }
    if (*lp).lnum > 1 as libc::c_int as libc::c_long {
        // there is a prior line
        (*lp).lnum -= 1;
        let mut p_1 = ml_get((*lp).lnum);
        (*lp).col = strlen(p_1 as *mut libc::c_char) as colnr_T;
        (*lp).col -= utf_head_off(p_1, p_1.offset((*lp).col as isize));
        return 1 as libc::c_int
    }
    // at start of file
    return -(1 as libc::c_int);
}
// / Same as dec(), but skip NUL at the end of non-empty lines.
#[no_mangle]
#[c2rust::src_loc = "4199:1"]
pub unsafe extern "C" fn decl(mut lp: *mut pos_T) -> libc::c_int {
    let mut r: libc::c_int = 0;
    r = dec(lp);
    if r == 1 as libc::c_int && (*lp).col != 0 { r = dec(lp) }
    return r;
}
